{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RAYX","text":"RAYX is a powerful, multi-component simulation platform designed to streamline the design and optimization of beamlines in synchrotron light source facilities. At the core of the platform is rayx-core, a high-performance library that delivers precise light tracing capabilities on both CPUs and GPUs. This core library ensures that users can achieve detailed and accurate simulations at high speeds, making it an ideal solution for complex beamline designs.      <p>To simplify the usage of rayx-core, the platform includes rayx, a command-line interface (CLI) tool designed for fast, one-shot tracing of beamlines. It provides comprehensive data on every ray-element intersection, making it especially valuable for generating large datasets efficiently. With its focus on ease of use, rayx empowers users to quickly run simulations and retrieve detailed ray-tracing results.</p> <p>For users who prefer a more visual approach, rayx-ui offers a graphical user interface (GUI) that includes a 3D viewport of the beamline, enabling interactive design and exploration. This GUI provides an intuitive interface to construct and modify beamlines, allowing users to visualize their designs in real-time. rayx-ui not only enhances the design process but also allows users to iteratively optimize configurations based on immediate visual feedback.</p>"},{"location":"#rayx-vs-ray-ui","title":"RAYX vs RAY-UI","text":"<p>RAYX offers several advanced features, including: - Global (not sequential) tracing of beamlines - GPU utilization for accelerated tracing performance - A dedicated mode for tracing multiple beamlines with ease - Objects in RAYX can be grouped for simplified group transformations - A GUI for intuitive beamline design</p>"},{"location":"#installing-or-building-rayx","title":"Installing or Building RAYX","text":"<p>For additional information, please visit our Wiki and read our latest paper, that introduces RAYX to the scientific community. We are committed to delivering stable releases, which can be found here. Please note that the <code>master</code> branch and other branches might be unstable, and building RAYX from the source could lead to unstable software. We recommend this only for developers and experienced users. If you experience issues with our distributed binaries or API, do not hesitate to open an issue. We are keen to provide assistance and develop features as the need arises.</p>"},{"location":"#relevant-publications","title":"Relevant Publications","text":"<p>If you use RAYX in your scientific work, please consider citing our paper:</p> <p>RAYX \u2013 An optics simulation software for synchrotron applications Sven Erdem, Peter Feuer-Forson, Jannis Maier, Felix M\u00f6ller, Enrico Philip Ahlers, Valentin St\u00f6cker, Fanny Zotter, Peter Baumg\u00e4rtel, Jens Viefhaus Review of Scientific Instruments, Vol. 96, Issue 6 (2025) DOI: 10.1063/5.0253857</p> <p>We present RAYX, an advanced optics simulation software for synchrotron applications and the successor to RAY/RAY-UI [Sch\u00e4fers, in Modern Developments in X-Ray and Neutron Optics, Springer, 2008]. RAYX offers a modern, versatile platform designed to accelerate beamline design, optimization, and data analysis, including machine learning workflows. It supports accurate and efficient simulations across a wide spectral range and optical elements, tailored for current and next-generation synchrotron facilities.</p> <p>This publication provides an overview of the software's architecture and capabilities, including GPU acceleration, Python bindings, and GUI support.</p>"},{"location":"how-to-use-mkdocs/","title":"Writing Documentation for RAYX","text":"<p>This site is build from Markdown files inside the <code>docs</code> directory, based on the configuration in <code>mkdocs.yml</code>. The page structure is defined in <code>docs/.nav.yml</code>, see mkdocs-awesome-nav.</p> <p>The API documentation is built using Doxygen together with MkDoxy.</p> <p>Versioning of the site is implemented using Mike. The CI takes care of the necessary steps, but it is also possible to manually add, update or remove versions as needed.</p>"},{"location":"how-to-use-mkdocs/#local-development-setup","title":"Local Development Setup","text":"<p>To build and test the documentation locally, install the python <code>docs</code> dependencies from <code>pyproject.toml</code> as well as <code>doxygen</code> (for the API documentation).</p> <p>With uv setting up a virtual environment and installing locked dependencies is done with:</p> <pre><code>uv sync --locked --group docs\n</code></pre> <p>Then either activate the virtual environment or prefix commands with <code>uv run</code>.</p> <p>Start the live-reloading docs server locally with:</p> <pre><code>mkdocs serve --livereload\n</code></pre>"},{"location":"how-to-use-mkdocs/#temporarily-disabling-mkdoxy","title":"Temporarily disabling MkDoxy","text":"<p>When working on documentation the local server takes some time to check and link the API documentation, even though the <code>Doxygen</code> output is cached to a <code>.mkdoxy</code> dir and only regenerated when necessary. <code>MkDoxy</code> can be temporarily disabled with the environment variable <code>ENABLE_MKDOXY</code></p> <pre><code>ENABLE_MKDOXY=false mkdocs serve\n</code></pre> <p>This is useful when writing documentation pages that don't use the API docs and you want to check the resulting page regularly, e.g. when using a lot of math.</p>"},{"location":"how-to-use-mkdocs/#markup","title":"Markup","text":"<p>Here is a quick overview of some of the available Markdown syntax. You can have a look at the source of this file too. This is also possible directly in the browser for every page on this site.  At the top there is a link to view the source.</p> <p>For a more thorough documentation have a look at the Material for MkDocs reference.</p>"},{"location":"how-to-use-mkdocs/#linking-to-other-pages","title":"Linking to other pages","text":"<p>Using markdown links relative to the current file (not the current page) this syntax is simply:</p> <pre><code>[Home](index.md)\n</code></pre> <p>Home</p>"},{"location":"how-to-use-mkdocs/#images","title":"Images","text":"<p>There are some additional settings available for images that are not part of core markdown, like sizing and captions, see Image Options.</p> <p></p> <p>RAYX Logo with a width of 300px</p>"},{"location":"how-to-use-mkdocs/#lists","title":"Lists","text":"<ul> <li>Unordered</li> <li>List<ul> <li>Nested levels need 4 spaces</li> </ul> </li> </ul> <ol> <li>Ordered</li> <li>List<ol> <li>Next Level</li> <li>Hi mom</li> </ol> </li> </ol> <ul> <li> Unchecked</li> <li> Checked<ul> <li> Nested</li> <li> Works</li> <li> aswell</li> </ul> </li> </ul>"},{"location":"how-to-use-mkdocs/#math","title":"Math","text":"\\[ \\cos x=\\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k)!}x^{2k} \\]"},{"location":"how-to-use-mkdocs/#emojis","title":"Emojis","text":""},{"location":"how-to-use-mkdocs/#source-code","title":"Source code","text":"<ul> <li> Syntax Highlighting</li> <li> Title</li> <li> Annotations</li> <li> Line numbers</li> <li> Highlight lines</li> </ul> Bragg angle computation from Crystal.h<pre><code>/// @brief Computes the bragg angle\n/// @param energy photonenergy of the ray\n/// @param d lattice spacing*2\n/// @param order Diffraction order\n/// @return the bragg angle theta (rad)\nRAYX_FN_ACC double getBraggAngle(double energy, double dSpacing2) {\n    int order = 1;\n    double wavelength = hvlam(energy);\n    double theta_factor = (order * wavelength) / dSpacing2; // (1)!\n\n    // Check for physical validity\n    if (theta_factor &gt; 1.0) {\n        return -1.0;  // No reflection possible\n    }\n\n    double theta = asin(theta_factor);  // In radians\n    return theta;\n}\n</code></pre> <ol> <li> <p> SCIENCE! With inline <code>SCIENCE</code>     Some <code>Bragg</code> related math: \\(n \\lambda = 2 d \\sin \\theta\\)</p> <p>Or as a separate block: $$ n \\lambda = 2 d \\sin \\theta $$</p> </li> </ol>"},{"location":"how-to-use-mkdocs/#admonitions","title":"Admonitions","text":"<p>Admonitions</p> <p>Admonitions are great!</p> Collapsible example <p>Collapsible Admonitions are nice too. Bragg angle computation from Crystal.h<pre><code>/// @brief Computes the bragg angle\n/// @param energy photonenergy of the ray\n/// @param d lattice spacing*2\n/// @param order Diffraction order\n/// @return the bragg angle theta (rad)\nRAYX_FN_ACC double getBraggAngle(double energy, double dSpacing2) {\n    int order = 1;\n    double wavelength = hvlam(energy);\n    double theta_factor = (order * wavelength) / dSpacing2; // (1)!\n\n    // Check for physical validity\n    if (theta_factor &gt; 1.0) {\n        return -1.0;  // No reflection possible\n    }\n\n    double theta = asin(theta_factor);  // In radians\n    return theta;\n}\n</code></pre></p> <ol> <li> SCIENCE! With inline <code>code</code></li> </ol>"},{"location":"how-to-use-mkdocs/#diagrams","title":"Diagrams","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"how-to-use-mkdocs/#inline-api-documentation-with-mkdoxy","title":"Inline API documentation with MkDoxy","text":"<p>This plugin uses <code>Doxygen</code> to generate markdown files from the code comments. You can include parts of the API documentation as Snippets into the written guides using a tag syntax.</p> Tag SyntaxResulting Snippet <pre><code>::: doxy.rayxCore.class.method\nname: rayx::BeamlineNode\nmethod: glm::mat4 getOrientation()\n</code></pre> <p>If there is an error inside the MkDoxy Tag it generates a helpful block with the error, available tags and the corresponding snippet. For example using the tag without any config shows the available projects.</p>"},{"location":"how-to-use-mkdocs/#function-getorientation","title":"function getOrientation","text":"<p>Gets the local orientation (rotation/transform) of this node. <pre><code>virtual glm::dmat4 rayx::BeamlineNode::getOrientation () const = 0\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the local orientation. </p>"},{"location":"Introduction/01-Introduction/","title":"Introduction","text":"<p>RAYX is a command-line tool developed to work in conjunction with RAYX-CORE for the purpose of accurately and efficiently tracing beamlines, as described by .rml files. RAYX-CORE is a specialized library with capabilities for simulating a variety of optical phenomena. The library adopts a modular architecture for the construction of optical elements, comprising three key components: Surface, Cutout, and Behavior. These components are responsible for calculating ray-object collisions and determining the subsequent interactions of the ray, such as reflection or absorption. The primary application of RAYX-CORE is to enable the precise tracing of synchrotron radiation in beamlines associated with electron storage rings.</p> <p>In terms of computational resources, RAYX utilizes the parallel processing capabilities of GPUs, facilitated through the Vulkan API. This approach allows for efficient and accurate ray tracing. For systems without GPU support, RAYX provides an alternative CPU-based tracing option to maintain compatibility across diverse hardware configurations.</p> <p>Further enhancing the project's capabilities, RAYX-UI has been introduced as a real-time rendering interface built upon RAYX-CORE. This interface provides immediate visual feedback on the interactions between rays and optical elements, serving as a valuable tool for adjusting element positions. While initially conceived as a debugging utility, the long-term objective for RAYX-UI is its development into a full-fledged 3D design tool for beamline construction and customization.</p>"},{"location":"Introduction/02-How-to-build/","title":"How to Build","text":"<p>For building and running the project, we recommend using Visual Studio Code (VSCode) as your IDE, along with the C/C++ and CMake Tools extensions. These extensions significantly simplify the building process. However, you are free to use any IDE of your choice. If you are on a UNIX-like system, the <code>compile.sh</code> script can be used for compilation (see using compile.sh).</p>"},{"location":"Introduction/02-How-to-build/#cmake-options","title":"CMake Options:","text":"CMake Option Default value Description <code>RAYX_ENABLE_OPENMP:BOOL</code> <code>ON</code> enable search for OpenMP on your system. If found, build with OpenMP for tracing on CPU <code>RAYX_REQUIRES_OPENMP:BOOL</code> <code>OFF</code> require OpenMP to be found on your system. Otherwise throw an error <code>RAYX_ENABLE_CUDA:BOOL</code> <code>ON</code> enable search for Cuda on your system. If found, build with Cuda for tracing on GPU <code>RAYX_REQUIRES_CUDA:BOOL</code> <code>OFF</code> require Cuda to be found on your system. Otherwise throw an error <code>RAYX_ENABLE_H5:BOOL</code> <code>ON</code> enable search for HDF5 on your system. If found, build with HDF5 for H5 file format support <code>RAYX_REQUIRES_H5:BOOL</code> <code>OFF</code> require HDF5 to be found on your system. Otherwise throw an error <code>RAYX_STATIC_LIB:BOOL</code> <code>OFF</code> this option builds 'rayx-core' as a static library <code>CMAKE_CUDA_ARCHITECTURES:STRING</code> <code>all-major</code> set the cuda device architectures to build for. by default, build for all major architectures"},{"location":"Introduction/02-How-to-build/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Clone the git repository by running one of the following commands:</p> <ul> <li>Using SSH:</li> </ul> <p><code>git clone --recurse-submodules git@github.com:hz-b/rayx.git</code></p> <ul> <li>Using HTTPS:</li> </ul> <p><code>git clone --recurse-submodules https://github.com/hz-b/rayx.git</code></p>"},{"location":"Introduction/02-How-to-build/#on-windows","title":"On Windows","text":""},{"location":"Introduction/02-How-to-build/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install CMake.</li> <li>Install the Vulkan SDK for Windows (at least version 1.3 or newer).</li> <li>Install the HDF5 library.</li> <li>Install Python3, python3-dev, and python3-matplotlib.</li> <li>We recommend using the MSVC compiler for Windows, available through Visual Studio (2019 or newer).</li> <li>Optional (required for Tracing on the GPU):<ul> <li>Install Cuda. Tested with Cuda version 12.5.1</li> <li>Add Cuda to your PATH.</li> </ul> </li> </ul>"},{"location":"Introduction/02-How-to-build/#known-issues","title":"Known Issues","text":"<ul> <li>Installing the VulkanSDK at the root directory of your drive may cause issues. If you encounter problems with the VulkanSDK, consider installing it in a different directory.</li> </ul>"},{"location":"Introduction/02-How-to-build/#building-with-vscode","title":"Building with VSCode","text":"<ul> <li>Open the project in VSCode. You will be prompted to select a build kit (e.g., gcc).</li> <li>Allow the CMake Extension to configure the project.</li> <li>You can then build the project using the build button in the bottom panel.</li> </ul> <p>To use a custom generator for CMake, such as Ninja for faster builds, you can set it in the <code>.vscode/settings.json</code> file. The following is an example configuration for the generator in VSCode: </p>"},{"location":"Introduction/02-How-to-build/#building-with-visual-studio","title":"Building with Visual Studio","text":"<ul> <li>Open a terminal in the project folder.</li> <li>Run the following command, replacing it with your version of Visual Studio:</li> </ul> <p><code>cmake -S . -B build -G \"Visual Studio 16 2019\" -A x64 -DCMAKE_BUILD_TYPE=Release</code></p> <p>see: Cmake Options</p>"},{"location":"Introduction/02-How-to-build/#on-linux","title":"On Linux","text":""},{"location":"Introduction/02-How-to-build/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>Ensure cmake, gcc, gdb, and make are installed and up to date.</li> <li>Install the Vulkan SDK from here. Select a version under Linux -&gt; Ubuntu Packages.</li> <li>Install Python3, python3-dev, and python3-matplotlib.</li> <li>The project leverages libhdf5 for data management and incorporates various other libraries for graphical user interfaces, linear algebra computations, and handling different aspects of the X11 window system. Install the necessary libraries with the following command:</li> <li>Optional (required for Tracing on the GPU):<ul> <li>Install Cuda</li> <li>see Determining Cuda and compiler version</li> </ul> </li> </ul>"},{"location":"Introduction/02-How-to-build/#ubuntu","title":"Ubuntu","text":"<p><code>apt update &amp;&amp; apt -y install libblas-dev liblapack-dev libhdf5-dev libgtk-3-dev pkg-config libxi-dev libxcursor-dev libxinerama-dev libxrandr-dev</code> - Ensure the libraries are installed at <code>/usr/include/hdf5/serial</code> and <code>/usr/lib/x86_64-linux-gnu/hdf5/serial</code>.</p>"},{"location":"Introduction/02-How-to-build/#arch-linux","title":"Arch Linux","text":"<p>Arch Linux users can obtain all necessary packages through pacman, yay, or other package managers. Specific instructions will be provided later.</p>"},{"location":"Introduction/02-How-to-build/#fedora","title":"Fedora","text":"<p>To install the required packages on Fedora, run the following command:</p> <p><code>sudo dnf install cmake gcc gdb vulkan vulkan-tools vulkan-validation-layers hdf5-devel ninja-build gcc-c++ vulkan-loader-devel glslc blas-devel lapack-devel gtk3-devel pkg-config libXi-devel libXcursor-devel libXinerama-devel libXrandr-devel boost</code></p>"},{"location":"Introduction/02-How-to-build/#determining-cuda-and-compiler-version","title":"Determining Cuda and compiler version","text":"<ul> <li>GCC: Depending on the Cuda version, different versions of GCC may be supported. This projects is tested with Cuda version 12.4.1 and GCC version 13.3 Please take a look at the supported versions of GCC for your Cuda installation:<ul> <li>https://stackoverflow.com/questions/6622454/Cuda-incompatible-with-my-gcc-version</li> <li>https://gist.github.com/ax3l/9489132</li> </ul> </li> <li>Clang: Using clang as Cuda compiler is currently not supported.</li> </ul>"},{"location":"Introduction/02-How-to-build/#using-compilesh","title":"Using compile.sh","text":"<p>usage: <code>./compile.sh</code></p>"},{"location":"Introduction/02-How-to-build/#options","title":"Options:","text":"<ul> <li><code>--release</code> build in release mode (default: build in debug mode)</li> <li><code>--cuda</code> enable compilation with Cuda (default: build without Cuda)\\ see Determining Cuda and compiler version \\ example usage: <code>CXX=g++-13 ./compile.sh --cuda</code></li> </ul>"},{"location":"Introduction/02-How-to-install/","title":"How to Install","text":"<p>Welcome to the installation guide for RAYX! This section is a work in progress as we refine our release distribution. If you encounter any issues, we're here to help. Please open an issue on GitHub here. Your feedback helps us improve our documentation and installers based on real user experiences.</p>"},{"location":"Introduction/02-How-to-install/#releases","title":"Releases","text":"<p>You can find the latest releases of RAYX here. Each release includes:</p> <ul> <li>rayx-core: The core library binary.</li> <li>rayx: Command-Line Interface (CLI) application.</li> <li>rayx-ui: Graphical User Interface (GUI) application.</li> <li>Data Files: Includes necessary data, shader, and font files.</li> </ul>"},{"location":"Introduction/02-How-to-install/#dependencies","title":"Dependencies","text":"<p>There are some dependencies that might not be handled by every distributed package, installer or archive. We give a general overview of missing dependencies you might encounter here.</p>"},{"location":"Introduction/02-How-to-install/#rayx-core","title":"rayx-core","text":"<ul> <li>HDF5 Library for faster I/O operations.</li> </ul>"},{"location":"Introduction/02-How-to-install/#rayx-ui","title":"rayx-ui","text":"<ul> <li>GPU driver from AMD, Intel, or NVIDIA.</li> </ul>"},{"location":"Introduction/02-How-to-install/#installation-instructions","title":"Installation Instructions","text":""},{"location":"Introduction/02-How-to-install/#windows","title":"Windows","text":"<p>We provide the following options for Windows:</p> <ul> <li>Portable Version (.zip): No installation required. Just unzip and run.</li> <li>Installer (.exe): An NSIS installer that guides you through the setup process.</li> </ul> <p>Note: You may need to install the Microsoft Visual C++ Redistributable.</p>"},{"location":"Introduction/02-How-to-install/#linux","title":"Linux","text":"<p>We offer several packages for Linux distributions:</p> <ul> <li>Debian Package (.deb): For Debian-based systems like Ubuntu.</li> <li>RPM Package (.rpm): For Red Hat-based systems like Fedora.</li> <li>Tarball (.tar.gz): For other Linux systems. Intended for experienced users comfortable with manual installations.</li> </ul>"},{"location":"Introduction/02-How-to-install/#ubuntu-debian-based-systems","title":"Ubuntu (Debian-based Systems)","text":"<p>To install RAYX on Ubuntu:</p> <ol> <li> <p>Download the <code>.deb</code> package from the releases page.</p> </li> <li> <p>Install the package using:</p> </li> </ol> <pre><code>sudo apt install ./rayx-ui_&lt;version&gt;_amd64.deb\n</code></pre> <p>Replace <code>&lt;version&gt;</code> with the actual version number.</p> <ol> <li>Install Dependencies:</li> </ol> <pre><code>sudo apt-get install libhdf5-dev\n</code></pre>"},{"location":"Introduction/02-How-to-install/#fedora-red-hat-based-systems","title":"Fedora (Red Hat-based Systems)","text":"<p>To install RAYX on Fedora:</p> <ol> <li> <p>Download the <code>.rpm</code> package from the releases page.</p> </li> <li> <p>Install the package using:</p> </li> </ol> <pre><code>sudo dnf install rayx-ui-&lt;version&gt;.rpm\n</code></pre> <p>Replace <code>&lt;version&gt;</code> with the actual version number.</p> <ol> <li>Install Dependencies:</li> </ol> <pre><code>sudo dnf install hdf5\n</code></pre>"},{"location":"Introduction/02-How-to-install/#arch-linux","title":"Arch Linux","text":"<p>While we don't provide a native package for Arch Linux, you can use the tarball or build from source.</p> <p>Install Dependencies:</p> <pre><code>sudo pacman -S hdf5\n</code></pre>"},{"location":"Introduction/02-How-to-install/#installing-from-tarball-targz","title":"Installing from Tarball (.tar.gz)","text":"<p>The tarball is intended for experienced users who prefer manual installation or are using a Linux distribution not directly supported by our <code>.deb</code> or <code>.rpm</code> packages.</p> <p>Steps:</p> <ol> <li> <p>Download the <code>.tar.gz</code> file from the releases page or use the provided tarball.</p> </li> <li> <p>Extract the tarball:</p> </li> </ol> <pre><code>tar -xzf RAYX-&lt;version&gt;-Linux.tar.gz\n</code></pre> <p>This will create a directory named <code>RAYX-&lt;version&gt;-Linux</code>.</p> <ol> <li>Move the extracted files to a directory of your choice (e.g., <code>/opt/rayx</code>):</li> </ol> <pre><code>sudo mv RAYX-&lt;version&gt;-Linux /opt/rayx\n</code></pre> <ol> <li>Add to PATH (optional):</li> </ol> <pre><code>echo 'export PATH=/opt/rayx/bin:$PATH' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <ol> <li>Run RAYX from the installation directory or after adding it to your PATH.</li> </ol> <p>Note: Installing from a tarball does not handle dependencies automatically. You need to ensure all required dependencies are present on your system. Look at the previous sections for guidance.</p> <p>If you have any questions or run into issues during installation, please don't hesitate to open an issue on GitHub. Your input is invaluable in helping us enhance our tools and documentation.</p>"},{"location":"Introduction/03-Getting-Started/","title":"Getting Started","text":"<p>Currently we only support a one over trace for a given beamline file. This means,  you can either use RAY-UI to generate a beamline file or alter an existing one.</p> <p>Here is an example for a simple beamline file \"PlaneMirror.rml\": <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;lab&gt;\n&lt;version&gt;1.1&lt;/version&gt;\n&lt;beamline&gt;\n\n  &lt;object name=\"Matrix Source\" type=\"Matrix Source\"&gt;\n    &lt;param id=\"numberRays\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n    &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n    &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"horDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"verDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"photonEnergyDistributionFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;1&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;1&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n\n  &lt;object name=\"Plane Mirror\" type=\"Plane Mirror\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" auto=\"T\" enabled=\"T\"&gt;40&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" auto=\"T\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"systemMount\" comment=\"standalone\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"premirrorShiftZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha1\" enabled=\"F\"&gt;1&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha2\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha3\" enabled=\"F\"&gt;3&lt;/param&gt;\n    &lt;param id=\"distancePremirrorGrating\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"elementSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.766044443118978&lt;/y&gt;\n      &lt;z&gt;-0.6427876096865393&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.6427876096865393&lt;/y&gt;\n      &lt;z&gt;0.766044443118978&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n\n&lt;/beamline&gt;\n\n&lt;ExtraData&gt;\n&lt;/ExtraData&gt;\n&lt;/lab&gt;\n</code></pre></p> <p>In it we have a matrix source that sends rays onto a plane mirror.  Assuming the beamline file is in the same directory as the binary you can run the CLI of rayx as follows: <pre><code>./rayx -i PlaneMirror.rml\n</code></pre></p> <p>Adding a <code>-p</code> flag will output a footprint of the last element in in the beamline, which was hit by rays. </p>"},{"location":"Introduction/04-How-to-use-rayx-ui/","title":"RAYX-UI User Guide","text":""},{"location":"Introduction/04-How-to-use-rayx-ui/#interface","title":"Interface","text":"<p>Th window in the image above is accessible in the RAYX-UI application once it's opened. The window provides additional options for adjusting the scene you're viewing. Most notably, the \"Open File Dialog\" button (indicated by a red arrow) opens a file dialog that allows you to load your .rml beamline file. Currently, the application expects the h5 file (RAYX output) to be located next to it. In the future, tracing functionality will be directly integrated into the interface.</p> <p>The subsequent camera settings in the interface are intended for advanced users and will not be explained here. If you're unfamiliar with these settings, you likely won't need them. Further down, however, you'll find the \"Save Camera\" and \"Load Camera\" buttons, which enable you to save and load a single camera position. This feature can be useful if you wish to save your camera settings for future use or compare different beamlines from the same vantage point.</p>"},{"location":"Introduction/04-How-to-use-rayx-ui/#basic-navigation-and-control","title":"Basic Navigation and Control","text":"<p>RAYX-UI is an interface designed for real-time visualization of beamline simulations conducted by RAYX-CORE. The application employs keyboard and mouse inputs for navigation and control.</p> <ul> <li>Camera Movement: Use the <code>W</code>, <code>A</code>, <code>S</code>, <code>D</code>, <code>Q</code>, and <code>E</code> keys to move the camera through the 3D space.</li> <li>Adjust Speed: Hold down the <code>Shift</code> key to adjust movement speed.</li> <li>Camera Direction: Right-clicking the mouse activates a mode to control camera direction.</li> <li>Toggle Modes: The application can be toggled between fullscreen and windowed modes using <code>F11</code> and <code>F10</code> keys, respectively.</li> </ul>"},{"location":"Introduction/04-How-to-use-rayx-ui/#color-indicators","title":"Color Indicators","text":"<p>In the visual representation, various colors are used to indicate specific conditions or states:</p> <ul> <li>Just Hit: Rays that have just hit an element are represented in a yellow to orange gradient.</li> <li>Absorbed: Rays that are absorbed by an element are depicted in red.</li> <li>Other: Rays created from other events are white (this most likely indicates an issue in the tracing)</li> </ul> <p>Optical Elements: Optical elements like slits or image planes are displayed in varying shades of blue, with the color gradient used to represent surface orientation.</p>"},{"location":"Introduction/05-How-to-use-rayx/","title":"RAYX Commands","text":"<p>After a successful build, type <code>-h</code> or <code>--help</code> for a summary of all known commands.</p> <p>Hint: <code>-c</code> or <code>--command</code> are accepted. But <code>-command</code> can result in errors.</p> <pre><code>Terminal application for rayx  \nUsage: ./rayx [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n  -c,--ocsv                   Output stored as .csv file.\n  -b,--batch INT              Batch size for Vulkan tracing\n  -B,--benchmark              Benchmark application and output to stdout\n  -X,--gpu                    Tracing on GPU\n  -x,--cpu                    Tracing on CPU\n  -p,--plot                   Plot output footprints and histograms.\n  -l,--list                   List available devices\n  -d,--device INT             Device ID\n  -i,--input TEXT             Input RML File or Directory.\n  -o,--output TEXT            Output path or filename\n  -v,--version                Print application metadata\n  -f                          Fix the seed to RAYX::FIXED_SEED (Uses default)\n  -s,--seed INT               Provide a user-defined seed\n  -S,--sequential             Trace rays sequentially\n  -V,--verbose                Print detailed debug and trace info\n  -F,--format TEXT            Format output CSV / H5 data\n  -m,--maxEvents INT          Maximum number of recorded events per ray\n  -R,--record-element INT     Record events only for a specific element (Default: -1 to record for all)\n</code></pre>"},{"location":"Introduction/05-How-to-use-rayx/#command-descriptions","title":"Command descriptions","text":"Command name Description <code>--help</code> Prints the help message. <code>--ocsv</code> Store the result as a <code>.csv</code> (defaults to <code>.h5</code>). Not recommended for large ray counts. <code>--batch</code> Specifies how large a batch of rays should be. Useful for compute performance tuning. <code>--benchmark</code> Benchmarks RAYX core performance. Outputs total runtime stats to stdout. <code>--gpu</code> Run tracing on the GPU. <code>--cpu</code> Run tracing on the CPU. <code>--plot</code> Plots footprints and histograms from the last Image Plane element. Closes only after the user exits the plot window. <code>--list</code> Lists all supported compute devices available on the system. <code>--device</code> Select a specific device by ID. Use with <code>--list</code> to see available IDs. <code>--input</code> Path to the RML file or directory to be used as the beamline. <code>--output</code> Path where the traced ray data should be saved. <code>--version</code> Displays application version and build metadata. <code>--dummy</code> Runs a dummy test beamline with a few optical elements. Useful for quick diagnostics. <code>--seed</code> Specifies a custom seed for deterministic tracing. <code>--f</code> Fix the seed to a default constant (<code>RAYX::FIXED_SEED</code>). <code>--sequential</code> Traces rays sequentially rather than in parallel. <code>--verbose</code> Outputs more internal information for debugging and performance tuning. <code>--format</code> Selects the output format. Supported: <code>csv</code>, <code>h5</code>. <code>--maxEvents</code> Limits the number of events (e.g., interactions with beamline elements) that are recorded per ray. <code>--record-element</code> Restrict event recording to a specific beamline element by index. Default: <code>-1</code> to record events for all elements."},{"location":"Introduction/06-Literature/","title":"Literature","text":""},{"location":"Introduction/06-Literature/#bachelors-thesis","title":"Bachelor's Thesis'","text":"<p>Extending_and_Accelerating_a_GPU_Ray_Tracing_Algorithm_for_Photon_Simulation_in_Beamlines_ohne.pdf</p>"},{"location":"Introduction/07-Style-Guide/","title":"Style Guide for Programming in RAYX","text":"<p>This document serves as a comprehensive style guide for the RAY project. It outlines the coding standards and best practices that have evolved over the course of the project's lifecycle. Adherence to these guidelines is crucial for maintaining code readability and facilitating effective collaboration among team members. Please read them attentively.</p>"},{"location":"Introduction/07-Style-Guide/#general","title":"General","text":"<p>Write code with collective ownership in mind; the primary audience is your teammates, not just the compiler. The KISS (Keep It Stupid Simple) principle should be applied whenever possible.</p>"},{"location":"Introduction/07-Style-Guide/#includes","title":"Includes","text":"<p>To enhance readability, includes should be categorized as follows:</p> <ul> <li> <p><code>#include \"internalHeader.h\"</code></p> </li> <li> <p><code>#include &lt;externalHeader.h&gt;</code></p> </li> </ul> <p>Internal headers are those developed within the project, while external headers pertain to dependencies integrated into the project.</p>"},{"location":"Introduction/07-Style-Guide/#comments","title":"Comments","text":"<p>Prioritize frequent and precise commenting. Comments should be tailored to newcomers to the project, who are the most likely to require and benefit from them.</p>"},{"location":"Introduction/07-Style-Guide/#doxygen-comments","title":"Doxygen Comments","text":"<pre><code>/**\n* a desctription (don't just repeat the function name)\n* @param value1     what the parameter value1 does\n* @param value2     what the parameter value2 does\n* @see related function\n* @return what the function returns\n*/\n</code></pre> <p>The objective is for header files to provide high-level documentation on API usage, while source files should contain more detailed documentation about implementation specifics.</p>"},{"location":"Introduction/07-Style-Guide/#naming-conventions","title":"Naming Conventions","text":"<p>As longer names can contain more than one word, it can help to have a visual divider. In the case of Ray-UI we use \"camelCase\" and \"PascalCase\". When to use what, will be explained in the \"Classes, Function and Variables\" subsection. </p> <p>The upper case letter indicates a new word and thus improves readability. Every name should be able to stand alone and describe the object, function or variable. Something like \"int v;\" does not achieve this. This also means to avoid using abbreviations, besides the most common ones (\"val\" for \"value\" or \"dx\" for a distance over x).</p> <p>Avoid using symbols or variable names from formulas for naming variables in the code. This makes the code a riddle to decipher, without further information. The correct ways to do this:  - Add a wiki entry for the formula and link to it  - Change the variable names to its purpose or type, e.g. \"hypotenuse\" instead of \"c\"  - Add a link to the formula, so other developers can find it (The other options are better, but at least do this)</p> <p>Should the name get too long or cryptic, write a comment to clarify what you mean with the name you chose for this variable.</p>"},{"location":"Introduction/07-Style-Guide/#boolean","title":"Boolean","text":"<p>Boolean values should begin with is/can/has/etc. when possible.</p>"},{"location":"Introduction/07-Style-Guide/#classes-function-and-variables","title":"Classes, Function and Variables","text":"<p>Class and object names are written in \"PascalCase\". Functions and Variables are written in \"camelCase\".</p> <p>e.g.:</p> <ul> <li>\"ClassA\"</li> <li>\"functionB(int valueC, bool isD)\"</li> </ul>"},{"location":"Introduction/07-Style-Guide/#member","title":"Member","text":"<p>Member objects and variables of a class are indicated by an \"m_\", e.g. : </p> <ul> <li>m_MemberObject </li> <li>m_memberVariable</li> </ul>"},{"location":"Introduction/07-Style-Guide/#const-correctness","title":"Const Correctness","text":"<p>Const correctness is the practice of using the <code>const</code> keyword to ensure that objects and variables remain immutable. Use <code>const</code> as the default. One exception: function parameters of trivial data types like <code>int</code>, <code>double</code>, etc.</p> <ol> <li><code>void f1(const std::string&amp; s);</code> // Pass by reference-to-<code>const</code></li> <li><code>void f2(const std::string* sptr);</code> // Pass by pointer-to-<code>const</code></li> <li><code>void f3(std::string s);</code> // Pass by value</li> </ol> <p>Employing const correctness from the start is advisable, as it can simplify code maintenance and improve overall code quality.</p> <p>Further reading on const correctness is highly recommended and can be found here.</p>"},{"location":"Introduction/07-Style-Guide/#pointer-usage-guidelines","title":"Pointer Usage Guidelines","text":"<p>Raw pointers are discouraged except when interfacing with APIs that require them. Following are alternatives to raw pointers for specific use-cases.</p> <ul> <li>Smart Pointers: Use <code>std::unique_ptr</code> and <code>std::shared_ptr</code> for managing dynamic memory.</li> <li>Optionality with <code>std::optional</code>: Utilize <code>std::optional</code> for optional parameters or return types to explicitly indicate the absence of a value.</li> <li>Const C-Strings: Raw C-strings (<code>const char*</code>) are acceptable only when necessary for compatibility with C APIs. Ensure they are <code>const</code> to prevent modification.</li> <li>Optimize Strings with <code>std::string_view</code>: For performance-critical code, use <code>std::string_view</code> to pass strings by reference without ownership or copy.</li> </ul>"},{"location":"Model/Efficiency/","title":"Efficiency","text":"<p>wiki for efficiency calculations</p>"},{"location":"Model/Efficiency/#snells-law","title":"Snell's law","text":"<p>A fraction of the light is reflected and another transmitted:</p> <p> \\(\\theta_i =\\)  (normal) incidence angle  \\(\\theta_r =\\) (normal) reflection angle (same as \\(\\theta_i\\)) \\(\\theta_t =\\) (normal) transmittance angle  \\(N_1 =\\) refraction index of material from which the ray is coming  (left in image) \\(N_2 =\\) refraction index of material into which the ray is going (right in image)</p> <p>all parameters are potentially complex numbers. The refractive indices are retrieved from files (Palik, Henke, Cromer..)</p> <p>Snell's law: \\[ N_1 \\sin \\theta_i = N_2 \\sin \\theta_t \\rightarrow \\sin \\theta_t = \\frac{N_1}{N_2} \\sin \\theta_i \\]</p> <p>\\(\\theta_i\\), \\(N_1\\), \\(N_2\\) are known, we are looking for \\(\\theta_t\\).   We do not calculate the angle specifically but only the cosinus, which is sufficient for further calculations and more efficient/precise than calculating the angle itself because we do not need to use more trigonometric functions. We can calculate the incidence angle \\(\\theta_i\\) of each ray from its direction and the surface normal. Then we calculate \\(\\cos(\\theta_i)\\) and from that we can derive \\(\\cos(\\theta_t)\\) with snell's law:</p> <p>\\[ (\\sin \\theta_i)^2 = 1 - (\\cos \\theta_i)^2 \\\\ (\\sin \\theta_t)^2 = (\\frac{N_1}{N_2})^2 (\\sin \\theta_i)^2 \\\\ \\cos \\theta_t = \\sqrt{1 - (\\sin \\theta_t)^2} = \\sqrt{1 - \\Big(\\frac{N_1}{N_2} \\sin \\theta_i\\Big)^2} \\]</p> <p>The cosine of both angles is then used in the Fresnel equations to calculate the s- and p-polarization</p>"},{"location":"Model/Efficiency/#fresnel-equation","title":"Fresnel equation","text":"<p>Any polarization state can be described by two components: one vertical and one horizontal. Or - relative to the plane of incidence - s- and p-polarization.  p-polarization (parallel, left image) lies parallel in the plane of incidence and s-polarization (senkrecht, right image) is orthogonal to the plane of incidence.</p> <p> </p> <p>the reflectance of both polarizations is calculated with the fresnel equations:</p> <p>\\[r_s = \\frac{N_1 \\cdot \\cos \\theta_i - N_2 \\cdot \\cos \\theta_t}{N_1 \\cdot \\cos \\theta_i + N_2 \\cdot \\cos \\theta_t}\\] \\[r_p = \\frac{N_2 \\cdot \\cos \\theta_i - N_1 \\cdot \\cos \\theta_t}{N_2 \\cdot \\cos \\theta_i + N_1 \\cdot \\cos \\theta_t}\\]</p> <p>(The transmitted power is then \"the rest\": \\(t_s = 1 - r_s\\) and \\(t_p = 1 -r_p\\))</p>"},{"location":"Model/Efficiency/#multilayer-reflection","title":"Multilayer Reflection","text":""},{"location":"Model/Events/","title":"Events","text":"<p>When the tracing process is finished, our Tracer does not only return the final state of the rays; additionally it provides us with a sequence of events - expressing what happened to each ray individually. This allows us to fully understand what happened to each ray, and potentially where in the beamline it diverged from our expectations.</p> <p>Each of these events contains a \"snapshot\" of the ray at that point in time, and information about what happened at this point (encoded as an \"EventType\").</p> <p>Some typical events include (for more, see the Doxygen documentation): - Just hit: The ray did just intersect with an element. - Fly off: The ray did not hit any more elements and instead it will now fly in the same direction forever. - Absorbed: The ray was absorbed by the element.</p> <p>Some EventTypes \"finalize\" the corresponding ray, preventing it from being processed further. Examples for this are \"Fly Off\" and \"Absorbed\".</p> <p>For more details see the Shared/EventType.h file.</p>"},{"location":"Model/Model/","title":"Model","text":"<p>In this section you can find formulas, methods and ideas used to develop RAYX. </p>"},{"location":"Model/PRNGs-on-the-GPU/","title":"Pseudo Random Number Generators (PRNGs) on the GPU","text":"<p>For RAYX we found a good and performant pseudo random number generator after some research. We cannot use default C++ options as they are not supported by our Shader code. We decided to use Squares RNG, which is counter based and utilizes a version of the Middle Square Weyl Sequence. We tested the method with the TestU01 bigcrush test with different seeds and it passed all of them.</p> <p>We added a few more methods for creating random numbers with more variety. These methods are: - <code>uint64_t squares64RNG(inout uint64_t ctr)</code>, which generates 64-Bit random integers from two 32-Bit random integers - <code>double squaresDoubleRNG(inout uint64_t ctr)</code>, which generates uniformly distributed doubles between 0 and 1 from one 64-Bit random integer - <code>double squaresNormalRNG(inout uint64_t ctr, double mu, double sigma)</code>, which creates (via the Box-Muller transform) a normal distributed double with mean <code>mu</code> and standard deviation <code>sigma</code>. This takes three random doulbes, which takes six 32-Bit integers.</p>"},{"location":"Model/PRNGs-on-the-GPU/#links","title":"Links","text":"<ul> <li>Squares: A Fast Counter-Based RNG</li> <li>TestU01: A C Library for Empirical Testing of Random Number Generators</li> <li>Box\u2013Muller transform</li> </ul>"},{"location":"Model/Quad%28ric%29-function/","title":"Quad(ric) Function","text":"<p>Function for calculating the intersection of a ray with the surface of an optical element in 3-dimensional space.</p>"},{"location":"Model/Quad%28ric%29-function/#input","title":"Input:","text":"<ul> <li>16 parameters \\(a_{11}\\) to \\(a_{44}\\) to define the surface in 3D space with the general equation for second order surfaces. Parameter values for specific surfaces can be found in the documentation.</li> <li>\\(ray = \\begin{bmatrix} x_{S'} \\\\ y_{S'} \\\\z_{S'} \\\\ \\end{bmatrix} + t \\begin{bmatrix} l_{S'} \\\\ m_{S'}\\\\ n_{S'} \\\\ \\end{bmatrix}\\)</li> <li>weight/III (set to 0(python)/-4(Fortran) if ray missed surface, unchanged otherwise)</li> <li>icurv: determines the sign in the formula for calculating \\(t\\), if negative first intersection point, if positive second intersection point.</li> </ul>"},{"location":"Model/Quad%28ric%29-function/#output","title":"Output:","text":"<ul> <li>modified ray</li> <li>normal at intersection point</li> <li>weight/III</li> </ul>"},{"location":"Model/Quad%28ric%29-function/#calculation-of-intersection-point","title":"Calculation of intersection point","text":"<p>general equation for second order surfaces: \\[F(x,y,z) = a_{11}x^2 + a_{22}y^2 + a_{33}z^2 + 2a_{12}xy + 2a_{13}xz + 2a_{23}yz + 2a_{14}x + 2a_{24}y + 2a_{34}z + a_{44}\\]</p> <p>The intersection is determined by inserting the x, y and z-coordinates of the ray in \\(F(x,y,z)\\) and set to zero:  \\[F(x_{S'}+t \\cdot l_{S'} ,y_{S'}+t \\cdot m_{S'}, z_{S'}+t \\cdot n_{S'}) = 0\\]</p> <p>We obtain a quadratic equation of the form \\(0 = a \\cdot t^2 + b \\cdot t + c\\) with variable \\(t\\) and the following coefficients:</p> <p>\\[ \\begin{align}     a &amp;= a_{11}l_{S'}^2 + a_{22}m_{S'}^2 + a_{33}n_{S'}^2 + 2a_{13}l_{S'}n_{S'} + 2a_{12}l_{S'}m_{S'} + 2a_{23}m_{S'}n_{S'} \\\\     b &amp;= 2a_{11}x_{S'}l_{S'} + 2a_{22}y_{S'}m_{S'} + 2a_{33}z_{S'}n_{S'} \\\\     &amp;+ 2a_{12}y_{S'}l_{S'} + 2a_{12}x_{S'}m_{S'}      + 2a_{13}z_{S'}l_{S'} + 2a_{13}x_{S'}n_{S'} \\\\     &amp;+ 2a_{23}z_{S'}m_{S'} + 2a_{23}y_{S'}n_{S'}      + 2a_{14}l_{S'} + 2a_{24}m_{S'} + 2a_{34}n_{S'} \\\\     c &amp;= a_{11}x_{S'}^2 + a_{22}y_{S'}^2 + a_{33}z_{S'}^2 + 2a_{12}x_{S'}y_{S'} + 2a_{13}x_{S'}z_{S'} + 2a_{23}y_{S'}z_{S'} \\\\     &amp;+ 2a_{14}x_{S'} + 2a_{24}y_{S'} + 2a_{34}z_{S'} + a_{44} \\end{align} \\]</p> <p>Since a, b and c can simply be calculated, we could solve the equation directly with  \\(t = \\frac{-b+ICURV \\cdot \\sqrt{b^2-4ac}}{2a}\\) and use \\(t\\) to find the intersection point. If ICURV is negative, we get the first intersection point with the object (smaller \\(t\\)). If ICURV is positive we get the second intersection point from when the ray exits the element (larger \\(t\\)). Some optimizations are applied to this formula in the code. Depending on the largest component in the direction of the ray, it is normalized in x, y or z direction to simplify the ray equation. Thus, there are three cases.</p>"},{"location":"Model/Quad%28ric%29-function/#optimization","title":"Optimization","text":"<p>Assume \\(l_{S'} \\geq m_{S'}\\) and \\(l_{S'} \\geq n_{S'}\\) (first case). Then, we can divide the direction by \\(l_{S'}\\), such that it is normalized in x and the y- and z-coordinates are within \\([-1,1]\\) (I). Moreover, we can translate the origin of the ray along the direction vector towards the origin of the coordinate system until the y-z-plane is hit \\((x=0, II)\\). Then, we end up with a normalized ray (III), where \\(x=t\\).</p> <p>\\[ \\begin{align}     ray      &amp;\\overset{\\text{I}}{=} \\begin{bmatrix} x_{S'} \\\\ y_{S'} \\\\z_{S'} \\\\ \\end{bmatrix} + t \\begin{bmatrix} 1 \\\\ m_{S'}/l_{S'}\\\\ n_{S'}/l_{S'} \\\\ \\end{bmatrix} \\\\     &amp;\\overset{\\text{II}}{=} \\begin{bmatrix} x_{S'}-1\\cdot x_{S'} \\\\ y_{S'} - (m_{S'}/l_{S'}) \\cdot y_{S'} \\\\z_{S'} - (n_{S'}/l_{S'}) \\cdot z_{S'} \\\\ \\end{bmatrix} + t \\begin{bmatrix} 1 \\\\ m_{S'}/l_{S'}\\\\ n_{S'}/l_{S'} \\\\ \\end{bmatrix} \\\\     &amp;\\overset{\\text{III}}{=} \\begin{bmatrix} 0 \\\\ y \\\\ z \\end{bmatrix} + t \\begin{bmatrix} 1 \\\\ a_{ml} \\\\ a_{nl} \\\\ \\end{bmatrix}  \\end{align} \\]</p> <p>When we plug this parameterization of the ray into \\(F(x,y,z)=0\\), some terms in a, b and c are removed (see code).</p> <p>Since every term in b contains the factor 2, the equation for calculating t can be simplified: \\[ t = \\frac{-2\\frac{b}{2} +ICURV \\cdot \\sqrt{(2\\frac{b}{2})^2 - 4ac}}{2a} \\\\ = \\frac{-2\\frac{b}{2} +ICURV \\cdot 2\\sqrt{(\\frac{b}{2})^2 - ac}}{2a} \\\\ = \\frac{-\\frac{b}{2} +ICURV \\cdot \\sqrt{(\\frac{b}{2})^2 - ac}}{a} \\]</p> <p>In the code the factor 2 is left out of the equation for \\(b\\) from the beginning. Thus, what is called \\(b\\) in the code is actually \\(\\frac{b}{2}\\).</p> <p>If the term in the root is negative there is no intersection and weight is set to 0 (or III to -4 in fortran).  Otherwise it is checked whether the factor a is much smaller than \\(c\\). Then, the divisor is very small or zero which can cause problems with the division. In that case, \\(a \\cdot t^2\\) is removed from the quadratic equation \\(a \\cdot t^2 + b \\cdot t + c\\) which thus yields \\(t=x=- \\frac{c}{b}\\) or \\(t=x= \\frac{c}{2b}\\) in the code since the factor \\(2\\) is excluded from \\(b\\) (see also (Ray Quadric Intersection)).  If \\(a\\) is not much smaller than \\(c\\), \\(t\\) is calculated with the simplified equation above. Subsequently, \\(t (=x)\\) is plugged into the modified ray equation and the intersection point is calculated.</p> <p>The other two cases for when \\(y\\) or \\(z\\) are the largest component of the direction of the ray are similar.</p> <p>The partial derivatives of \\(F(x,y,z)\\) form the normal vector \\(f_{x,y,z}\\) of the surface. Inserting the calculated intersection point into the normal vector yields the normal of the surface at this specific point. The intersection point is set to be the new origin of the ray. The ray direction \\((l_{S'},m_{S'},n_{S'})\\) remains unchanged.</p>"},{"location":"Model/Quad%28ric%29-function/#general-equation-for-second-order-surfaces","title":"General equation for second order surfaces","text":"<p>The equation can describe the surface of several elements in a similar way as a circle with radius 1 can be described in 2D as \\(x^2 + y^2 -1 = 0\\). Elements that can be described by this general equation include sphere, ellipsoid, plane, cone, cylinder, paraboloid. These are so called quadric surfaces. Surfaces that cannot be described by any quadratic function include for example the torus. The equation refers to a right-handed coordinate system with the center of the optical element in the origin. The element's surface is the x-z-plane and the y-axis is the normal vector. </p> <p>\\[ \\begin{align}     F(x,y,z) &amp;= \\vec{x}^TA\\vec{x} \\\\     \\vec{x} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}     A &amp;= \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\\\     a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\\\     a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\\\     a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44}      \\end{bmatrix} \\\\     a_{ij} = a_{ji} &amp;\\Rightarrow A^T = A \\end{align} \\]</p> <p>Literature:  https://en.wikipedia.org/wiki/Quadric https://www.win.tue.nl/~sterk/Bouwkunde/2db60-chap3.pdf</p>"},{"location":"Model/Ray-generation/","title":"Ray Generation","text":"<p>Rays are described in tree-dimensional space with an origin and a direction. The origin are described with a three dimensional vector. However, the direction can be interpreted as the cosines of two angles \\(\\phi\\) and \\(\\psi\\). Since the z-axis is the direction of the center ray, the direction of all other rays can be described as the angle between ray direction vector and z-y-plane (horizontal divergence \\(\\phi\\)) and between vector and z-x-plane (vertical divergence \\(\\psi\\)). See also documentation p.18,19.</p> <p>\\[     \\text{ray} = \\begin{bmatrix}     x_s \\\\ y_s \\\\ z_s     \\end{bmatrix} + t      \\begin{bmatrix}     l_S \\\\ m_S \\\\ n_S     \\end{bmatrix}     = \\begin{bmatrix}     x_s \\\\ y_s \\\\ z_s     \\end{bmatrix} + t      \\begin{bmatrix}     \\sin \\phi_S \\cdot \\cos \\psi_S \\\\ \\cos \\psi_S \\\\ \\cos \\psi_S \\cdot \\cos \\phi_S     \\end{bmatrix} \\]</p> <p>When the ray is created in the light source, its origin and direction angles are chosen randomly.</p>"},{"location":"Model/Ray-generation/#light-sources-point-source","title":"Light sources: Point source","text":"<p>The user sets the following parameters: * number of rays * source dimensions width(x-dir), height(y-dir) and depth(z-dir)  * horizontal and vertical divergence</p> <p>The intensity distribution in the lightsource is understood as the probability distribution of the parameters position and angle. The parameters \\(x\\), \\(y\\) and \\(z\\) of position and the angles \\(\\phi\\) and \\(\\psi\\) are chosen randomly but according to a probability distribution. Uniformly distributed random numbers within the range \\([0,1]\\) are obtained by FORTRAN's random_number function. There are two options for the probability distribution in the light source: soft edge (Gaussian) and hard edge (uniformly). Afterwards, some predefined offset can be added to each component.</p>"},{"location":"Model/Ray-generation/#hard-edge","title":"Hard edge","text":"<p>The hard edge option is the simpler one since the random numbers are already uniformly distributed. Thus, the ray parameters \\(x\\), \\(y\\), \\(z\\), \\(\\phi\\), \\(\\psi\\) are chosen uniformly within the given extent (width, height, divergence..) of the point source by calculating a random number \\(u\\), subtracting 0.5 such that the number ranges in \\([-0.5,+0.5]\\) and multiplying with the given width/height/depth or horizontal/vertical extent of the point source.</p> <p>\\(x_S = (u_x - 0.5) \\cdot width\\)  \\(y_S = (u_y - 0.5) \\cdot height\\)  \\(z_S = (u_z - 0.5) \\cdot depth\\)  \\(\\phi_S = (u_\\phi - 0.5) \\cdot hor. div\\)  \\(\\psi_S = (u_\\psi - 0.5) \\cdot vert. div\\) </p> <p>Thus, the x-coordinate of the origin, for example, lies within \\([-\\frac{width}{2}, +\\frac{width}{2}]\\) and is picked uniformly.</p>"},{"location":"Model/Ray-generation/#soft-edge","title":"Soft edge","text":"<p>(See also documentation p.14)</p> <p>For the soft edge we have to transform the uniform distribution to a Gaussian distribution with \\(\\mu = 0\\) and \\(\\sigma = extent\\). The resulting values for a specific ray are not bound by the input parameters as for the hard edge. Instead, the more they deviate from \\(\\mu\\) the more rare they are. </p>"},{"location":"Model/Ray-generation/#in-fortran-code","title":"In FORTRAN code","text":"<p>The old implementation uses the following apporach:</p> <ol> <li>create two random numbers \\(u_1,u_2\\) from a uniform distribution in \\([0,1]\\)</li> <li>\\(x =(u_1 - 0.5 ) \\cdot \\sigma \\cdot 9\\)</li> <li>\\(wx =  \\exp(\\frac{-x^2}{2})\\)</li> <li>\\(dif = wx-u_2\\)</li> <li>\\(wx\\) is the value of the densitiy function \\(f(x)\\) of the distribution with \\(\\mu=0\\) and \\(\\sigma\\). If \\(wx &lt; u_2\\), then repeat from step 1 (keep \\(x\\) with probability \\(f(x)\\))</li> <li>else keep \\(x\\)</li> </ol> <p>Here, 9 is used as a factor for \\(\\sigma\\), since the Gaussian distribution is defined from \\(-\\infty\\) to \\(+\\infty\\) but a confidence interval \\([-4.5 \\sigma, +4.5 \\sigma]\\) contains already more than 99.99%.</p> <p>\\(w(x_s)\\) lies in \\([0,1]\\). It is \\(1\\) for \\(x_s = 0\\) and becomes smaller the more \\(x_s\\) deviates from \\(0\\) according to the gaussian bell curve. Since \\(w(x_s)\\) is the probability that \\(x_s\\) occurs in our gaussian distribution, we want to use \\(x_s\\) for the origin of the ray with a probability of \\(w(x_s)\\). Thus, we get a second random number \\(u_x'\\) from FORTRAN's random_number function and if \\(u_x' \\leq w(x_s)\\) holds we use \\(x_S\\) for the ray. Otherwise, \\(x_S\\) is discarded and re-calculated with a new random number \\(u_x\\). Thereby, we use \\(x_S\\) with a probability that corresponds to the Gaussian distribution.</p> <p>However, this is not very efficient as a lot of rays are thrown away. The following method uses a different approach which - although some values are discarded as well - is more efficient and creates two values in one iteration instead of one (more here Section 5.5.2):</p>"},{"location":"Model/Ray-generation/#more-efficiently","title":"More efficiently:","text":"<ol> <li>create two random numbers \\(u_1, u_2\\) from a uniform distribution in \\([0,1]\\)</li> <li>calculate \\(x_1 = 2u_1-1\\) and \\(x_2 = 2u_2 -1\\)</li> <li>calculate  \\(r^2 = x_1^2 + x_2^2r^2\\)</li> <li>if \\(r^2 &gt; 1\\) repeat from step 1</li> <li>else calculate  \\(z_1 = x_1 \\cdot \\sqrt{-2\\frac{\\ln{r^2}}{r^2}} \\cdot \\sigma\\) and  \\(z_2 = x_2 \\cdot \\sqrt{-2\\frac{\\ln{r^2}}{r^2}} \\cdot \\sigma\\)</li> </ol> <p>Now \\(z_1\\) and \\(z_2\\) are distributed according to the Gaussian distribution with \\(\\mu = 0\\) and \\(\\sigma = extent\\) as defined by the user.</p> <p>This calculation is faster since we get 2 values instead of 1.  (In python the first method took twice as long as this method to create the same amount of values)</p>"},{"location":"Model/Transformation-between-coordinate-systems/","title":"Transformation between coordinate systems","text":""},{"location":"Model/Transformation-between-coordinate-systems/#how-to-calculate-world-coordinates","title":"How to calculate World Coordinates","text":"<p>This explains how to get world coordinates (global position and orientation of an optical element) from the sequential setup of a beamline that is often used, where the position and orientation of an element is described with distances and rotations relative to its predecesor.</p> <p>First a small introduction to rotation matrices which is not super relevant for the transformations but might help to visualize the rotations and understand why some angles are positive and others negative.</p>"},{"location":"Model/Transformation-between-coordinate-systems/#rotation-matrices","title":"Rotation matrices","text":"<p>A rotation through an angle \\(\\theta\\) can either be active or passive. An active rotation around for example the z-axis through the angle \\(\\theta\\) rotates the point within the coordinate system. Thereby, the coordinates of the point are changed whereas the coordinate system is left unchanged. When looking along the rotation axis in a right-handed coordinate system towards the origin, the rotation direction is counter-clockwise.</p> <p>\\[ R_a({\\theta}) =  \\begin{bmatrix}     \\cos(\\theta) &amp; -\\sin(\\theta) &amp; 0 \\\\     \\sin(\\theta) &amp; \\cos(\\theta) &amp; \\\\     0           &amp; 0         &amp; 1  \\end{bmatrix} \\]</p> <p>A passive rotation leaves the position of the vector unchanged and rotates the axes of the coordinate system relative to the vector i.e. rotates the basis vectors (change of basis). When looking along the rotation-axis towards the origin in a right-handed coordinate system, the rotation of the rotating axes is clockwise. Thus, it is defined as an active rotation (applied to the basis vectors) in the other direction i.e. through the negative angle (\\(\\cos(-\\theta) = \\cos(\\theta)\\) and \\(-\\sin(\\theta) = \\sin(-\\theta))\\):</p> <p>\\[      R_p({\\theta}) = \\begin{bmatrix}     \\cos(\\theta) &amp; \\sin(\\theta) &amp; 0 \\\\     -\\sin(\\theta) &amp; \\cos(\\theta) &amp;  \\\\     0           &amp; 0         &amp; 1      \\end{bmatrix} = \\begin{bmatrix}     \\cos(-\\theta) &amp; -\\sin(-\\theta) &amp; 0 \\\\     \\sin(-\\theta) &amp; \\cos(-\\theta) &amp;  \\\\     0           &amp; 0         &amp; 1      \\end{bmatrix} \\]</p> <p>The relation between axes and the position of the point are the same after each of the rotations: After the passive rotation the basis vectors are different and the vector coordinates stay the same whereas after the active rotation the vector coordinates are different but the basis vectors are the same.</p> <p>Example for active (left) and passive (right) rotation through \\(\\alpha=25^\\circ\\):    The relative position of the vector to the axes is the same after each rotation.  See also active vs passive transformation</p> <p>However, active and passive are in our case only an interpretation of the rotations that makes sense when looking at the beamline from a global point of view. Globally seen, the local coordinate system of each optical element is rotated and translated differently with respect to a global coordinate system whereas the vectors (the rays) only change by e.g. reflection when interacting with an element. Thus, we have coordinate systems for optical elements, that are identical for each element in the sense that the y-axis is the normal and the x-z-plane is the tangent plane of the surface at the origin, and for rays where the center ray is the z-axis and a global system. The transformation between the systems is implemented by rotating and translating the vectors within the same coordinate system. \\(\\rightarrow\\) In the implementation only the vectors are transformed by active transformations and the axes of the coordinate system stay the same, although in the \"real world\", the beams remain unchanged and only the coordinate system is rotated around them.</p> <p>The following sections describe how to calculate the transformation matrices from beam coordinates to element coordinates and again to (new) beam coordinates based on the given distance and angles in the sequential setup. This is relevant for RAYX if you need to calculate the world coordinates from the user parameters that describe the sequential setup yourself and cannot directly use the world coordinates from the rml file: </p>"},{"location":"Model/Transformation-between-coordinate-systems/#positioning-of-elements-in-sequential-setup","title":"Positioning of elements in sequential setup","text":"<p>In the RAY-UI rays are represented in a beam coordinate system. In that system the main ray always points from the origin towards the z-axis wheras the individual rays have slight deviations in their direction and origin.</p> <p>Elements are represented in an element coordinate system. The elements are mostly located in the x-z-plane of their coordinate system. The y-axis is the normal in the center of the element (Visualized in the documentation).</p> <p>In order to calculate the intersection point with the \"quad\" function, we first need to transfer the incoming rays from beam coordinates to the object coordinates. The relation between these system is defined by two angles \\(\\alpha\\) and \\(\\chi\\) and a translation by \\(z_0\\). The transformation affects the position and direction of the ray.</p> <ol> <li> <p>the offset \\(z_0\\) describes the distance between the previous element or the source and the current optical element. </p> </li> <li> <p>the main ray should have a specific incidence angle \\(\\alpha\\) (angle between main ray and x-z-plane of the optical element). This rotation is counter-clockwise around the x-axis:</p> </li> </ol> <p>\\[     R_x({\\alpha}) = \\begin{bmatrix}     1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos(\\alpha) &amp; -\\sin(\\alpha) \\\\     0 &amp; \\sin(\\alpha) &amp; \\cos(\\alpha)     \\end{bmatrix} \\]</p> Side note <p>Side note for visualization: An example for this rotation interpreted as an active and as a passive rotation of the main ray (z-axis) and a ray \\(v\\) through the grazing incidence angle \\(\\alpha=25\u00b0\\). The first coordinate system shows the incoming ray in the ray-coordinate system. In the second one the rays/the axes are rotated through \\(\\alpha\\) such that the rays lie in the element-coordinate system. In the third image the reflection is calculated. Finally, in the last image, the reflected ray/the axes are rotated to the new ray-coordinate system. Since we are using a right-handed coordinate system, the x-axis points into the image and the rotations that appear to be clockwise are actually counter-clockwise around the x-axis.</p> <ol> <li>The second rotation through angle \\(\\chi\\) around the z-axis tilts the optical element such that the ray is not reflected upwards (\\(\\chi=0\u00b0\\)) but to the right (\\(\\chi=90\u00b0\\)), downwards (\\(\\chi=180\u00b0\\)) or to the left (\\(\\chi=270\u00b0\\)). This is a clockwise rotation. Thus, we rotate through \\(-\\chi\\) when \\(\\chi\\) is given.</li> </ol> <p>After tracing we need to transform the ray back to the beam coordinate system. Therefore we rotate back around \\(\\chi\\) and then rotate around the exit angle \\(\\beta\\) All these parameters are given as \"user\" parameters. The following section describes how to calculate beam-element and element-beam transformation matrices.</p>"},{"location":"Model/Transformation-between-coordinate-systems/#calculating-transformation-matrices-between-elements-in-sequential-setup","title":"Calculating transformation matrices between elements in sequential setup","text":""},{"location":"Model/Transformation-between-coordinate-systems/#beam-to-element","title":"Beam to Element","text":"<ol> <li> <p>Translation by \\(z_0\\) in z direction = distance to preceeding element</p> </li> <li> <p>Rotation by azimuthal angle \\(\\chi\\) around z-axis. </p> </li> </ol> <p>\\[     R_z(-\\chi) = \\begin{bmatrix} \\cos(-\\chi) &amp; -\\sin(-\\chi) &amp; 0 \\\\     \\sin(-\\chi) &amp; \\cos(-\\chi) &amp; 0 \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} =     \\begin{bmatrix} \\cos(\\chi) &amp; \\sin(\\chi) &amp; 0 \\\\     -\\sin(\\chi) &amp; \\cos(\\chi) &amp; 0 \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} \\]</p> <ol> <li>Rotation through grazing incidence angle \\(\\alpha\\) around x-axis. Sometimes, the normal incidence angle with \\(90\u00b0-\\alpha\\) is given. Then, it has to be converted to the grazing incidence angle \\(\\alpha\\).</li> </ol> <p>\\[     R_x(\\alpha) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\     0 &amp; \\cos(\\alpha) &amp; -\\sin(\\alpha) \\\\     0 &amp; \\sin(\\alpha) &amp; \\cos(\\alpha) \\end{bmatrix} \\]</p> <p>Putting it all together this is an affine transformation and can be written in homogeneous coordinates as one single matrix:</p> <p>\\[ \\begin{align}     M_{b2e} &amp;= R_{x}(\\alpha) R_z(-\\chi) T_z(z_0) \\\\     M_{b2e} &amp;= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\     0 &amp; \\cos(\\alpha) &amp; -\\sin(\\alpha) &amp; 0 \\\\ 0 &amp; \\sin(\\alpha) &amp; \\cos(\\alpha) &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} \\cos(\\chi) &amp; \\sin(\\chi) &amp; 0 &amp; 0\\\\ -\\sin(\\chi) &amp; \\cos(\\chi) &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; -z_0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix} \\cos(\\chi) &amp; \\sin(\\chi) &amp; 0 &amp; 0 \\\\ -\\sin(\\chi)\\cos(\\alpha) &amp; \\cos(\\chi)\\cos(\\alpha) &amp; -\\sin(\\alpha) &amp; z_0 \\sin(\\alpha) \\\\ -\\sin(\\chi) \\sin(\\alpha) &amp; \\sin(\\alpha)\\cos(\\chi) &amp; \\cos(\\alpha) &amp; -z_0 \\cos(\\alpha) \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\end{align} \\]</p>"},{"location":"Model/Transformation-between-coordinate-systems/#element-to-beam","title":"Element to Beam","text":"<p>After the interaction with the element, the reflected ray \\(x_R\\) is transformed back to a beam coordinate system. The rotations around the axes are applied in reverse order.</p> <ol> <li>Rotation through gracing exit angle \\(\\beta\\) around x-axis. We do not need to rotate back through \\(\\alpha\\) but keep rotating in the same direction since the new z-axis should point in the direction of the reflected and not of the incoming main ray. E.g. \\(\\beta\\) is the same as \\(\\alpha\\) for mirrors.</li> </ol> <p>\\[     R_x(\\beta) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\      0 &amp; \\cos(\\beta) &amp; -\\sin(\\beta) \\\\ 0 &amp; \\sin(\\beta) &amp; \\cos(\\beta) \\end{bmatrix} \\]</p> <ol> <li>Rotation back through \\(\\chi\\).</li> </ol> <p>\\[ R_z(\\chi) = R_z^{-1}(-\\chi) = \\begin{bmatrix} \\cos(\\chi) &amp; -\\sin(\\chi) &amp; 0 \\\\     \\sin(\\chi) &amp; \\cos(\\chi) &amp; 0 \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} \\]</p> <p>In homogeneous coordinates:</p> <p>\\[ \\begin{align}     M_{e2b} &amp;= R_z(\\chi)R_{x}(\\beta) \\\\     M_{e2b} &amp;= \\begin{bmatrix} \\cos(\\chi) &amp; -\\sin(\\chi) &amp; 0 &amp; 0\\\\     \\sin(\\chi) &amp; \\cos(\\chi) &amp; 0 &amp; 0\\\\     0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot  \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\      0 &amp; \\cos(\\beta) &amp; -\\sin(\\beta) &amp; 0 \\\\ 0 &amp; \\sin(\\beta) &amp; \\cos(\\beta) &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\\\ &amp;= \\begin{bmatrix} \\cos(\\chi) &amp; -\\sin(\\chi) \\cos(\\beta) &amp; \\sin(\\chi)\\sin(\\beta) &amp; 0 \\\\ \\sin(\\chi) &amp; \\cos(\\chi)\\cos(\\beta) &amp; -\\cos(\\chi)\\sin(\\beta) &amp; 0 \\\\ 0 &amp; \\sin(\\beta) &amp; \\cos(\\beta) &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\end{align} \\]</p> <p>(Since there is no translation a 3x3 matrix would suffice)</p>"},{"location":"Model/Transformation-between-coordinate-systems/#misalignment","title":"Misalignment","text":"<p>Misalignment is used when the optical element does not lie exactly where it should after applying the beam to element matrix. Therefore some rotation or translation might be necessary before the intersection point can be calculated.</p> <p>The misalignment transformation matrix \\(M_{mis}\\) is simply derived from the user parameters \\(d_x\\), \\(d_y\\), \\(d_z\\), \\(d_{\\phi}\\), \\(d_{\\psi}\\), \\(d_{\\chi}\\). It can be calculated by spliting into a transformation matrix (from \\(d_x\\), \\(d_y\\), \\(d_z\\)) and multiplying with a rotation matrix (from \\(d_{\\phi}\\), \\(-d_{\\psi}\\), \\(d_{\\chi}\\)):</p> <p>\\[     \\begin{align}         M_{mis} &amp;= T_{x,y,z} R_{\\phi, -\\psi, \\chi} \\\\         &amp;= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -d_x\\\\         0 &amp; 1 &amp; 0 &amp; -d_y\\\\         0 &amp; 0 &amp; 1 &amp; -d_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot R^x_{-\\psi} \\cdot R^y_{\\phi} \\cdot R^z_{\\chi}     \\end{align}  \\]</p> <p>where e.g. \\(R^x_{\\psi}\\) is the 4x4 homogeneous rotation matrix through \\(\\psi\\) around the x-axis.</p> <p>The inverse misalignment matrix is then calculated as follows:</p> <p>\\[     \\begin{align}         M_{mis}^{-1} &amp;= R_{-\\psi, \\phi, \\chi}^{-1} \\cdot T_{x,y,z}^{-1}\\\\         &amp;= (R^x_{-\\psi} \\cdot R^y_{\\phi} \\cdot R^z_{\\chi}) ^{T} \\cdot      \\begin{bmatrix}         1 &amp; 0 &amp; 0 &amp; d_x \\\\         0 &amp; 1 &amp; 0 &amp; d_y \\\\         0 &amp; 0 &amp; 1 &amp; d_z \\\\         0 &amp; 0 &amp; 0 &amp; 1      \\end{bmatrix}      \\end{align} \\]</p> <p>Since rotation matrices are orthogonal, the inverse of \\((R^x_{-\\psi} R^y_{\\phi} R^z_{\\chi})\\) is the same as the transpose. The inverse of the translation matrix is the same but with negative offsets.</p> <p>\\(M_{mis}\\), \\(M_{mis}^{-1}\\) are multiplied with \\(M_{b/g2e}\\) and \\(M_{e2g/b}\\), respectively, to form the final transformation matrices which could be given to the shader if we would still use the sequential approach in RAYX. However, we use a global coordinate system instead of the beam coordinate system but don't worry you didn't just read all of that for nothing, it will be important in the derivation of the transformation from global to element coordinates and back.</p> <p>The next section describes how to replace the beam coordinate system that is used in the sequential approach with the global coordinate system and how to calculate the position and orientation.</p>"},{"location":"Model/Transformation-between-coordinate-systems/#sequential-to-world-coordinates","title":"Sequential to world coordinates","text":"<p>As explained in the previous sections, there is no global coordinate system in the sequential implementation but instead rays are transformed from beam coordinate system to element coordinate system and back to a different beam coordinate system such that the z-axis of the beam coordinate system always follows the main ray, which means that the main ray with \\(pos=(0,0,0)\\), \\(dir=(0,0,1)\\) in beam coordinates is always the same after each interaction with an optical element.</p> <p>In a global coordinate system this is different. The origin of the system is the (first) source. When the main ray hits the first element, it is transformed into the element's coordinate system, traced (e.g. reflected) and transformed back into the global coordinate system. Then it does no longer have the values \\(pos=(0,0,0)\\) and \\(dir=(0,0,1)\\). To achieve this for the first element (i=1) in the beamline, we can still use \\(M_{b2e}\\) that we defined previously \\((M_{g2e}^{-1} = M_{b2e}^{-1})\\) since for the first element the global coordinate system is the same as the beam coordinate system of the incoming rays (bc the source is in \\((0,0,0)\\) which is the origin of both the global coord system and the initial beam coord. system). However, we need a different element to global coordinate system transformation for this elemet \\(M_{g2e}^{-1} \\neq M_{b2e}^1\\) and of course also for all following elements. Moreover, for all following elements we also need a different \\(M_{g2e}^i \\neq M_{b2e}^i\\) for \\(i&gt;1\\).</p>"},{"location":"Model/Transformation-between-coordinate-systems/#transformation-matrices-from-position-and-orientation","title":"Transformation matrices from position and orientation","text":"<p>global coordinates are sometimes given by the user directly via e.g. an rml file, which stores the global orientation as a 3x3 matrix and the position as a 3 element vector. Expanding both to homogeneous 4x4 rotation/translation matrices makes it possible to calculate \\(M_{g2e}\\) and \\(M_{e2g}\\) by multiplying them. For the case that the beamline was still build sequentially, it was decided to first build the global position and orientation from \\(\\alpha\\), \\(\\beta\\), \\(\\chi\\), the distance \\(z_0\\) and the misalignment and then derive the matrices \\(M_{g2e}\\) and \\(M_{e2g}\\)  in the same way.</p> <p>The following calculations can be used for all optical elements. For the ellipsoid, however, the misalignment can be defined in the coordinate system of the mirror or of the curvation. The usual misalignment is in the coordinate system of the mirror. The coordinate system of the curvation differs by a rotation through the tangent angle \\(\\theta\\) around the x-axis. This angle depends on the shape of the ellipsoid. Depending on the coordinate system, we add the rotation \\(T_x(\\theta)\\) (in red), for all other elements this is irrelevant so \\(\\theta = 0\\).</p> <p>As mentioned before, in the case that the element is the first in the beamline, it is simply placed at a certain distance on the z-axis. Therefore, the position (pos) is, in homogeneous coordinates:</p> <p>\\[     pos^0 = \\begin{bmatrix} 0 \\\\ 0 \\\\ z_0^0 \\\\ 1 \\end{bmatrix} + or^0 \\cdot \\color{red}{R_x^0(\\theta)} \\cdot \\color{black}{\\begin{bmatrix} d_x^0 \\\\ d_y^0 \\\\ d_z^0 \\\\ 1 \\end{bmatrix}} \\]</p> <p>where or is the orientation of the element and \\(d_x\\), \\(d_y\\), \\(d_z\\) are the positional misalignment. The orientation of the first element is calculated as follow:</p> <p>\\[     or^0 = R_x^0(\\alpha) R_z^0(-\\chi) \\cdot \\color{red}{R_x^0(\\theta)} \\cdot \\color{black}{R_{\\phi, -\\psi, \\chi}^0} \\cdot \\color{red}{R_x^0(\\theta)^T}  \\]</p> <p>where \\(R_{\\phi -\\psi \\chi}\\) contains the orientational misalignment and \\(R_x(\\alpha) R_z(-\\chi)\\) is the rotational part of \\(M_{b2e}\\) (without the translation by \\(z_0\\) since the distance is not part of the orientation but of the position)</p> <p>When the element is not the first in the beamline, we need in addition to the ususal parameters of this element (\\(\\alpha\\), \\(\\beta\\), \\(\\chi\\), the distance \\(z_0\\) and the misalignment) also the global position and orientation and the \\(M_{e2b}\\) matrix of the previous element. Unfortunately, we also have to remove the misalignment from the global position of the previous element (equation 1), then we can add the distance from the previous to new element to the position of the previous element following the direction of the outgoing ray (2). Finally, we can add the positional misalignment of element i to the position (3).</p> <p>\\[     \\begin{align}         pos^{(i-1)} &amp;= pos^{i-1} - or^{i-1} \\cdot \\color{red}{R_x^{i-1}(\\theta)} \\cdot \\color{black}{\\begin{bmatrix} d_x^{i-1} \\\\ d_y^{i-1} \\\\ d_z^{i-1} \\\\ 1 \\end{bmatrix}} \\\\         pos^i &amp;= pos^{i-1} - or^{i-1} \\cdot R_x^{i-1}(\\theta) \\cdot \\begin{bmatrix} 0 \\\\ 0 \\\\ z_0^i \\\\ 1 \\end{bmatrix} \\\\         pos^i &amp;= pos^i + or^{i} \\cdot \\color{red}{R_x^{i}(\\theta)} \\cdot \\color{black}{\\begin{bmatrix} d_x^i \\\\ d_y^i \\\\ d_z^i \\\\ 1 \\end{bmatrix}}     \\end{align} \\]</p> <p>The calculation of the orientation of the ith element is a bit simpler. The global orientation of element i is the global orientation of the previous element \\((or^{i-1})\\) without the rotational misalignment (1) multiplied with the rotation of the new element coordinate system with respect to the previous element coordinate system \\((M_{e2b}, \\text{eq 2})\\) multiplied with the orientation of the new element in its own element coordinate system (which is calculated in the same way as for the first element: local orientation \\(\\cdot\\) misalignment, eq. 3):</p> <p>\\[     \\begin{align}         or^{(i-1)} &amp;= or^{i-1} \\cdot \\color{red}{R_x^{i-1}(\\theta)^T} \\cdot \\color{black}{(R_{\\phi, -\\psi, \\chi}^{i-1})^{T}} \\cdot \\color{red}{R_x^{i-1}(\\theta)} \\\\         or^i &amp;= or^{(i-1)} \\cdot M_{e2b}^{i-1} \\\\         or^i &amp;= or^i \\cdot (R_x^i(\\alpha) R_z^i(-\\chi) \\cdot \\color{red}{R_x^i(\\theta)} \\cdot \\color{black}{R_{\\phi, -\\psi, \\chi}^i} \\color{red}{R_x^i(\\theta)^T})     \\end{align} \\]</p> <p>These calculations are done in WorldUserParams.cpp. They have been tested but still there might be some mistake in there, so feel free to question the calculations if something is not working.</p> <p>Once you have the global position and orientation, you can derive the Transformation matrices by expanding the position p to a homogeneous translation matrix and the orientation to a homogeneous rotation matrix:</p> <p>\\[ M_{g2e} =  \\begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; -p_x \\\\ 0 &amp; 1 &amp; 0 &amp; -p_y \\\\ 0 &amp; 0 &amp; 1 &amp; -p_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\cdot or \\] \\[ M_{e2g} = M_{g2e}^{-1} = or^T \\cdot \\begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; p_x \\\\ 0 &amp; 1 &amp; 0 &amp; p_y \\\\ 0 &amp; 0 &amp; 1 &amp; p_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]</p>"},{"location":"Model/User-vs-Model-Parameter/","title":"User vs Model Parameter","text":"<p>In RAYX we intend to work on better modularity and readability in our code. In our opinion, one step to achieve this, to reevaluate and restructure the parameters of RAY-UI. Since a lot of the parameters had dependencies on each other, we decided that a distinction between them was needed. This is where our definition of User and Model Parameters comes into play. </p>"},{"location":"Model/User-vs-Model-Parameter/#model-parameter","title":"Model Parameter","text":"<p>A Model Parameter is any parameter that is directly influencing the calculations of the tracer. Further, a Model Parameter can also be a parameter, which is required for the fundamental definition of our model. </p>"},{"location":"Model/User-vs-Model-Parameter/#example","title":"Example","text":"<p>The position and direction Matrix are not directly used in the calculations of the Tracer, but they still are Model Parameters, since they are essential in directly defining our model.</p>"},{"location":"Model/User-vs-Model-Parameter/#user-parameters","title":"User Parameters","text":"<p>User Parameters are all the parameters that are only used to calculate Model Parameters. They only exist to improve the user experience of our application and are neither passed directly to the tracer nor are needed to define our model.</p>"},{"location":"Model/BeamlineObjects/","title":"Beamline Objects","text":"<p>In the following chapter, you will find extensive information on all the Beamline Objects supported by RAYX.</p>"},{"location":"Model/BeamlineObjects/#supported-objects","title":"Supported Objects","text":"<p>We divide the objects into two categories: Light Sources and Optical Elements. As the name suggests, the Light Sources are the objects that create the ray information, such as their starting position, the direction of the flight path, and the energy the ray is carrying.</p>"},{"location":"Model/BeamlineObjects/#light-sources","title":"Light Sources","text":"<ul> <li>Dipole Source</li> <li>Point Source</li> <li>Matrix Source</li> <li>Simple Undulator Source</li> <li>Circle Source</li> <li>Pixel Source</li> </ul>"},{"location":"Model/BeamlineObjects/#optical-elements","title":"Optical Elements","text":"<ul> <li>Image Plane</li> <li>Plane Mirror</li> <li>Plane Grating</li> <li>Cone Mirror</li> <li>Cone Grating</li> <li>Crystal</li> <li>Cylindrical Mirror</li> <li>Ellipsoid Mirror</li> <li>Foil</li> <li>Spherical Mirror</li> <li>Spherical Grating</li> <li>Toroidal Mirror</li> <li>Toroidal Grating</li> <li>Reflection Zone Plate</li> <li>Slit</li> <li>Custom Quadric Surface Mirror</li> <li>Custom Cubic Surface Mirror</li> </ul>"},{"location":"Model/BeamlineObjects/Beamline-Parameter/","title":"Beamline Parameter","text":"<p>This table explains all the parameters that can be used in a RAYX beamline. They are ordered for Elements and Sources and roughly in their order of importance.</p>"},{"location":"Model/BeamlineObjects/Beamline-Parameter/#light-source-parameter","title":"Light Source Parameter","text":"Name Description Number of Rays Number of rays emitted from the source Source Width Width of the light source in millimeters Source Height Height of the light source in millimeters Source Depth Depth of the light source in millimeters Horizontal Divergence Horizontal angular spread of the rays Vertical Divergence Vertical angular spread of the rays Source Width Distribution Distribution type for source width Source Height Distribution Distribution type for source height Horizontal Divergence Distribution Distribution type for horizontal divergence Vertical Divergence Distribution Distribution type for vertical divergence Linear Pol 0 Degree of linear polarization at 0 degrees Linear Pol 45 Degree of linear polarization at 45 degrees Circular Pol Degree of circular polarization Energy Distribution Type How the nergy distribution should be defined (e.g. Values, File) Energy Spread Type Distribution pattern for the Energy (e.g Gaussian) Energy Spread Spread of energy around the central photon energy Photon Energy Distribution File Filepath for .DAT- File with Energy distribution information Photon Energy Central photon energy Separate Energies Number of seperate energy spikes Electron Energy Orientation Movement in the Synchrotron (clockwise, counter-clockwise) Source Pulse Type (unused) Vertical E-beam Divergence Vertical divergence of the electron beam Bending Radius Bending radius of the electron bunch in a bending magnet Electron Energy Energy of the electrons in the source Alignment Error Possible misalignment of the source Photon Flux -- Photon Energy Central photon energy of the source Energy Spread Energy spread around the central energy Energy Spread Unit Unit for energy spread (eV) Number of Equidistant Circles -- Maximum Opening Angle Maximum divergence angle for the rays Minimum Opening Angle Minimum divergence angle for the rays Delta Opening Angle -- Parameter P -- Parameter P Type -- Sigma Type -- Undulator Length -- Electron Sigma X Horizontal electron beam size Electron Sigma Xs Horizontal electron beam divergence Electron Sigma Y Vertical electron beam size Electron Sigma Ys Vertical electron beam divergence"},{"location":"Model/BeamlineObjects/Beamline-Parameter/#optical-element-parameter","title":"Optical Element Parameter","text":"Name Description World Position 3D coordinates of the optical element's position Total Width Width of the optical element Total Length Length of the optical element Total Height Height of the optical element Grazing Incidence Angle Angle of incidence for grazing rays Arm Length Length of the arm of the optical element Entrance Arm Length Length of the entrance arm Exit Arm Length Length of the exit arm Entrance Arm Length (Mer) Meridional entrance arm length Exit Arm Length (Mer) Meridional exit arm length Entrance Arm Length (Sag) Sagittal entrance arm length Exit Arm Length (Sag) Sagittal exit arm length Central Beamstop Stop placed in the center of the beam Total Width Stop Width of the beamstop Total Height Stop Height of the beamstop Opening Width Width of the optical element opening Opening Height Height of the optical element opening Opening Shape Shape of the optical element opening (e.g., rectangle, circle) Grating Mount -- Radius Radius of curvature for curved surfaces Design Energy Target design energy for the optical element Line Density -- Order of Diffraction Diffraction order for grating elements Design Energy Mounting -- Design Order of Diffraction -- Design Alpha Angle -- Design Beta Angle -- Short Radius Short radius for elliptical elements Long Radius Long radius for elliptical elements Fresnel Z Offset -- Bending Radius Direction -- Parameter A11 -- Design Grazing Inc Angle Grazing incidence angle in design Long Half Axis A Long half-axis for elliptical elements Short Half Axis B Short half-axis for elliptical elements Figure Rotation -- Distance Preceding Distance from preceding element Misalignment Coordinate System Coordinate system for misalignment Reflectivity Type Type of reflectivity used Material Substrate Material of the substrate Geometrical Shape Shape of the optical element Image Type Type of image plane Azimuthal Angle Azimuthal angle of rotation Additional Order -- Slope Error Slope error for reflecting surfaces Slope Error Sag Sagittal slope error Slope Error Mer Meridional slope error Thermal Distortion Amp Amplitude of thermal distortion Thermal Distortion Sigma X Sigma in X for thermal distortion Thermal Distortion Sigma Z Sigma in Z for thermal distortion Cylindrical Bowing Amp Amplitude of cylindrical bowing Cylindrical Bowing Radius Radius for cylindrical bowing VLS Parameter -- Reflectivity Type Type of reflectivity coating Material Substrate Substrate material for reflecting surfaces Roughness Substrate Surface roughness of the substrate Density Substrate Density of the substrate material Surface Coating Coating material for the optical surface Coating File External file for custom coating Number Layer Number of layers in multilayer coatings Material Coating 1 Material of the first coating layer Thickness Coating 1 Thickness of the first coating layer Roughness Coating 1 Roughness of the first coating layer Density Coating 1 Density of the first coating layer Material Coating 2 Material of the second coating layer Thickness Coating 2 Thickness of the second coating layer Roughness Coating 2 Roughness of the second coating layer Density Coating 2 Density of the second coating layer Material Top Layer Material of the top layer coating Thickness Top Layer Thickness of the top layer coating Roughness Top Layer Roughness of the top layer coating Density Top Layer Density of the top layer coating Lattice Spacing \u00d7\u202f2 Twice the lattice spacing \\(2d\\) of the crystal (in nm) Unit Cell Volume Volume of the crystal's unit cell (in nm\u00b3) Structure Factor F\u2080 Real and imaginary parts of the forward scattering factor Structure Factor F_H Real and imaginary parts of the Bragg-reflected structure factor Structure Factor F_H\u0304 Real and imaginary parts of the conjugate reflected factor Offset Angle \u03b1 Crystal surface tilt relative to atomic planes (in radians)"},{"location":"Model/BeamlineObjects/LightSources/Circle-Source/","title":"Circle Source","text":""},{"location":"Model/BeamlineObjects/LightSources/Circle-Source/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. The values are randomly generated according to the given distribution. This ensures that minimal systematic errors impact the simulation.</p> <p>Light properties include: - Origin - Direction - Photon Energy - Polarization</p>"},{"location":"Model/BeamlineObjects/LightSources/Circle-Source/#origin","title":"Origin","text":"<p>The origin of each ray is described by its x, y, and z positions.</p>"},{"location":"Model/BeamlineObjects/LightSources/Circle-Source/#tracing-parameters","title":"Tracing Parameters","text":"<ul> <li>Source Depth</li> <li>Source Height</li> <li>Source Width</li> <li>Linear Pol 0</li> <li>Linear Pol 45</li> <li>Circular Pol</li> <li>numOfEquidistantCircles</li> <li>maxOpeningAngle</li> <li>minOpeningAngle</li> <li>deltaOpeningAngle</li> <li>Energy</li> <li>Energy Spread</li> <li>Energy Spread Type</li> <li>Energy Distribution Type</li> <li>Energy Distribution File</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/Circle-Source/#rml-object","title":"RML Object","text":"<p>To trace a Circle Source through an RML file, use an XML object to contain all relevant information for the light source. Below is the default configuration for the light source from RAY-UI for your convenience. It is recommended to include an Image Plane at the end for clearer results.</p> <pre><code>&lt;object name=\"Circle Source\" type=\"Circle Source\"&gt;\n   &lt;param id=\"numberRays\" enabled=\"T\"&gt;20000&lt;/param&gt;\n   &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n   &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n   &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"numberCircles\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"maximumOpeningAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"minimumOpeningAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"deltaOpeningAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/","title":"Dipole Source","text":"<p>The Dipole Source in RAYX is implemented to generate a realistic light beam. To simulate realistic behavior, the natural spectral and spatial distributions of synchrotron radiation are used as a foundation. Specifically, the distributions defined by the universal function for synchrotron radiation, as outlined by Wiedemann in Synchrotron Radiation, p. 159, are utilized.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#background","title":"Background","text":"<p>Dipole sources are among the most common light sources used to generate synchrotron radiation. In synchrotrons, dipole magnets are used to bend a charged particle beam. Depending on the strength of the magnetic field and other adjustable parameters, bending the particle beam produces X-rays\u2014high-energy photons traveling at relativistic speeds. These photons then travel through the beamline, interacting with optical elements, and eventually reaching an experiment at the end of the line.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. Each light source has a different approach to determining these, depending on which parts should be realistic and which should be synthetically generated. The values are randomly generated for the given distribution, ensuring that minimal systematic errors impact the simulation. The user provides a distribution window for these properties.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#origin","title":"Origin","text":"<p>The origin of each ray is described by its x, y, and z positions. For the dipole source, the position depends on the strength of the dipole magnet. In the coordinate system for the light source, x lies on the horizontal plane with z, while the y direction is \"up\" and \"down\" when looking from the source down the beamline (toward the experiment or the next optical element, described by z). The user has limited influence over the distribution of the position, which is primarily determined by the magnetic field and the horizontal divergence window.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#direction","title":"Direction","text":"<p>The direction is determined by the vertical and horizontal angles, based on the user's input for vertical and horizontal divergence. The direction is calculated using two variables: the Phi and Psi angles. Phi is determined randomly with a uniform distribution over the given horizontal divergence. Psi is more complex, depending on the polarization. From the given vertical electron beam divergence, a distribution window is calculated.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#energy","title":"Energy","text":"<p>The photon energy depends on the specified mean energy and the energy spread. The focus of the simulation is the distribution of photon energies among all generated rays. The energy can be understood as equivalent to the wavelength of the photon. For the dipole source, energy is randomly distributed according to the universal function for synchrotron radiation. The basis for this simulation is Helmut Wiedemann\u2019s description in Synchrotron Radiation, p. 259 (D.21), where edge cases simplify the simulation.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#polarization","title":"Polarization","text":"<p>Light polarization affects the reflective properties of the ray. Polarization is also important for the distribution of the vertical direction of the ray. As described by Helmut Wiedemann (Synchrotron Radiation, p. 155 (9.78)), polarization, direction, and photon energy jointly determine the distribution.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#struct-ray","title":"Struct Ray","text":"<p>In RAYX, all the generated information from the light sources is transferred to the optical elements using the <code>Ray</code> structure.</p>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#tracing-parameters","title":"Tracing Parameters","text":"<ul> <li>Energy Distribution</li> <li>Photon Flux</li> <li>Electron Energy Orientation</li> <li>Source Pulse Type</li> <li>Bending Radius</li> <li>Electron Energy</li> <li>Photon Energy</li> <li>Vertical E-beam Divergence</li> <li>Energy Spread</li> <li>Energy Spread Unit</li> <li>Horizontal Divergence</li> <li>Source Height</li> <li>Source Width</li> <li>Energy</li> <li>Energy Spread</li> <li>Energy Spread Type</li> <li>Energy Distribution Type</li> <li>Energy Distribution File</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/DipoleSource/#rml-object","title":"RML Object","text":"<p>To trace a Dipole Source through an RML file, use an XML object to contain all relevant information for the light source. Below is the default configuration for the light source from RAY-UI for your convenience. It is recommended to include an Image Plane at the end for clearer results.</p> <pre><code>&lt;object name=\"Dipole Source\" type=\"Dipole Source\"&gt;\n    &lt;param id=\"numberRays\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n    &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n    &lt;param id=\"verEbeamDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"horDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"electronEnergy\" enabled=\"T\"&gt;1.7&lt;/param&gt;\n    &lt;param id=\"electronEnergyOrientation\" comment=\"clockwise\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"bendingRadius\" enabled=\"T\"&gt;4.35&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n     &lt;x&gt;0.0000000000000000&lt;/x&gt;\n     &lt;y&gt;0.0000000000000000&lt;/y&gt;\n     &lt;z&gt;0.0000000000000000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n     &lt;x&gt;1.0000000000000000&lt;/x&gt;\n     &lt;y&gt;0.0000000000000000&lt;/y&gt;\n     &lt;z&gt;0.0000000000000000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n     &lt;x&gt;0.0000000000000000&lt;/x&gt;\n     &lt;y&gt;1.0000000000000000&lt;/y&gt;\n     &lt;z&gt;0.0000000000000000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n     &lt;x&gt;0.0000000000000000&lt;/x&gt;\n     &lt;y&gt;0.0000000000000000&lt;/y&gt;\n     &lt;z&gt;1.0000000000000000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energySpreadUnit\" comment=\"eV\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"photonFlux\" enabled=\"T\"&gt;2.76089e+12&lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/","title":"Light Sources","text":"<p>Light sources are the starting point for each ray. Here, the properties of the light are set. Depending on user input, the direction, photon energy, and light polarization are determined. This section provides a description of how the light sources are implemented and how to use them for different beamlines. Depending on your needs, it can be useful to understand which light source is most suitable. The key part of light source implementation in RAYX is the overall distribution of values. Most light sources produce a spectrum of light rays. </p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#implemented-sources","title":"Implemented Sources","text":"<p>Currently, there are six light sources implemented in RAYX. They are fundamentally different and serve various purposes:</p> <ul> <li>Dipole Source</li> <li>Matrix Source</li> <li>Point Source</li> <li>Circle Source</li> <li>Pixel Source</li> <li>Simple Undulator Source</li> </ul> <p>The Matrix and Point Sources are conceptual sources, whereas the Dipole Source aims to replicate real-world behavior as accurately as possible.</p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. Each light source has a different approach to determining these, depending on which aspects should be realistic and which should be synthetically generated. The values are almost always in a given distribution window and are randomly generated. This ensures minimal systematic errors impact the ray generation. The user can choose a distribution window and a distribution type.</p> <p>Parameters: - Origin - Direction - Photon Energy - Polarization</p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#origin","title":"Origin","text":"<p>The user sets the following parameters: * Source width (x-dir) * Source height (y-dir) * Source depth (z-dir) * Distribution types (up to 3 different ones)</p> <p>The origin for each ray is described by x, y, and z values.</p> <p>With repeatability in mind, the Matrix Source has a fully deterministic approach to setting the origin of each ray. All rays are positioned in a uniform grid within the given width and height. Depending on the number of rays, this grid can appear sparse or fully filled.</p> <p>The Point Source uses preset distribution types for the positions. Each ray has a random origin, but when considered collectively, they represent the chosen distribution type. Common choices are either hard-edge or soft-edge distributions.</p> <p>The Dipole Source additionally considers the horizontal divergence and bending radius. The origin positions are in a 3-dimensional curve, representing the trajectory of the electrons in the synchrotron. The positions have a natural distribution that depends on the horizontal divergence of the electron beam.</p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#direction","title":"Direction","text":"<p>The user sets the following parameters: * Horizontal divergence (x-dir) * Vertical divergence (y-dir) * Distribution type</p> <p>The direction for each ray is calculated using the phi and psi values, which are the horizontal and vertical angles of the direction. A direction vector is then calculated from these angles and used in the tracing process.</p> <p>Each source has different directional behaviors, which are detailed in their respective chapters.</p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#energy","title":"Energy","text":"<p>The user sets the following parameters: * Photon Energy (mean) * Energy Spread * Distribution type * (File path)</p> <p>Photon energy is understood as the mean energy in a given distribution. If the energy spread is defined as 0, all rays have the same energy.</p> <p>The energy is equivalent to the wavelength of the light ray. Different distribution types are available for observing the behavior.</p>"},{"location":"Model/BeamlineObjects/LightSources/LightSources/#polarization","title":"Polarization","text":"<p>Light polarization impacts the reflective properties of the ray. Depending on the light source, it is either calculated or provided by the user.</p> <p>For more information on how to implement and use light sources, please refer to the documentation for the specific light source (updated soon).</p>"},{"location":"Model/BeamlineObjects/LightSources/Matrix-Source/","title":"Matrix Source","text":""},{"location":"Model/BeamlineObjects/LightSources/Matrix-Source/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. The values are randomly generated within the given distribution. This guarantees that minimal systematic errors impact the simulation.</p> <p>Light properties: - Origin - Direction - Photon Energy - Polarization</p>"},{"location":"Model/BeamlineObjects/LightSources/Matrix-Source/#origin","title":"Origin","text":"<p>The origin for each ray is described by its x, y, and z position.</p>"},{"location":"Model/BeamlineObjects/LightSources/Matrix-Source/#tracing-parameters","title":"Tracing Parameters","text":"<ul> <li>Ver Div</li> <li>Hor Div</li> <li>Source Depth</li> <li>Source Height</li> <li>Source Width</li> <li>Linear Pol 0</li> <li>Linear Pol 45</li> <li>Circular Pol</li> <li>Energy</li> <li>Energy Spread</li> <li>Energy Spread Type</li> <li>Energy Distribution Type</li> <li>Energy Distribution File</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/Matrix-Source/#rml-object","title":"RML Object","text":"<p>To trace a Pixel Source through an RML file, use an XML object to encompass all pertinent information for the light source. The default configuration for the light source from RAY-UI is presented here for ease of use. It is recommended to include an Imageplane at the end for clearer results.</p> <pre><code>&lt;object name=\"Pixel Source\" type=\"Pixel Source\"&gt;\n   &lt;param id=\"numberRays\" enabled=\"T\"&gt;20000&lt;/param&gt;\n   &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n   &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n   &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"horDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"verDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;1.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/Pixel-Source/","title":"Pixel Source","text":""},{"location":"Model/BeamlineObjects/LightSources/Pixel-Source/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. The values are randomly generated for the given distribution. This guarantees that minimal systematic errors impact the simulation.</p> <p>Light properties: - Origin - Direction - Photon Energy - Polarization</p>"},{"location":"Model/BeamlineObjects/LightSources/Pixel-Source/#origin","title":"Origin","text":"<p>The origin for each ray is described by its x, y, and z position.</p>"},{"location":"Model/BeamlineObjects/LightSources/Pixel-Source/#tracing-parameters","title":"Tracing Parameters","text":"<ul> <li>Ver Div</li> <li>Hor Div</li> <li>Source Depth</li> <li>Source Height</li> <li>Source Width</li> <li>Linear Pol 0</li> <li>Linear Pol 45</li> <li>Circular Pol</li> <li>Energy</li> <li>Energy Spread</li> <li>Energy Spread Type</li> <li>Energy Distribution Type</li> <li>Energy Distribution File</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/Pixel-Source/#rml-object","title":"RML Object","text":"<p>To trace a Pixel Source through an RML file, use an XML object to encompass all pertinent information for the light source. The default configuration for the light source from RAY-UI is presented here for ease of use. It is recommended to include an Imageplane at the end for clearer results.</p> <pre><code>&lt;object name=\"Pixel Source\" type=\"Pixel Source\"&gt;\n   &lt;param id=\"numberRays\" enabled=\"T\"&gt;20000&lt;/param&gt;\n   &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n   &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n   &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"horDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"verDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;1.0000000000000000&lt;/y&gt;\n      &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0.0000000000000000&lt;/x&gt;\n      &lt;y&gt;0.0000000000000000&lt;/y&gt;\n      &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/Point-Source/","title":"Point Source","text":""},{"location":"Model/BeamlineObjects/LightSources/Point-Source/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is described by four properties. The values are randomly generated within the given distribution to ensure minimal systematic errors during simulation.</p> <p>Light properties: - Origin - Direction - Photon Energy - Polarization</p>"},{"location":"Model/BeamlineObjects/LightSources/Point-Source/#origin","title":"Origin","text":"<p>The origin for each ray is described by its x, y, and z position.</p>"},{"location":"Model/BeamlineObjects/LightSources/Point-Source/#tracing-parameters","title":"Tracing Parameters","text":"<ul> <li>sourceWidthDistribution</li> <li>sourceHeightDistribution</li> <li>horDivDistribution</li> <li>verDivDistribution</li> <li>Ver Div</li> <li>Hor Div</li> <li>Source Depth</li> <li>Source Height</li> <li>Source Width</li> <li>Linear Pol 0</li> <li>Linear Pol 45</li> <li>Circular Pol</li> <li>Energy</li> <li>Energy Spread</li> <li>Energy Spread Type</li> <li>Energy Distribution Type</li> <li>Energy Distribution File</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/Point-Source/#rml-object","title":"RML Object","text":"<p>To trace a Point Source through an RML file, use an XML object to encapsulate all relevant information about the light source. Below is the default configuration for a point source from RAY-UI, which can be used as a template. It is recommended to include an Imageplane at the end for clearer simulation results.</p> <pre><code>&lt;object name=\"Point Source\" type=\"Point Source\"&gt;\n    &lt;param id=\"numberRays\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"sourceWidthDistribution\" comment=\"gaussian (sigma)\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"sourceWidth\" enabled=\"T\"&gt;0.065&lt;/param&gt;\n    &lt;param id=\"sourceHeightDistribution\" comment=\"gaussian (sigma)\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"sourceHeight\" enabled=\"T\"&gt;0.04&lt;/param&gt;\n    &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"horDivDistribution\" comment=\"gaussian (sigma)\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"horDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"verDivDistribution\" comment=\"gaussian (sigma)\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"verDiv\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"Yes\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;5&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;5&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;151&lt;/param&gt;\n    &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energySpreadUnit\" comment=\"eV\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"energySpread\" enabled=\"T\"&gt;6&lt;/param&gt;\n    &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;1&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;1&lt;/z&gt;\n    &lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/","title":"Simple Undulator Source","text":"<p>The Simple Undulator source in RAYX approximates the physics of a real undulator source, allowing for faster tracing of an undulator light beam. This light source uses Gaussian Beam Theory, which simplifies the beam properties significantly. By treating the light beam as a collection of individual rays, complex wave theory can be substituted with approximations.</p> <p>Simply put, Gaussian Beam Theory states that certain beam properties are distributed in Gaussian patterns. These patterns flatten or squeeze after collisions with optical elements, but generally, the beam maintains a Gaussian bell curve shape.</p>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/#light-properties","title":"Light Properties","text":"<p>In RAYX, every ray is characterized by four properties, which are randomly generated to ensure minimal systematic errors in the simulation:</p> <ul> <li>Origin: Position in x, y, and z coordinates.</li> <li>Direction: Direction vector of the ray.</li> <li>Photon Energy: Energy of the photon carried by the ray.</li> <li>Polarization: Polarization state of the photon.</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/#origin","title":"Origin","text":"<p>The origin for each ray is described by x, y, and z positions.</p>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/#tracing-parameters","title":"Tracing Parameters","text":"<p>Key parameters used for tracing an undulator source include:</p> <ul> <li>sourceDepth: Depth of the light source.</li> <li>linearPol0: Linear polarization at 0 degrees.</li> <li>linearPol45: Linear polarization at 45 degrees.</li> <li>circularPol: Circular polarization.</li> <li>undulatorLength: Length of the undulator.</li> <li>photonEnergy: Energy of the photons.</li> <li>sigmaType: Type of sigma (distribution type).</li> <li>electronSigmaX: Horizontal electron beam size.</li> <li>electronSigmaXs: Horizontal electron beam divergence.</li> <li>electronSigmaY: Vertical electron beam size.</li> <li>electronSigmaYs: Vertical electron beam divergence.</li> <li>Energy: Photon energy level.</li> <li>Energy Spread: Spread in energy.</li> <li>Energy Spread Type: Type of energy spread (e.g., white band).</li> <li>Energy Distribution Type: Distribution type of the photon energy.</li> <li>Energy Distribution File: File used to define energy distribution.</li> </ul>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/#rml-object","title":"RML Object","text":"<p>To trace a Simple Undulator Source using an RML file, you can define the source in an XML format. The default configuration from RAY-UI is provided here, which can be customized for your specific needs. It is advisable to include an Imageplane at the end for more accurate results.</p> <pre><code>&lt;object name=\"Simple Undulator\" type=\"Simple Undulator\"&gt;\n   &lt;param id=\"numberRays\" enabled=\"T\"&gt;20000&lt;/param&gt;\n   &lt;param id=\"sigmaType\" comment=\"standard\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"undulatorLength\" enabled=\"T\"&gt;4&lt;/param&gt;\n   &lt;param id=\"electronDistributionType\" comment=\"manual\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"electronSigmaX\" enabled=\"T\"&gt;216&lt;/param&gt;\n   &lt;param id=\"electronSigmaXs\" enabled=\"T\"&gt;24.8&lt;/param&gt;\n   &lt;param id=\"electronSigmaY\" enabled=\"T\"&gt;18.7&lt;/param&gt;\n   &lt;param id=\"electronSigmaYs\" enabled=\"T\"&gt;4.3&lt;/param&gt;\n   &lt;param id=\"sourceDepth\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/x&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/x&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"energyDistributionType\" comment=\"Values\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"photonEnergyDistributionFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"photonEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"energySpreadType\" comment=\"white band\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"energySpreadUnit\" comment=\"eV\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"energySpread\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"linearPol_0\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"linearPol_45\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"circularPol\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseType\" comment=\"all rays start simultaneously\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"sourcePulseLength\" enabled=\"F\"&gt;0&lt;/param&gt;\n&lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/LightSources/SimpleUndulatorSource/#literature","title":"Literature","text":"<p>[1] Representation of a Gaussian Beam by Rays, P. P. Crooker, W. B. Colson, and J. Blau, Physics Department, Naval Postgraduate School, Monterey, California. Published 2006.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Cone-Mirror/","title":"Cone Mirror","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Cone-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Cone: - Grazing Inc Angle - Entrance Arm Length - Exit Arm Length - Total Length</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Cone-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Cone Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>    &lt;object name=\"Cone\" type=\"Cone\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"entranceArmLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLength\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"upstreamRadius\" auto=\"T\" enabled=\"T\"&gt;346.85522293840654&lt;/param&gt;\n    &lt;param id=\"downstreamRadius\" auto=\"T\" enabled=\"T\"&gt;284.67930120577341&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.300000000000001&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.98480775301220802&lt;/y&gt;\n      &lt;z&gt;-0.17364817766693033&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.17364817766693033&lt;/y&gt;\n      &lt;z&gt;0.98480775301220802&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/","title":"Plane-Crystal","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#crystal-diffraction","title":"Crystal Diffraction","text":"<p>We simulate X-ray diffraction using the dynamical theory in the Bragg-case geometry, assuming a perfect and thick crystal. </p> <p>We compute the reflection coefficient based on this model. The reflected field is then determined from it. To run this simulation, the following user inputs are required:</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#required-inputs","title":"Required Inputs","text":"<ul> <li>Photon energy (in eV)  </li> <li>lattice spacing*2 (in nm)  </li> <li>Unit cell volume (in nm\u00b3)  </li> <li>Structure factors:  </li> <li>F\u2080, F_H, F_H\u0304 with real/imaginary components</li> <li>Crystal surface offset angle \u03b1 (in radians)</li> </ul> <p>The following sections explain how each physical quantity and formula is derived and used in the simulation. This section details the implementation of dynamical X-ray diffraction theory for perfect crystals, based on the foundational work of Batterman &amp; Cole (1964). </p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#bragg-angle-calculation","title":"Bragg Angle Calculation","text":"<p>\\[ \\theta_B = \\arcsin\\left(\\frac{\\lambda}{2d}\\right) \\]</p> <ul> <li>Function: <code>getBraggAngle(energy, dSpacing2)</code></li> <li>Purpose: Calculate the Bragg diffraction angle</li> <li>Parameters:</li> <li><code>energy</code>: Photon energy (eV)</li> <li><code>dSpacing2</code>: lattice spacing*2 (nm)</li> <li>Returns: Bragg angle in radians</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#asymmetry-factor","title":"Asymmetry Factor","text":"<p>\\[ b = \\frac{\\sin(\\theta_B - \\alpha)}{\\sin(\\theta_B + \\alpha)} \\]</p> <ul> <li>Function: <code>getAsymmetryFactor(braggAngle, offsetAngle)</code></li> <li>Purpose: Account for crystal surface orientation effects</li> <li>Parameters:</li> <li><code>braggAngle</code>: Calculated Bragg angle</li> <li><code>offsetAngle</code>: Surface tilt angle \u03b1</li> </ul> <p>This definition corresponds to the asymmetry factor derived from direction cosines and is consistent with the definition on page 690 in Batterman &amp; Cole (1964).</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#diffraction-prefactor","title":"Diffraction Prefactor","text":"<p>\\[ \\Gamma = \\frac{r_e \\lambda^2}{\\pi V} \\]</p> <ul> <li>Function: <code>getDiffractionPrefactor(wavelength, unitCellVolume)</code></li> <li>Purpose: Calculate scaling factor for absorption/dispersion</li> <li>Parameters:</li> <li><code>wavelength</code>: X-ray wavelength (nm)</li> <li><code>unitCellVolume</code>: Unit cell volume (nm\u00b3)</li> </ul> <p>Gamma is defined in Batterman &amp; Cole (1964) p.\u202f685.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#eta-parameter","title":"Eta Parameter (\u03b7)","text":"<p>\\[ \\eta = \\frac{b\\Delta\\theta\\sin 2\\theta + \\frac{1}{2}\\Gamma F_0(1-b)}{\\Gamma|P|\\sqrt{|b|}\\sqrt{F_H F_{\\overline{H}}}} \\]</p> <ul> <li>Function: <code>computeEta(theta, bragg, asymmetry, FH_re, FH_im, FHC_re, FHC_im, F0_re, F0_im, polFactor, gamma)</code></li> <li>Purpose: Compute normalized angular deviation parameter</li> <li>Parameters:</li> <li>Structure factors (F\u2080, F_H, F_H\u0304) with real/imaginary components</li> <li><code>polFactor</code>: Polarization factor (1 or |cos2\u03b8_B|)</li> </ul> <p>Eta is defined as equation (32) in Batterman &amp; Cole (1964) p. 690 .</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#reflection-coefficient-r","title":"Reflection Coefficient (R)","text":"<p>\\[ R = \\left(\\eta \\pm \\sqrt{\\eta^2 - 1}\\right)\\sqrt{\\frac{F_H}{F_{\\overline{H}}}} \\]</p> <ul> <li>Function: <code>computeR(eta, FH_re, FH_im, FHC_re, FHC_im)</code></li> <li>Purpose: Calculate complex reflection coefficient</li> <li>Note: Sign selection based on real part of \u03b7</li> </ul> <p>This function is based on Equation (103) from  Batterman &amp; Cole (1964) p.\u202f706. We applied the square to the structure factor terms in advance and omitted the leading \\(|b|\\) factor.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#polarization-factors","title":"Polarization Factors","text":"<p>Two states considered: - \\(\\sigma\\)-polarization: \\(P = 1\\) - \\(\\pi\\)-polarization: \\(P = |\\cos 2\\theta_B|\\)</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Crystal/#references","title":"References","text":"<ul> <li>Batterman, B. W., &amp; Cole, H. (1964). Dynamical Diffraction of X Rays by Perfect Crystals. Reviews of Modern Physics, 36(3), 681\u2013717. https://doi.org/10.1103/RevModPhys.36.681</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/Cylinder-Mirror/","title":"Cylindrical Mirror","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Cylinder-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Cylinder: - Bending Radius - Radius - Grazing Inc Angle - Entrance Arm Length - Exit Arm Length</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Cylinder-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Cylindrical Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>    &lt;object name=\"Cylinder\" type=\"Cylinder\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"entranceArmLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLength\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"bendingRadius\" comment=\"Long Radius R\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"radius\" auto=\"T\" enabled=\"T\"&gt;10470.4917875&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.98480775301220802&lt;/y&gt;\n      &lt;z&gt;-0.17364817766693033&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.17364817766693033&lt;/y&gt;\n      &lt;z&gt;0.98480775301220802&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Ellipsoid-Mirror/","title":"Ellipsoid Mirror","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Ellipsoid-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Ellipoid: - Entrance Arm Length - Exit Arm Length - Short Half Axis B - Long Half Axis A - Design Grazing Inc Angle - Figure Rotation - Parameter A11</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Ellipsoid-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Ellipsoid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>    &lt;object name=\"Ellipsoid\" type=\"Ellipsoid\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"entranceArmLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLength\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"designGrazingIncAngle\" auto=\"T\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"longHalfAxisA\" auto=\"T\" enabled=\"T\"&gt;5500&lt;/param&gt;\n    &lt;param id=\"shortHalfAxisB\" auto=\"T\" enabled=\"T\"&gt;549.12375296508355&lt;/param&gt;\n    &lt;param id=\"figureRotation\" comment=\"Yes\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"parameter_a11\" enabled=\"F\"&gt;1&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.300000000000001&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"misalignmentCoordinateSystem\" comment=\"Ellipsoid\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.98480775301220802&lt;/y&gt;\n      &lt;z&gt;-0.17364817766693033&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.17364817766693033&lt;/y&gt;\n      &lt;z&gt;0.98480775301220802&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/","title":"Foil","text":"<p>The Foil is an optical element that simulates the interaction of light with thin material layers (e.g., gold filters). It calculates polarization-dependent transmission/reflection using Fresnel equations.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Foil: - Substrate Thicness - Substrate Roughness </p>"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#transmission-coefficient-calculation","title":"Transmission Coefficient Calculation","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#angle-theta","title":"Angle Theta","text":"\\[\\begin{aligned} \\sin\\theta_1 &amp;= \\frac{N_1}{N_2}\\sin\\theta_0 \\\\ \\theta_2 &amp;= \\theta_0 \\quad \\text{(Exit angle equals incidence angle)} \\end{aligned}\\]"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#fresnel-coefficients","title":"Fresnel Coefficients","text":"<p>These are calculated for the entrance and exit surfaces.  \\begin{aligned} r_s &amp;= \\frac{N_1\\cos\\theta_0 - N_2\\cos\\theta_1}{N_1\\cos\\theta_0 + N_2\\cos\\theta_1}, \\  t_s &amp;= \\frac{2N_1\\cos\\theta_0}{N_1\\cos\\theta_0 + N_2\\cos\\theta_1} \\ r_p &amp;= \\frac{N_2\\cos\\theta_0 - N_1\\cos\\theta_1}{N_2\\cos\\theta_0 + N_1\\cos\\theta_1}, \\ t_p &amp;= \\frac{2N_1\\cos\\theta_0}{N_2\\cos\\theta_0 + N_1\\cos\\theta_1} \\end{aligned}</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#phaseshift","title":"Phaseshift","text":"<p>\\begin{aligned} \\delta &amp;= \\frac{2\\pi}{\\lambda}N_2d\\cos\\theta_1, \\ \\phi &amp;= e^{i\\delta} \\end{aligned}</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#total-transmission","title":"Total Transmission","text":"\\[\\begin{aligned} t_{\\text{total}} &amp;= \\frac{t_{01}t_{12}e^{i\\delta}}{1 + r_{01}r_{12}e^{2i\\delta}} \\end{aligned}\\]"},{"location":"Model/BeamlineObjects/OpticalElements/Foil/#rml-configuration","title":"RML Configuration","text":"<pre><code>  &lt;object name=\"Foil\" type=\"Foil\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;40&lt;/param&gt;\n   &lt;param id=\"totalHeight\" enabled=\"T\"&gt;60&lt;/param&gt;\n   &lt;param id=\"normalIncidenceAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"transmissionType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n   &lt;param id=\"thicknessSubstrate\" enabled=\"T\"&gt;50&lt;/param&gt;\n   &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.3&lt;/param&gt;\n   &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"lateralThicknessGradientCoating\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;10000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/","title":"Image Plane","text":"<p>The Image Plane is a fundamental optical element characterized by its flat, absorbing surface. This element is designed to capture all incoming rays, regardless of their direction or divergence. The Image Plane can be used in various optical simulations and is typically placed at a specified distance from the light source.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#light-properties","title":"Light Properties","text":"<p>In an Image Plane, rays are absorbed upon contact, allowing for the collection of all light interacting with the surface. This element does not modify the rays' properties but serves as a detector or absorber.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#standard-image-plane","title":"Standard Image Plane","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#rml-configuration","title":"RML Configuration","text":"<p>The standard configuration for an Image Plane does not impose any restrictions on size, meaning it effectively has an unlimited area for rays to hit.</p> <pre><code>  &lt;object name=\"ImagePlane\" type=\"ImagePlane\"&gt;\n   &lt;param id=\"distanceImagePlane\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#parameters","title":"Parameters","text":"<ul> <li>distanceImagePlane: The distance from the light source to the image plane.</li> <li>worldPosition: The (x, y, z) coordinates of the image plane in world space.</li> <li>worldXdirection: Direction vector along the X-axis.</li> <li>worldYdirection: Direction vector along the Y-axis.</li> <li>worldZdirection: Direction vector along the Z-axis.</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#image-plane-with-cutout","title":"Image Plane with Cutout","text":"<p>In scenarios where only a specific area of the image plane is needed, a cutout can be specified. This will restrict the absorption to the defined geometrical shape.</p> <pre><code>  &lt;object name=\"ImagePlane\" type=\"ImagePlane\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n   &lt;param id=\"totalHeight\" enabled=\"T\"&gt;200&lt;/param&gt;\n   &lt;param id=\"distanceImagePlane\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Image-Plane/#parameters-with-cutout","title":"Parameters with Cutout","text":"<ul> <li>geometricalShape: The shape of the cutout (e.g., rectangle).</li> <li>totalWidth: Width of the image plane (or cutout).</li> <li>totalHeight: Height of the image plane (or cutout).</li> <li>distanceImagePlane: The distance from the light source to the image plane.</li> <li>worldPosition: The (x, y, z) coordinates of the image plane in world space.</li> <li>worldXdirection: Direction vector along the X-axis.</li> <li>worldYdirection: Direction vector along the Y-axis.</li> <li>worldZdirection: Direction vector along the Z-axis.</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/","title":"Optical Elements","text":"<p>Optical elements are a central part of the tracing process. They define how light is guided through the beamline - where it is focused, redirected, or scattered. In the context of RAYX a beamline consists of two types of elements:</p> <ul> <li>LightSources, to create the rays, and</li> <li>OpticalElements, to be hit by and manipulate these rays</li> </ul> <p>In this section, you can read up on the design choices we made when implementing OpticalElements in RAYX.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#behavior-cutout-surface-coating","title":"Behavior, Cutout, Surface, Coating","text":"<p>Next to its position and orientation, an OpticalElement is classified by three parts: The Behaviour, Surface and Cutout.</p> <ul> <li>The Behavior defines how the element interacts with a ray (eg. reflecting, absorbing, redirecting)</li> <li>The Surface expresses the curvature of an OpticalElement</li> <li>The cutout defines the boundaries of the OpticalElement. In other words it \"cuts\" a finite shape out of the large Surface.</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#behavior","title":"Behavior","text":"<p>Behavior determines what happens to a ray once it hits the OpticalElement. Such a \"hit\" might result in absorbtion, reflection or the ray might pass through the OpticalElement. Typical examples of Behaviours are Mirror, Grating, Slit and RZP.</p> <p>Behaviours are defined in the Shared/Behaviour.h file. Each Behaviour has a \"behave\" function (eg. behaveMirror, behaveSlit, ...) that translates the incoming ray to the outgoing ray. These functions are gathered in the behave.comp file.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#surface","title":"Surface","text":"<p>Surfaces in RAYX are defined as either a plane, a quadric, or a toroid. We use mathematical formulas to represent them internally, which means they are not necessarily bounded in size. Optical elements are often subtly curved; to the human eye, they might appear indistinguishable from planar elements.</p> <p>There are two ways to describe the reflectivity of the Surface. The User can choose between reflectivity Type '100%' and 'derived by material'. If you want the second option you need to specify the following parameter:</p> <ul> <li>Material Substrate</li> <li>Roughness Substrate</li> <li>Density Substrate</li> <li>Surface Coating</li> <li>Coating File</li> <li>Number Layer</li> <li>Material Coating 1</li> <li>Thickness Coating 1</li> <li>Roughness Coating 1</li> <li>Density Coating 1</li> <li>Material Coating 2</li> <li>Thickness Coating 2</li> <li>Roughness Coating 2</li> <li>Density Coating 2</li> <li>Material Top Layer</li> <li>Thickness Top Layer</li> <li>Roughness Top Layer</li> <li>Density Top Layer</li> </ul> <p>An example of the RML input looks like this:</p> <pre><code>    &lt;param id=\"reflectivityType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.300000000000001&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#cutout","title":"Cutout","text":"<p>The cutout defines the boundaries of the OpticalElement, by cutting a shape out of the Surface. As the surfaces of OpticalElements often only slightly differ from the XZ plane, we implement Cutouts by a simple 2D shape applied to the coordinates X and Z.</p> <p>Cutouts come in different shapes: - Rectangle - Ellipse - Trapezoid - Unlimited</p> <p>The central function is the <code>bool inCutout(Cutout cutout, double x, double z);</code>. A given 3D point <code>p</code> is within the cutout c, if <code>inCutout(c, p.x, p.z)</code> returns <code>true</code>.</p> <p>Not all OpticalElements use exactly one Cutout. The Slit for example uses three Cutouts, one for the ray-absorbing shape around the \"opening\", then one for the \"opening\" itself, and another one for the ray-absorbing beamstop within the opening.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#coating","title":"Coating","text":"<p>The Coating describes the Layers a Mirror or Grating can have: No Layer, Single Layer or Multilayer. </p>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#ray-opticalelement-collision","title":"Ray-OpticalElement collision","text":"<p>When checking whether a ray collides with an OpticalElement, we first convert the Ray to the element coordinate system of the ray. This makes (0, 0, 0) the center of the element, which generally lies in the XZ plane. Rays then come from negative or positive y.</p> <p>We then ask the Surface of our OpticalElement for a hitpoint using the <code>findCollisionWith</code> function. And finally, if this hitpoint is in the cutout, we have found a collision.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/OpticalElements/#how-they-are-combined","title":"How They Are Combined","text":"<p>In the following image, you can see a visualization of how the surface and cutout interact. The surface is a quadric that defines a sphere. The cutout is a rectangle, defined by points \\(A\\), \\(B\\), \\(C\\), and \\(D\\).</p> <p>Coupled with the <code>icurv</code> parameter, the cutout is mapped to the correct side of the sphere, visualized by points \\(A_1\\), \\(B_1\\), \\(C_1\\), and \\(D_1\\). If a ray intersects the element's surface within the bounds of the cutout, it will be counted as a hit. This is, where the behaviour comes into play to calculate the continuing path of the ray.</p> <p>The cutout itself does not have a position; it is always at the origin of the element's coordinate system.</p> <p>For some quadrics, this rule might not adequately define the position. Therefore, we use the <code>icurv</code> parameter to determine whether the quadric is concave or convex. This suffices since we calculate all intersection points with elements. When two intersections occur, the <code>icurv</code> parameter informs us which intersection point to select.</p> <p></p>"},{"location":"Model/BeamlineObjects/OpticalElements/Paraboloid-Mirror/","title":"Paraboloid Mirror","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Paraboloid-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Paraboloid: - Arm Length - Parameter P - Parameter P Type - Grazing Inc Angle - Parameter </p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Paraboloid-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Paraboloid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>    &lt;object name=\"Paraboloid\" type=\"Paraboloid\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n   &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n   &lt;param id=\"secondSurface\" comment=\"on\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n   &lt;param id=\"armLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"parameter_P_type\" comment=\"focusing\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"parameter_P\" auto=\"T\" enabled=\"T\"&gt;-603.0737921409161&lt;/param&gt;\n   &lt;param id=\"figureRotation\" comment=\"Yes\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"parameter_a11\" enabled=\"F\"&gt;1&lt;/param&gt;\n   &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n   &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n   &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n   &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"lateralThicknessGradientCoating\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"misalignmentCoordinateSystem\" comment=\"Paraboloid\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;10000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.9848077530122080&lt;/x&gt;\n    &lt;y&gt;0.1736481776669303&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;-0.1736481776669303&lt;/x&gt;\n    &lt;y&gt;0.9848077530122080&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Grating/","title":"Plane Grating","text":"<p>A Plane Grating is amongst the simplest Elements you can include in your beamline. The Surface is flat and it reflects light like an optical grating. </p>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Grating/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Grating: - vls parameter - Line Density - Order Of Diffraction</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Grating/#rml-object","title":"RML Object","text":"<p>To track a Plane Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>  &lt;object name=\"Plane Grating\" type=\"Plane Grating\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"gratingMount\" comment=\"constant deviation\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"systemMount\" comment=\"standalone, none\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"deviationAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"halfConeAngle\" enabled=\"F\"&gt;10&lt;/param&gt;\n    &lt;param id=\"pimpaleX0\" enabled=\"F\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"pimpaleY0\" enabled=\"F\"&gt;10&lt;/param&gt;\n    &lt;param id=\"premirrorMountPsi0\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"designEnergyMounting\" auto=\"T\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"lineDensity\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"orderDiffraction\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"cFactor\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"alpha\" auto=\"T\" enabled=\"T\"&gt;5.35655050894&lt;/param&gt;\n    &lt;param id=\"beta\" auto=\"T\" enabled=\"T\"&gt;-4.64344949106&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"entranceArmLength\" enabled=\"F\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"lineSpacing\" comment=\"constant\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"vlsParameterB7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lineProfile\" comment=\"unknown\" enabled=\"F\"&gt;3&lt;/param&gt;\n    &lt;param id=\"gratingEfficiency\" enabled=\"F\"&gt;0.5&lt;/param&gt;\n    &lt;param id=\"blazeAngle\" enabled=\"F\"&gt;4&lt;/param&gt;\n    &lt;param id=\"aspectAngle\" enabled=\"F\"&gt;90&lt;/param&gt;\n    &lt;param id=\"grooveDepth\" enabled=\"F\"&gt;10&lt;/param&gt;\n    &lt;param id=\"grooveRatio\" enabled=\"F\"&gt;0.65&lt;/param&gt;\n    &lt;param id=\"multilayerFourierCoefficients\" auto=\"T\" enabled=\"F\"&gt;11&lt;/param&gt;\n    &lt;param id=\"multilayerIntegrationSteps\" auto=\"T\" enabled=\"F\"&gt;50&lt;/param&gt;\n    &lt;param id=\"reflectivitySenkrecht\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"reflectivityParallel\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"reflectivityPhase\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.766044443118978&lt;/y&gt;\n      &lt;z&gt;-0.6427876096865393&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.6427876096865393&lt;/y&gt;\n      &lt;z&gt;0.766044443118978&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Mirror/","title":"Plane Mirror","text":"<p>A Plane Mirror is amongst the simplest Elements you can include in your beamline. The Surface is flat and reflective as described by the material. </p>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Plane-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Plane Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>  &lt;object name=\"Plane Mirror\" type=\"Plane Mirror\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" auto=\"T\" enabled=\"T\"&gt;40&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" auto=\"T\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"systemMount\" comment=\"standalone\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"premirrorShiftZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha1\" enabled=\"F\"&gt;1&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha2\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"pimpaleAlpha3\" enabled=\"F\"&gt;3&lt;/param&gt;\n    &lt;param id=\"distancePremirrorGrating\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"elementSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.766044443118978&lt;/y&gt;\n      &lt;z&gt;-0.6427876096865393&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.6427876096865393&lt;/y&gt;\n      &lt;z&gt;0.766044443118978&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/RZP/","title":"Reflection Zone Plate (RZP)","text":"<p>Information about RZP</p> <p>Literature:</p> <ul> <li>Rehanek, Jens Konstantin. 2014. Beam Diagnostics and Spectroscopy at X-Ray Free Electron Lasers. https://doi.org/10.17169/refubium-14167.</li> <li>L\u00f6chel, Heike. 2016. Reflection Zone Plates for X-Ray Spectroscopy. https://doi.org/10.17169/refubium-42097.</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/RZP/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory:</p> <ul> <li>Reflectivity Type (see more in chapter Optical Elements)</li> <li>Slope Error</li> <li>World Position</li> <li>Misalignment</li> </ul> <p>RZP:</p> <ul> <li>Fresnel Z Offset</li> <li>Design Alpha Angle</li> <li>Design Beta Angle</li> <li>Design Order Diffraction</li> <li>Design Energy</li> <li>Entrance Arm Length Sag</li> <li>Exit Arm Length Sag</li> <li>Entrance Arm Length Sag</li> <li>Exit Arm Length Mer</li> <li>Order Diffraction</li> <li>Additional Order</li> <li>Curvature Type</li> <li>Long Radius</li> <li>Image Type</li> </ul> <p>Cutout:</p> <ul> <li>Geometrical Shape</li> <li>Total Width</li> <li>Total Length</li> </ul>"},{"location":"Model/BeamlineObjects/OpticalElements/RZP/#rml-object","title":"RML Object","text":"<p>If you want to follow a RZP using an RML File, you'll need an XML Object that contains all the RZP details. The default RZP from RAY-UI is available for use. Just remember, tracing only works if you set up a Light Source first. It's a good idea to add an Imageplane Object at the end for clearer results.</p> <pre><code>  &lt;object name=\"Reflection Zoneplate\" type=\"Reflection Zoneplate\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"gratingMount\" comment=\"constant incidence angle\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" auto=\"T\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"deviationAngle\" enabled=\"F\"&gt;170&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"elementOffsetZType\" comment=\"manual\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"elementOffsetZ\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"meridionalIncidenceBeamDivergence\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"meridionalIncidenceFocusDistance\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"orderDiffraction\" auto=\"T\" enabled=\"T\"&gt;-1&lt;/param&gt;\n    &lt;param id=\"betaDiffraction\" auto=\"T\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"derivationMethod\" comment=\"Formulas\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coefficientsFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"designEnergy\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"designOrderDiffraction\" auto=\"T\" enabled=\"T\"&gt;-1&lt;/param&gt;\n    &lt;param id=\"entranceArmLengthSag\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"entranceArmLengthMer\" enabled=\"T\"&gt;100&lt;/param&gt;\n    &lt;param id=\"designAlphaAngle\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"exitArmLengthSag\" enabled=\"T\"&gt;500&lt;/param&gt;\n    &lt;param id=\"exitArmLengthMer\" enabled=\"T\"&gt;500&lt;/param&gt;\n    &lt;param id=\"curvatureType\" comment=\"planar\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"longRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"shortRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"designType\" comment=\"use Fresnel Center Offset\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"FresnelZOffset\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"designBetaAngle\" enabled=\"F\"&gt;1&lt;/param&gt;\n    &lt;param id=\"imageType\" comment=\"point to point\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"stretchXdirection\" enabled=\"F\"&gt;1&lt;/param&gt;\n    &lt;param id=\"rzpType\" comment=\"elliptical (standard)\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"zDcalc\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"xDcalc\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"Dz\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"Dx\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"refracMethod\" comment=\"2D (new)\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"additionalOrder\" comment=\"off\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lineProfile\" comment=\"unknown\" enabled=\"T\"&gt;3&lt;/param&gt;\n    &lt;param id=\"fullEfficiency\" comment=\"off\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gratingEfficiency\" enabled=\"T\"&gt;0.5&lt;/param&gt;\n    &lt;param id=\"blazeAngle\" enabled=\"F\"&gt;4&lt;/param&gt;\n    &lt;param id=\"aspectAngle\" enabled=\"F\"&gt;90&lt;/param&gt;\n    &lt;param id=\"grooveDepth\" enabled=\"F\"&gt;10&lt;/param&gt;\n    &lt;param id=\"grooveRatio\" enabled=\"F\"&gt;0.65&lt;/param&gt;\n    &lt;param id=\"multilayerFourierCoefficients\" auto=\"T\" enabled=\"F\"&gt;11&lt;/param&gt;\n    &lt;param id=\"multilayerIntegrationSteps\" auto=\"T\" enabled=\"F\"&gt;50&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.99984769515639127&lt;/y&gt;\n      &lt;z&gt;-0.017452406437283512&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.017452406437283512&lt;/y&gt;\n      &lt;z&gt;0.99984769515639127&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/","title":"Slit","text":"<p>The Slit is an optical element that allows users to define a cutout through which light rays pass. You can configure the shape and size of the slit opening, as well as the size and shape of a central beamstop to block part of the light. The Slit element also accounts for Fraunhofer diffraction, producing realistic diffraction patterns when light interacts with the slit, especially in the case of single-slit diffraction.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Cutout: - Opening Shape - Opening Width - Opening Height - Central Beamstop - Total Width Stop - Total Height Stop</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/#fraunhofer-diffraction-rectangular-slits","title":"Fraunhofer Diffraction (Rectangular Slits)","text":"<p>The RAYX simulation software calculates Fraunhofer diffraction for rectangular slits, which impacts the diffraction angle of rays passing through the slit. The diffraction effect is dependent on the slit dimensions and the wavelength of the light. The diffraction pattern produced follows the well-known Fraunhofer single-slit diffraction model, where the intensity of the light depends on the angle and the size of the slit.</p> <p>For a rectangular slit of dimension <code>b</code>, the diffraction angle <code>dAngle</code> is calculated based on the equation:</p> \\[ u = \\frac{\\pi b \\sin(\\theta)}{\\lambda} \\] <p>where: - \\( b \\) is the width or height of the slit - \\( \\theta \\) is the diffraction angle - \\( \\lambda \\) is the wavelength of the light</p> <p>The intensity distribution is proportional to \\( \\left( \\frac{\\sin(u)}{u} \\right)^2 \\).</p> <p>The algorithm ensures that rays with different angles are assigned based on a random distribution, simulating the diffraction pattern as light passes through the slit.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/#circular-apertures-and-zone-plates","title":"Circular Apertures and Zone Plates","text":"<p>In addition to rectangular slit diffraction, the software also supports Bessel diffraction for circular slits and zone plates. For a circular aperture of radius <code>r</code>, the diffraction is modeled using Bessel functions, producing characteristic ring-like diffraction patterns.</p> <p>In this case, the diffraction angle <code>dphi</code> and <code>dpsi</code> are calculated based on the aperture radius and wavelength, simulating the radial symmetry of diffraction patterns from circular openings.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/#rml-object","title":"RML Object","text":"<p>To track a Slit using an RML File, you'll require an XML Object to encompass all the mirror details.</p> <pre><code>  &lt;object name=\"Slit\" type=\"Slit\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;20&lt;/param&gt;\n   &lt;param id=\"totalHeight\" enabled=\"T\"&gt;2&lt;/param&gt;\n   &lt;param id=\"centralBeamstop\" comment=\"none\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidthStop\" enabled=\"F\"&gt;20&lt;/param&gt;\n   &lt;param id=\"totalHeightStop\" enabled=\"F\"&gt;1&lt;/param&gt;\n   &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;10000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;1.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;1.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Slit/#references","title":"References","text":"<p>For further reading on Fraunhofer diffraction, please refer to the Wikipedia page on Fraunhofer Diffraction or standard optics textbooks.</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Grating/","title":"Spherical Grating","text":"<p>TBA </p>"},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Grating/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Sphere: - Radius</p> <p>Grating: - vls parameter - Line Density - Order Of Diffraction</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Grating/#rml-object","title":"RML Object","text":"<p>To track a Spherical Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>  &lt;object name=\"Spherical Grating\" type=\"Spherical Grating\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n   &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n   &lt;param id=\"gratingMount\" comment=\"constant deviation\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"deviationAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n   &lt;param id=\"entranceArmLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"exitArmLength\" auto=\"T\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"radius\" auto=\"T\" enabled=\"T\"&gt;1825.126977351541&lt;/param&gt;\n   &lt;param id=\"designEnergy\" auto=\"T\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"lineDensity\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"orderDiffraction\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"alpha\" auto=\"T\" enabled=\"T\"&gt;5.356547628646595&lt;/param&gt;\n   &lt;param id=\"beta\" auto=\"T\" enabled=\"T\"&gt;-4.643452371353405&lt;/param&gt;\n   &lt;param id=\"lineSpacing\" comment=\"constant\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter3\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter4\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter5\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter6\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"lineProfile\" comment=\"unknown\" enabled=\"T\"&gt;3&lt;/param&gt;\n   &lt;param id=\"gratingEfficiency\" enabled=\"T\"&gt;0.5&lt;/param&gt;\n   &lt;param id=\"blazeAngle\" enabled=\"F\"&gt;4&lt;/param&gt;\n   &lt;param id=\"aspectAngle\" enabled=\"F\"&gt;90&lt;/param&gt;\n   &lt;param id=\"grooveDepth\" enabled=\"F\"&gt;10&lt;/param&gt;\n   &lt;param id=\"grooveRatio\" enabled=\"F\"&gt;0.65&lt;/param&gt;\n   &lt;param id=\"multilayerFourierCoefficients\" auto=\"T\" enabled=\"F\"&gt;11&lt;/param&gt;\n   &lt;param id=\"multilayerIntegrationSteps\" auto=\"T\" enabled=\"F\"&gt;50&lt;/param&gt;\n   &lt;param id=\"reflectivityType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n   &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.3&lt;/param&gt;\n   &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;10000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0933532651278599&lt;/y&gt;\n    &lt;z&gt;-0.9956330488136518&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.9956330488136518&lt;/y&gt;\n    &lt;z&gt;0.0933532651278599&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Mirror/","title":"Sphere Mirror","text":""},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Sphere: - Radius</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Sphere-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Sphere Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>  &lt;object name=\"SphereMirrorDefault\" type=\"Sphere\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"entranceArmLength\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLength\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"radius\" auto=\"T\" enabled=\"T\"&gt;10470.4917875&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"elementSubstrate\" enabled=\"T\"&gt;Cu&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;8.94&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" relative=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.98480775301220802&lt;/y&gt;\n      &lt;z&gt;-0.17364817766693033&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.17364817766693033&lt;/y&gt;\n      &lt;z&gt;0.98480775301220802&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Grating/","title":"Toroid Grating","text":"<p>TBA</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Grating/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Toroid: - Short Radius - Long Radius</p> <p>Grating: - Varied line spaceing parameter  - Line Density - Order Of Diffraction</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Grating/#rml-object","title":"RML Object","text":"<p>To track a Toroid Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>   &lt;object name=\"Toroidal Grating\" type=\"Toroidal Grating\"&gt;\n   &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n   &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n   &lt;param id=\"gratingMount\" comment=\"constant deviation\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"deviationAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n   &lt;param id=\"entranceArmLengthSag\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"exitArmLengthSag\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"entranceArmLengthMer\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"exitArmLengthMer\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"longRadius\" auto=\"T\" enabled=\"T\"&gt;1823.537175159428&lt;/param&gt;\n   &lt;param id=\"shortRadius\" auto=\"T\" enabled=\"T\"&gt;1811.228017099299&lt;/param&gt;\n   &lt;param id=\"designEnergy\" auto=\"T\" enabled=\"T\"&gt;100&lt;/param&gt;\n   &lt;param id=\"lineDensity\" enabled=\"T\"&gt;1000&lt;/param&gt;\n   &lt;param id=\"orderDiffraction\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"alpha\" auto=\"T\" enabled=\"T\"&gt;5.356547628646594&lt;/param&gt;\n   &lt;param id=\"beta\" auto=\"T\" enabled=\"T\"&gt;-4.643452371353406&lt;/param&gt;\n   &lt;param id=\"lineSpacing\" comment=\"constant\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter3\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter4\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter5\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"vlsParameter6\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n   &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"lineProfile\" comment=\"unknown\" enabled=\"T\"&gt;3&lt;/param&gt;\n   &lt;param id=\"gratingEfficiency\" enabled=\"T\"&gt;0.5&lt;/param&gt;\n   &lt;param id=\"blazeAngle\" enabled=\"F\"&gt;4&lt;/param&gt;\n   &lt;param id=\"aspectAngle\" enabled=\"F\"&gt;90&lt;/param&gt;\n   &lt;param id=\"grooveDepth\" enabled=\"F\"&gt;10&lt;/param&gt;\n   &lt;param id=\"grooveRatio\" enabled=\"F\"&gt;0.65&lt;/param&gt;\n   &lt;param id=\"reflectivityType\" comment=\"Derived by Material\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"materialSubstrate\" enabled=\"T\"&gt;Au&lt;/param&gt;\n   &lt;param id=\"roughnessSubstrate\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"T\"&gt;19.3&lt;/param&gt;\n   &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"T\"&gt;0&lt;/param&gt;\n   &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;10000.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;1.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0000000000000000&lt;/y&gt;\n    &lt;z&gt;0.0000000000000000&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.0933532651278599&lt;/y&gt;\n    &lt;z&gt;-0.9956330488136518&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n    &lt;x&gt;0.0000000000000000&lt;/x&gt;\n    &lt;y&gt;0.9956330488136518&lt;/y&gt;\n    &lt;z&gt;0.0933532651278599&lt;/z&gt;\n   &lt;/param&gt;\n   &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n   &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n   &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n   &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n   &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Mirror/","title":"Toroid Mirror","text":"<p>TBA</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Mirror/#tracing-parameter","title":"Tracing Parameter","text":"<p>Mandatory: - Reflectivity Type (see more in chapter Optical Elements) - Slope Error - World Position - Misalignment</p> <p>Toroid: - Short Radius - Long Radius</p> <p>Cutout: - Geometrical Shape - Total Width - Total Length</p>"},{"location":"Model/BeamlineObjects/OpticalElements/Toroid-Mirror/#rml-object","title":"RML Object","text":"<p>To track a Toroid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p> <pre><code>   &lt;object name=\"Toroid\" type=\"Toroid\"&gt;\n    &lt;param id=\"geometricalShape\" comment=\"rectangle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"totalWidth\" enabled=\"T\"&gt;50&lt;/param&gt;\n    &lt;param id=\"totalLength\" enabled=\"T\"&gt;200&lt;/param&gt;\n    &lt;param id=\"grazingIncAngle\" enabled=\"T\"&gt;10&lt;/param&gt;\n    &lt;param id=\"entranceArmLengthSag\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLengthSag\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"entranceArmLengthMer\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"exitArmLengthMer\" enabled=\"T\"&gt;1000&lt;/param&gt;\n    &lt;param id=\"longRadius\" auto=\"T\" enabled=\"T\"&gt;10470.4917875&lt;/param&gt;\n    &lt;param id=\"shortRadius\" auto=\"T\" enabled=\"T\"&gt;315.723959394&lt;/param&gt;\n    &lt;param id=\"distancePreceding\" enabled=\"T\"&gt;10000&lt;/param&gt;\n    &lt;param id=\"azimuthalAngle\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"reflectivityType\" comment=\"100%\" enabled=\"T\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialSubstrate\" enabled=\"F\"&gt;Au&lt;/param&gt;\n    &lt;param id=\"roughnessSubstrate\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densitySubstrate\" auto=\"T\" enabled=\"F\"&gt;19.3&lt;/param&gt;\n    &lt;param id=\"surfaceCoating\" comment=\"Substrate only\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"coatingFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"numberLayer\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"materialCoating1\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating1\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialCoating2\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessCoating2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityCoating2\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"materialTopLayer\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"thicknessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"roughnessTopLayer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"densityTopLayer\" auto=\"T\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"lateralThicknessGradientCoating1\" comment=\"No\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B1\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B2\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B3\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B4\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B5\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B6\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B7\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"gradientC1B8\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"alignmentError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"translationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"translationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationXerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationYerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"rotationZerror\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeError\" comment=\"No\" enabled=\"T\"&gt;1&lt;/param&gt;\n    &lt;param id=\"profileKind\" comment=\"no Profile\" enabled=\"F\"&gt;2&lt;/param&gt;\n    &lt;param id=\"profileFile\" absolute=\"\" enabled=\"F\"&gt;&lt;/param&gt;\n    &lt;param id=\"slopeErrorSag\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"slopeErrorMer\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaX\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"thermalDistortionSigmaZ\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingAmp\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"cylindricalBowingRadius\" enabled=\"F\"&gt;0&lt;/param&gt;\n    &lt;param id=\"worldPosition\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;10000&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldXdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;1&lt;/x&gt;\n      &lt;y&gt;0&lt;/y&gt;\n      &lt;z&gt;0&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldYdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.98480775301220802&lt;/y&gt;\n      &lt;z&gt;-0.17364817766693033&lt;/z&gt;\n    &lt;/param&gt;\n    &lt;param id=\"worldZdirection\" enabled=\"F\"&gt;\n      &lt;x&gt;0&lt;/x&gt;\n      &lt;y&gt;0.17364817766693033&lt;/y&gt;\n      &lt;z&gt;0.98480775301220802&lt;/z&gt;\n    &lt;/param&gt;\n  &lt;/object&gt;\n</code></pre>"},{"location":"RAYX-UI/RAYX-UI/","title":"RAYX-UI","text":""},{"location":"RAYX-UI/RAYX-UI/#code-documentation","title":"Code Documentation","text":"<ul> <li>Triangulation</li> </ul>"},{"location":"RAYX-UI/Triangulation/","title":"2D Triangulation","text":"<p>The triangulation algorithm is based on the algorithm presented in Computational Geometry</p>"},{"location":"RAYX-UI/Triangulation/#initial-polygon-representation","title":"Initial polygon representation","text":"<p>The polygons are represented as a collection of paths for faces and holes. Faces are ordered in counter-clockwise order and holes in clockwise order.</p>"},{"location":"RAYX-UI/Triangulation/#edge-list","title":"Edge list","text":"<p>The edge list a data structure containing all edges of the polygons. The edges are directed. A polygon is represented in counter-clockwise order.</p> <p>Every edge contains: - A reference to the incoming edge - A reference to the outgoing edge - The point of origin</p> <p>The data structure has a split method. This method inserts two new edges and updates some incoming and outgoing references.</p> <p>References before splitting: - v_prev -&gt; v - u_prev -&gt; u</p> <p>References after splitting: - v_prev -&gt; vu -&gt; u - u_prev -&gt; uv -&gt; v</p> <p>Split returns uv and vu.</p> <p>Example:</p> <p></p>"},{"location":"RAYX-UI/Triangulation/#generate-monotone-pieces","title":"Generate monotone pieces","text":"<p>A polygon is monotone if every line in y direction intersects 0 or 2 edges.</p> <p>The algorithm is a sweep line algorithm. The line sweeps from +y to -y. The algorithm requires a binary search tree, a hash map and a priority queue. The BST contains every edge that is currently intersecting the sweep line sorted by x position of the intersection. The hash map maps downward facing edges intersecting the sweep line to edges used for splitting.</p> <ol> <li>Add faces and holes to the edge list.</li> <li>Classify edge origins as Regular, Start, End, Split or Merge vertices.</li> <li>Add the edges to a priority queue. Priotity relation: <code>y1 &gt; y2 || (y1 == y2 &amp;&amp; x1 &lt; x2)</code></li> <li>Initialize the BST and HM as empty.</li> <li>Process entries of the priority queue in order.</li> </ol>"},{"location":"RAYX-UI/Triangulation/#classification","title":"Classification","text":"<p>Start:</p> <p>Polygon begin</p> <p></p> <p>End:</p> <p>Polygon end</p> <p></p> <p>Regular:</p> <p>Standard edge</p> <p></p> <p>Merge:</p> <p>Merge two monotone polygons in one</p> <p></p> <p>Split:</p> <p>Split polygon in two monotone pieces</p> <p></p>"},{"location":"RAYX-UI/Triangulation/#processing-of-a-vertexedge","title":"Processing of a Vertex/Edge","text":"<p><code>le*</code> denotes an edge in the BST and <code>helper[le*]</code> the corresponding edge in the HM. The left part of each diagram is the state before processing and the right part the state after processing. The dotted line is the current sweep line. The BST and HM can contain more entries than shown. These entries wont be modified.</p>"},{"location":"RAYX-UI/Triangulation/#start","title":"Start","text":""},{"location":"RAYX-UI/Triangulation/#end","title":"End","text":"<p>Origin of helper is a merge vertex:</p> <p></p> <p>Otherwise no new edges will be added.</p>"},{"location":"RAYX-UI/Triangulation/#split","title":"Split","text":"<p>This works for every vertex type of the helpers origin, in this example the helpers origin is a merge vertex:</p> <p></p>"},{"location":"RAYX-UI/Triangulation/#merge","title":"Merge","text":"<p>New edges are only added if a helpers origin is a merge vertex. In case le1s helper is not a merge vertex, the helper of le is set to the outgoing edge of the currently processed vertex.</p> <p></p>"},{"location":"RAYX-UI/Triangulation/#regular","title":"Regular","text":""},{"location":"RAYX-UI/Triangulation/#left","title":"Left","text":"<p>Origin of helper is merge vertex.</p> <p></p> <p>Otherwise no new edge will be added.</p>"},{"location":"RAYX-UI/Triangulation/#right","title":"Right","text":"<p>Origin of helper is merge vertex.</p> <p></p> <p>Otherwise no new edge will be added. And the helper of le is the outgoing edge of the currently processed vertex.</p>"},{"location":"RAYX-UI/Triangulation/#output","title":"Output","text":"<p>The newly added edges are colored blue.</p> <p></p>"},{"location":"RAYX-UI/Triangulation/#triangulation-of-monotone-polygon","title":"Triangulation of monotone polygon","text":"<p>The algorithm requires a stack containing all not yet triangulated edges.</p> <p>The triangulation algorithm has the following steps:</p> <ol> <li>Annotate each edge origin of the polygon with either left or right.</li> <li>Initialize the stack and push the first 2 edges. </li> <li>Process vertices (except the first 2) in decreasing y order.</li> </ol>"},{"location":"RAYX-UI/Triangulation/#processing","title":"Processing","text":"<p>The green edge is the current edge. The blue edges are on the stack. (ordered by y coordinate)</p>"},{"location":"RAYX-UI/Triangulation/#current-edge-origin-is-on-the-left","title":"Current edge origin is on the left","text":""},{"location":"RAYX-UI/Triangulation/#edge-on-top-of-the-stack-is-on-the-left","title":"Edge on top of the stack is on the left","text":""},{"location":"RAYX-UI/Triangulation/#edge-on-top-of-the-stack-is-on-the-right","title":"Edge on top of the stack is on the right","text":""},{"location":"RAYX-UI/Triangulation/#current-edge-origin-is-on-the-right","title":"Current edge origin is on the right","text":""},{"location":"RAYX-UI/Triangulation/#edge-on-top-of-the-stack-is-on-the-right_1","title":"Edge on top of the stack is on the right","text":""},{"location":"RAYX-UI/Triangulation/#edge-on-top-of-the-stack-is-on-the","title":"Edge on top of the stack is on the","text":""},{"location":"Tools/Code-Coverage/","title":"What is Code Coverage:","text":"<p>Analyzing your code Coverage is a necessary step in devloping complex big projects.</p> <p>Getting the code's coverage is simply generating a summary of how much a piece of code is executed and \"covered\".</p> <p>Code Coverage offers line, function, and branch analysis.</p> <p>Generally, the most reasonable method is to check how much code your Testsuites cover.</p>"},{"location":"Tools/Code-Coverage/#requirements","title":"Requirements","text":"<p>Please Note: This has only been tested on UNIX System (Ubuntu) </p> <p>Code Coverage is supported by GNU GCC and LLVM. Make sure that one of these build tools is installed. Gcov, lcov and genhtml are packages that are also needed. For more information, you can check the usage of gcov (GCC) here.</p> <p>You can also use gcovr as an alternative to gcov. </p>"},{"location":"Tools/Code-Coverage/#how-it-works","title":"How it works","text":"<p>Code Coverage only works if the main function returns 0. (The Test Suite returns 0 if all testcases pass). </p> <p>The test suite should run only in DEBUG Mode and with all optimizations turned off \"-O0\" for Coverage. Warnings will pop if not.</p> <p>With the correct gcov and -fdump added to <code>CXX_COMPILER_FLAGS</code>, running the Testsuite will generate <code>*.gcno</code> and <code>*.gch</code> files meant for lcov. The file generation and flags are handled by a CMAKE submodule. An <code>*.info</code> file is then created and transformed afterwards to interactable <code>index.html</code> page on the web browser. Configuration information on the CMAKE Output window show up as the submodule defaults to verbose.</p>"},{"location":"Tools/Code-Coverage/#how-to-enable","title":"How to enable","text":""},{"location":"Tools/Code-Coverage/#visual-stuido-code","title":"Visual Stuido Code","text":"<ul> <li>Uncomment the code under <code>#CodeCoverage</code> in the CMakeLists.txt on the project's root directory, to set the option <code>BUILD_WITH_GCOV</code>.</li> <li>(Optional) You can also build with <code>DBUILD_WITH_GCOV</code> instead of last step.</li> <li>Make sure to choose RAYX_tst as target in Debug Mode.</li> <li>Once ran, <code>cd build</code> and run: </li> </ul> <p><code>lcov --capture --directory . --output-file coverage.info</code></p> <p><code>genhtml coverage.info --output-directory coverage</code></p> <ul> <li>A new file in <code>build/</code> called coverage, with and <code>index.html</code> can be opened to see Code Coverage.</li> </ul>"},{"location":"Tools/Code-Coverage/#jetbrains-clion","title":"JetBrains Clion","text":"<ul> <li>Chose the Google Test \"RAYX_tst | Debug-Coverage\" as configuration, if first time doing this you should only see \"RAYX_tst | Debug \" as option, chose that instead.</li> <li>Near the Run button, you should see \"Run \"RAYX_tst\" with Coverage\".</li> <li>If configration is missing, let CLion handle the creation of a new Cmake configuration.</li> <li>Once all testsuites are successfuly ran, a dialog box  of the Line, Branch coverages pops out. Notice also the colors in the editor.</li> </ul>"},{"location":"Tools/Debugging/","title":"Debugging","text":"<p>Rayx uses a number of languages but mainly C++ and GLSL. </p>"},{"location":"Tools/Debugging/#debugging-the-applications-c","title":"Debugging the application's C++","text":"<p>If you are using VS Code, you may create a new Debugging Setting to launch rayx through gdb. More here</p> <p>Once the setting file (launch.json) is ready, you can change and add arguments for VSCode/gdb to parse.  - set \"program\" : \"\\({workspaceFolder}/build/bin/TerminalApp\" (For TerminalApp) - set \"args\" : [arg1,arg2 etc.] (keep arguments between \" \" ) - set \"cwd\" : \"\\)/build/bin/\"</p> <p>If you are familiar with gdb, add more commands in setupCommands, eg. Disassembly Flavor for Intel </p>"},{"location":"Tools/Debugging/#debugging-the-applications-vulkan-and-glsl","title":"Debugging the application's Vulkan and GLSL","text":"<p>The shader language (GLSL) does not offer live debugging and stepping with gdb or similar. If you run the CPU Tracer then you can step through the code as it was compiled into C code, since it's only running on the CPU. However when using Vulkan a few more steps needs attention. </p> <p>Vulkan offers a debug extension layer that can be activated with the combination of vkconfig to launch the application in debug mode. </p> <ol> <li> <p>We need <code>#extension GL_EXT_debug_printf : enable</code> in the shader file.</p> </li> <li> <p>We also need to add <code>VK_KHR_shader_non_semantic_info</code> as in extension in the Vulkan Instance.</p> </li> <li> <p>Launch the application with vkconfig and chose the Debug Printf Preset in VK_LAYER_KHRONOS_validation. (Vkconfig should be packaged with Vulkan-SDK)</p> </li> <li> <p>Make sure to increase Printf buffer size under Debug Printf if you get a Validation Layer Warning.</p> </li> </ol> <p></p>"},{"location":"Tools/How-to-use-Doxygen/","title":"How to use Doxygen","text":""},{"location":"Tools/How-to-use-Doxygen/#prerequisites","title":"Prerequisites","text":"<ul> <li>Doxygen: http://www.doxygen.nl/download.html#srcbin</li> <li>(GraphViz: https://graphviz.gitlab.io/download/) \\(\\leftarrow\\) at the moment not needed</li> </ul> <p>Note GraphViz installation: On windows you can install graphviz via MSYS2 since you might already have it to build the project. Simply call: pacman -S mingw-w64-x86_64-graphviz in the MSYS2 commandline window. The DOT_PATH muust then be set to {MSYS2}/mingw64/bin</p>"},{"location":"Tools/How-to-use-Doxygen/#configuration","title":"Configuration","text":"<ol> <li>Open the Doxyfile in Intern/rayx-core/doc/ with Doxywizard</li> <li>Under Wizard-&gt;Diagrams check \"Use dot tool from the GraphViz package\"</li> <li>Change the DOT_PATH in \"Expert \\(\\rightarrow\\) Dot\" to the bin-directory in your GraphViz-Folder (where you installed it). This is usually the doxygen/bin folder.</li> <li>Click on the \"Run\"-tab and click \"Run doxygen\" (this will take a while, depending on your cpu performance)</li> <li>After completion click \"Show HTML output\" in the Doxywizard or open the Index.html in Intern/rayx-core/doc/html/</li> </ol>"},{"location":"Tools/How-to-use-Doxygen/#class-diagram","title":"Class Diagram","text":"<p>A generated Class Diagram can be found under \"Classes-&gt;Class Hierarchy\"</p>"},{"location":"Tools/How-to-use-Doxygen/#generating-documentation-with-gpt-4-35-not-recommended","title":"Generating documentation with GPT-4 (3.5 not recommended)","text":"<p>Use this prompt and replace the header and cpp code in the lower part with your code. Note: The first code is example code for ChatGPT so it knows the style. Do not replace it. Just replace the lower code after \"Create a documentation for this header file:\" and \"Create a documentation for this cpp file:\"</p>"},{"location":"Tools/How-to-use-Doxygen/#important","title":"Important:","text":"<p>Read and check all generated content. ChatGPT can easily make errors and assumptions. It is only a tool to save time writing text. The information needs to be approved by the developer.</p> <p>Prompt:</p> <pre><code>I need to create a doxygen documentation for some code I wrote. You will help me with that. The comments in the header file should include the information what the function does/is for. In the cpp file, it's how the function is implemented. This is a good example how it should be:\n\n.h\n/**\n * @brief Triangulates optical elements for rendering.\n * @param elements A vector of optical elements to be triangulated.\n * @param useMarchinCubes Flag to determine if Marching Cubes triangulation should be used.\n * @return A vector of RenderObject, which are the triangulated version of the input elements.\n */\nstd::vector&lt;RenderObject&gt; triangulateObjects(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements, bool useMarchinCubes = false);\n\n/**\n * @brief Generates visual representations of rays based on bundle history and optical elements.\n * @param bundleHist RAYX-Core type, providing details of ray interactions in the beamline.\n * @param elements A vector of optical elements used for coordinate conversions.\n * @return A vector of lines, which visually represents the paths of rays in the beamline.\n */\nstd::vector&lt;Line&gt; getRays(const RAYX::BundleHistory&amp; bundleHist, const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements);\n\n.cpp\n/**\n * This function processes the BundleHistory and determines the ray's path in the beamline.\n * Depending on the event type associated with the ray, the function produces visual lines that represent\n * ray segments, colored based on the event type.\n */\nstd::vector&lt;Line&gt; getRays(const RAYX::BundleHistory&amp; bundleHist, const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements) {\n    std::vector&lt;Line&gt; rays;\n\n    for (const auto&amp; rayHist : bundleHist) {\n        glm::vec3 rayLastPos = {0.0f, 0.0f, 0.0f};\n        for (const auto&amp; event : rayHist) {\n            if (event.m_eventType == ETYPE_JUST_HIT_ELEM || event.m_eventType == ETYPE_ABSORBED) {\n                // Events where rays hit objects are in element coordinates\n                // We need to convert them to world coordinates\n                glm::vec4 worldPos = elements[(size_t)event.m_lastElement].m_element.m_outTrans * glm::vec4(event.m_position, 1.0f);\n\n                Vertex origin = {{rayLastPos.x, rayLastPos.y, rayLastPos.z, 1.0f}, YELLOW};\n                Vertex point = (event.m_eventType == ETYPE_JUST_HIT_ELEM) ? Vertex(worldPos, ORANGE) : Vertex(worldPos, RED);\n\n                rays.push_back(Line(origin, point));\n                rayLastPos = point.pos;\n            } else if (event.m_eventType == ETYPE_FLY_OFF) {\n                // Fly off events are in world coordinates\n                // The origin here is the position of the event\n                // The point is defined by the direction of the ray (default length)\n\n                glm::vec4 eventPos = glm::vec4(event.m_position, 1.0f);\n                glm::vec4 eventDir = glm::vec4(event.m_direction, 0.0f);\n                glm::vec4 pointPos = eventPos + eventDir * 1000.0f;\n\n                Vertex origin = {eventPos, GREY};\n                Vertex point = {pointPos, GREY};\n\n                rays.push_back(Line(origin, point));\n            }\n        }\n    }\n\n    return rays;\n}\n\nCreate a documentation for this header file:\n\n// Marching Cubes\nstd::vector&lt;RenderObject&gt; marchingCubeTriangulation(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements);\nstd::vector&lt;Triangle&gt; trianglesFromQuadric(const double* quadric, Cutout cutout);  // TODO: make nicer\n\nglm::vec3 getPositionAtCorner(int cornerIndex);\nVertex interpolateVertex(int edgeIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY, int offsetZ,\n                         glm::vec3 scale);\ndouble evaluateQuadricAtPosition(const double surface[16], const glm::vec4&amp; pos);\nint determineMarchingCubesCase(const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int x, int y, int z);\nstd::vector&lt;Triangle&gt; lookupTrianglesForCase(int caseIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY,\n                                             int offsetZ, glm::vec3 scale);\nVertex getVertexFromEdge(int edgeIndex);\ndouble getScalarValueAtCorner(int x, int y, int z, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE]);\n\n// Marching Cubes\nconst int edgeTable[256] = {...}\nconst int triTable[256][16] = {...}\n\nCreate a documentation for this cpp file:\n#include \"MarchingCubes.h\"\n\n#include \"Colors.h\"\n#include \"Debug/Debug.h\"\n\nnamespace RAYX {\nnamespace CPU_TRACER {\nbool RAYX_API inCutout(Cutout cutout, double x1, double x2);\n}  // namespace CPU_TRACER\n}  // namespace RAYX\n\nstd::vector&lt;RenderObject&gt; marchingCubeTriangulation(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements) {\n    std::vector&lt;RenderObject&gt; objects;\n\n    for (RAYX::OpticalElement element : elements) {\n        auto quadric = element.m_element.m_surface.m_params;\n        std::vector&lt;Triangle&gt; triangles = trianglesFromQuadric(quadric, element.m_element.m_cutout);\n        RenderObject object(glm::mat4(element.m_element.m_outTrans));\n        for (Triangle triangle : triangles) {\n            object.addTriangle(triangle);\n        }\n        objects.push_back(object);\n    }\n\n    return objects;\n}\n\nstd::vector&lt;Triangle&gt; trianglesFromQuadric(const double* quadric, Cutout cutout) {\n    // Define the size and resolution of the grid\n    double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE];\n    if (cutout.m_type == CTYPE_UNLIMITED) {\n        RAYX_ERR &lt;&lt; \"Unlimited cutout not supported by marching cubes\";\n    }\n    RAYX_LOG &lt;&lt; \"cutout: \" &lt;&lt; cutout.m_params[0] &lt;&lt; \", \" &lt;&lt; cutout.m_params[1];\n\n    const double SCALE = 1;  // Define your desired scaling factor here\n\n    const glm::vec3 bounding_box = glm::vec3(cutout.m_params[0], cutout.m_params[1], 1.0f);\n    const glm::vec3 scale = glm::vec3(cutout.m_params[0] * SCALE / GRIDSIZE, SCALE * 1.0f, cutout.m_params[1] * SCALE / GRIDSIZE);\n\n    // 1. Sample the 3D space\n    for (int x = 0; x &lt; GRIDSIZE; x++) {\n        for (int y = 0; y &lt; GRIDSIZE; y++) {\n            for (int z = 0; z &lt; GRIDSIZE; z++) {\n                // Convert grid coordinate to centered &amp; scaled space coordinate\n\n                double realX = ((double(x) / GRIDSIZE) - 0.5) * bounding_box.x;\n                double realY = ((double(y) / GRIDSIZE) - 0.5) * bounding_box.y;\n                double realZ = ((double(z) / GRIDSIZE) - 0.5) * bounding_box.z;\n\n                glm::vec4 pos(realX, realY, realZ, 1);\n                double value = evaluateQuadricAtPosition(quadric, pos);\n                scalarGrid[x][y][z] = value;\n            }\n        }\n    }\n\n    // 2. March through each voxel\n    std::vector&lt;Triangle&gt; triangles;\n    for (int x = 0; x &lt; GRIDSIZE - 1; x++) {\n        for (int y = 0; y &lt; GRIDSIZE - 1; y++) {\n            for (int z = 0; z &lt; GRIDSIZE - 1; z++) {\n                double realX = ((double(x) / GRIDSIZE) - 0.5) * bounding_box.x;\n                double realZ = ((double(z) / GRIDSIZE) - 0.5) * bounding_box.y;\n                if (RAYX::CPU_TRACER::inCutout(cutout, realX, realZ)) {\n                    int caseIndex = determineMarchingCubesCase(scalarGrid, x, y, z);\n                    std::vector&lt;Triangle&gt; voxelTriangles = lookupTrianglesForCase(caseIndex, scalarGrid, x, y, z, scale);\n                    triangles.insert(triangles.end(), voxelTriangles.begin(), voxelTriangles.end());\n                }\n            }\n        }\n    }\n\n    return triangles;\n}\n\ndouble evaluateQuadricAtPosition(const double surface[16], const glm::vec4&amp; pos) {\n    double icurv = surface[0];\n    double a11 = surface[1];\n    double a12 = surface[2];\n    double a13 = surface[3];\n    double a14 = surface[4];\n    double a22 = surface[5];\n    double a23 = surface[6];\n    double a24 = surface[7];\n    double a33 = surface[8];\n    double a34 = surface[9];\n    double a44 = surface[10];\n    double result = a11 * pos.x * pos.x + a22 * pos.y * pos.y + a33 * pos.z * pos.z + a12 * pos.x * pos.y + a13 * pos.x * pos.z +\n                    a23 * pos.y * pos.z + a14 * pos.x + a24 * pos.y + a34 * pos.z + a44;\n\n    return result;\n}\n\nint determineMarchingCubesCase(const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int x, int y, int z) {\n    // Based on the scalar values at the voxel corners, determine the index for the lookup tables.\n    int cubeIndex = 0;\n\n    auto test = scalarGrid[x][y][z];\n    if (scalarGrid[x][y][z] &lt; 0) cubeIndex |= 1;\n    auto test2 = scalarGrid[x + 1][y][z];\n    if (scalarGrid[x + 1][y][z] &lt; 0) cubeIndex |= 2;\n    if (scalarGrid[x + 1][y][z + 1] &lt; 0) cubeIndex |= 4;\n    if (scalarGrid[x][y][z + 1] &lt; 0) cubeIndex |= 8;\n    if (scalarGrid[x][y + 1][z] &lt; 0) cubeIndex |= 16;\n    if (scalarGrid[x + 1][y + 1][z] &lt; 0) cubeIndex |= 32;\n    if (scalarGrid[x + 1][y + 1][z + 1] &lt; 0) cubeIndex |= 64;\n    if (scalarGrid[x][y + 1][z + 1] &lt; 0) cubeIndex |= 128;\n\n    return cubeIndex;\n}\n\nstd::vector&lt;Triangle&gt; lookupTrianglesForCase(int caseIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY,\n                                             int offsetZ, glm::vec3 scale) {\n    // Using the triTable to generate the triangles for the voxel.\n\n    std::vector&lt;Triangle&gt; triangles;\n\n    // triTable[caseIndex] provides the edges to be connected for the triangles.\n    // Every 3 indices in the table make up a triangle.\n    for (int i = 0; triTable[caseIndex][i] != -1; i += 3) {\n        Triangle triangle;\n\n        // Convert edge indices to vertices\n        triangle.v1 = interpolateVertex(triTable[caseIndex][i], scalarGrid, offsetX, offsetY, offsetZ, scale);\n        triangle.v2 = interpolateVertex(triTable[caseIndex][i + 1], scalarGrid, offsetX, offsetY, offsetZ, scale);\n        triangle.v3 = interpolateVertex(triTable[caseIndex][i + 2], scalarGrid, offsetX, offsetY, offsetZ, scale);\n        triangle.v1.color = DARKER_BLUE;\n        triangle.v2.color = BLUE;\n        triangle.v3.color = LIGHTER_BLUE;\n\n        triangles.push_back(triangle);\n    }\n\n    return triangles;\n}\n\nglm::vec3 getPositionAtCorner(int cornerIndex) {\n    glm::vec3 cornerPositions[8] = {\n        glm::vec3(0, 0, 0),  // 0\n        glm::vec3(1, 0, 0),  // 1\n        glm::vec3(1, 0, 1),  // 2\n        glm::vec3(0, 0, 1),  // 3\n        glm::vec3(0, 1, 0),  // 4\n        glm::vec3(1, 1, 0),  // 5\n        glm::vec3(1, 1, 1),  // 6\n        glm::vec3(0, 1, 1)   // 7\n    };\n    // Check for valid index\n    if (cornerIndex &lt; 0 || cornerIndex &gt;= 8) {\n        throw std::out_of_range(\"Invalid corner index\");\n    }\n    return cornerPositions[cornerIndex];\n}\nVertex interpolateVertex(int edgeIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY, int offsetZ,\n                         glm::vec3 scale) {\n    int edgeToVertex[12][2] = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {4, 5}, {5, 6}, {6, 7}, {7, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}};\n\n    // Define the corner-to-voxel mapping\n    int cornerToVoxel[8][3] = {{0, 0, 0}, {1, 0, 0}, {1, 0, 1}, {0, 0, 1}, {0, 1, 0}, {1, 1, 0}, {1, 1, 1}, {0, 1, 1}};\n\n    int v0Index = edgeToVertex[edgeIndex][0];\n    int v1Index = edgeToVertex[edgeIndex][1];\n\n    double value0 = getScalarValueAtCorner(cornerToVoxel[v0Index][0] + offsetX, cornerToVoxel[v0Index][1] + offsetY,\n                                           cornerToVoxel[v0Index][2] + offsetZ, scalarGrid);\n    double value1 = getScalarValueAtCorner(cornerToVoxel[v1Index][0] + offsetX, cornerToVoxel[v1Index][1] + offsetY,\n                                           cornerToVoxel[v1Index][2] + offsetZ, scalarGrid);\n    // Check for divide by zero\n\n    double t;\n    if (fabs(value1 - value0) &lt; 1e-6) {\n        t = 0.5;  // or choose a reasonable default\n        RAYX_LOG &lt;&lt; \"Divide by zero\";\n    } else {\n        t = (0 - value0) / (value1 - value0);\n    }\n    double move = (GRIDSIZE / 2.0);\n    Vertex v;\n    v.pos = glm::vec4((glm::mix(getPositionAtCorner(v0Index), getPositionAtCorner(v1Index), t) + glm::vec3(offsetX, offsetY, offsetZ) -\n                       glm::vec3(move, move, move)) *\n                          scale,\n                      1.0f);\n\n    return v;\n}\n\ndouble getScalarValueAtCorner(int x, int y, int z, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE]) {\n    if (x &lt; 0 || x &gt;= GRIDSIZE || y &lt; 0 || y &gt;= GRIDSIZE || z &lt; 0 || z &gt;= GRIDSIZE) {\n        throw std::out_of_range(\"Invalid corner index\");\n    }\n    return scalarGrid[x][y][z];\n}\n</code></pre>"},{"location":"Tools/How-to-use-our-formatter/","title":"How to use our formatter","text":"<p>In RAYX we decided on using a formatter to keep our code clean and organized. Here you can read how to use it.</p>"},{"location":"Tools/How-to-use-our-formatter/#general","title":"General","text":"<p>We use clang-format for this purpose. The style is defined in the .clang-format file in the project root. As you can see in the file, our style is based on the Google C++ style. Remember: the formatter just completes our style guide and doesn't replace it.</p>"},{"location":"Tools/How-to-use-our-formatter/#visual-studio-code","title":"Visual Studio Code","text":"<p>If you are using Visual Studio Code you can use the C/C++ extension for formatting. It includes the clang-format binary so you just need to change a few settings to configure it correctly. You can see the changes (highlighted in red) in the following screenshots:</p> <p></p> <p>The following settings control, when the formatting should happen. This is up to you as long as the commited code is formatted.</p> <p></p>"},{"location":"Tools/How-to-use-our-formatter/#using-format-all-files-in-workspace","title":"Using Format All Files in Workspace","text":"<p>To format all the workspace at once, you can use the following Visual Studio Code's Extension.</p> <p>In your settings .json file, add the lines to go through the correct directories and only format C++ files:</p> <pre><code>    \"formatAll.includeFileExtensions\": [\n        \".cpp\",\n        \".h\"\n    ],\n    \"formatAll.excludeFolders\": [\n        \"build\",\n        \"Extern\",\n    ], \n</code></pre> <p>WARNING: Using this extension can take up some time, you'll see all targeted files opening in new tabs. Grab a cup of coffee and let it do the trick :)</p>"},{"location":"Tools/How-to-use-our-formatter/#vim-integration","title":"Vim Integration","text":"<p>ClangFormat \u2014 Clang 13 documentation (llvm.org)</p>"},{"location":"Tools/RAYX-Profiling/","title":"Rayx Profiling","text":"<p>Here you can find an overview of the profiling tools used in rayx. Further reading can be done in the code (see Instrumentor.h file in \"Debug\"-folder).</p> <p>The code for this profiler, was taken from a tutorial by TheCherno on Youtube.</p>"},{"location":"Tools/RAYX-Profiling/#usage","title":"Usage","text":"<p>The Profiling used in RAYX is a simple json export of the time each profiled function took. If you want to add profiling to a function, simply add:</p> <p><code>RAYX_PROFILE_FUNCTION;</code></p> <p>at the beginning of the function. </p> <p>For profiling specific scopes, you can use <code>RAYX_PROFILE_SCOPE</code>, which takes in a name for the scoped timer. </p>"},{"location":"Tools/RAYX-Profiling/#profiled-data","title":"Profiled Data","text":"<p>The data will be output to the directory, the executable was started in. You can use the tracing functionality of any chromium based browser to read the data.</p> <p>For example, use the URL \"chrome://tracing\" for the Chrome browser.</p>"},{"location":"Tools/RAYX-Profiling/#sessions","title":"Sessions","text":"<p>The profiling can happen in multiple sessions. You can't have to sessions running at the same time though. This is functionality is mainly supposed to give the option to separate data for different parts of the program. </p> <p>An example would be seperating measurements into startup, runtime, shutdown. </p> <p>The Macros used to create and end sessions:</p> <ul> <li><code>RAYX_PROFILE_BEGIN_SESSION</code></li> <li><code>RAYX_PROFILE_END_SESSION</code> </li> </ul>"},{"location":"Tools/Testing/","title":"Testing in RAYX","text":"<p>There are several kinds of tests: </p>"},{"location":"Tools/Testing/#testing-c-code","title":"Testing C++ Code","text":"<p>testing only c++ code and not using the shader, to check if parameters of optical elements are calculated correctly</p> <p>check especially if the values that are derived from given user parameters and given to the shader are correct. These include the surface Parameters, the object parameters, the element parameters and the world to element and element to world coordinate transformation matrices, each of which are stored in an 16 element value array. </p>"},{"location":"Tools/Testing/#testing-shader-code-test_shadercpp","title":"Testing Shader Code (test_shader.cpp)","text":"<p>The testing suite \"Tracer\" contains unit tests that check if the individual functions in the shader code are behaving as expected. As the functions that are tested are on the shader and in our current framework the only values that can be moved to the shader are mainly the Ray and Optical Element buffers, we cannot just call the functions with the required input values.  Instead we first store the test values in Rays on the C++ side and retrieve them from the Rays on the shader side. Then the test can be executed on the shader and the results are stored again in the Ray buffer (outputRays). Back on the C++ side this can then be compared with the expected values. </p>"},{"location":"Tools/Testing/#example-testing-the-refraction-function","title":"Example: Testing the refraction function","text":"<p>The refraction function on the shader calculates the direction and weight of the refracted ray from the direction of the incoming ray, the normal at the intersection and the line density. The input to the test should therefore be:</p> <ul> <li>dvec3 direction</li> <li>dvec3 normal</li> <li>double lineDensity</li> <li>double weight</li> </ul> <p>The output and therefore the values to verify are:</p> <ul> <li>dvec3 direction_out</li> <li>double weight_out</li> </ul> <p>after the refraction</p> <p>To move the test data to the shader and retrieve the results after applying the function we use the Ray buffer. Each test case is encoded in one Ray and we can add as many test cases as we want to the ray buffer. A ray consists of:</p> <ul> <li>dvec3 position</li> <li>dvec3 direction</li> <li>double energy</li> <li>double weight</li> <li>dvec4 stokes</li> <li>double order</li> <li>double pathLength</li> <li>double lastElement</li> <li>double extra Parameter</li> </ul> <p>We can for example encode the test values for the refraction test as:</p> <ul> <li>dvec position \\(\\leftarrow\\) normal</li> <li>dvec direction \\(\\leftarrow\\) direction</li> <li>double energy \\(\\leftarrow\\) lineDensity</li> <li>double weight \\(\\leftarrow\\) weight</li> <li>others \\(\\leftarrow\\) 0</li> </ul> <p>For this, we can use the function \"addTestSetting\" that receives the test values in the correct order, creates a ray and adds it to a given ray vector which is in this case the one that will be transferred to the shader (<code>std::vector &lt;RAYX::Ray&gt; testValues</code>). To be able to verify the result that we will later retrieve from the shader, we need to store also the expected direction_out and weight_out. To make the comparison later easier we also store these in a Ray that corresponds to the test case and add it to <code>std::vector&lt;RAYX::Ray&gt; correct</code> using for example the following encoding:</p> <ul> <li>dvec position \\(\\leftarrow\\) (0,0,0)</li> <li>dvec direction \\(\\leftarrow\\) direction_expected</li> <li>double energy \\(\\leftarrow\\) 0</li> <li>double weight \\(\\leftarrow\\) weight_expected</li> <li>others \\(\\leftarrow\\) 0</li> </ul> <p>Now we have in both vectors one Ray for each test case, where testValues contains the values that we move to the shader and correct contains those that we expect to get back. Now, we can move testValues as the Ray buffer to the shader.</p> <p>Then, on the shader side we need to make sure that the test values are \"unpacked\" correctly from the ray buffer. We can execute the function and store the updated direction and weight in the output ray buffer in the same format as they are stored in correct on the C++ side which is:</p> <ul> <li>dvec position \\(\\leftarrow\\) (0,0,0)</li> <li>dvec direction \\(\\leftarrow\\) direction_out</li> <li>double energy \\(\\leftarrow\\) 0</li> <li>double weight \\(\\leftarrow\\) weight_out</li> <li>others \\(\\leftarrow\\) 0</li> </ul> <p>These Rays are returned to the C++ test code as outputRays where the can be compared with <code>compareFromCorrect(correct, outputRays, tolerance);</code> for a given tolerance.</p> <p>For other functions, like the approximation of sinus for example, we do not necessarily need the correct vector but we can simply apply the function sin() to the testValues and compare them directly with:</p> <pre><code>auto sinfun = fn&lt;double, double&gt;([](double x) { return sin(x); });\ncompareFromFunction(sinfun, testValues, outputRays, tolerance);\n</code></pre> <p>If a test has more test values than a ray has paramters, one could use the opticalElement buffer and add e.g. one opticalElement for each test case.</p> <p>To make things even more complicated, we also need to have an id for each test to distinguish on the shader side which test is run and how the rays should be interpreted. The id is set in the surfaceParams of an optical Element. Because we want to have only one main function on the shader we also have to distinguish between a test case and a normal run of a beamline. This is achieved by setting the id to 0 if it is a beamline and to the test id otherwise (there is no test with id=0).</p>"},{"location":"Tools/Testing/#testing-beamlines-test_shadercpp","title":"Testing Beamlines (test_shader.cpp)","text":"<p>Tests from the testing suite opticalElements read a beamline from a given rml file, run the tracer on it and writes the returned rays to a csv file with the same name as the rml file.  If the beamlines give deterministic results, we can compare them with the output of RAY-UI using the test.py file. Therefore it is necessary to export the traced data from the same beamline traced in RAY-UI. Moreover, the beamline needs to end with an image plane because of the different coordinate systems that are used (Ray coodinates vs world coordinates).</p>"},{"location":"Tools/Tools/","title":"Tools","text":"<p>In this section, you can read up on all the tools used to develop RAYX. </p>"},{"location":"Vulkan/Vulkan-Beyond/","title":"Vulkan one stage Compute Pipeline and beyond... A Vulkan Case Study","text":""},{"location":"Vulkan/Vulkan-Beyond/#note","title":"Note","text":"<p>Please note that this page has been written from a Vulkan beginner's perspective. All information and facts are bound to change and tend to be misleading at times.</p>"},{"location":"Vulkan/Vulkan-Beyond/#introduction","title":"Introduction","text":"<p>We have followed an extensive research on RAYX Execution Model on the GPU side and found plenty of rabbit holes and possible bottlenecks that might lead to future misbehaviours or loss in performance. In this blog-like post, we explain some of the mentioned issues and possible solutions to overcome them. When needed, this post can be a starting point to a code refraction in RAYX.</p>"},{"location":"Vulkan/Vulkan-Beyond/#what-is-vulkan","title":"What is Vulkan?","text":"<p>The GPU is a massive die on Chip that has plenty of processing cores (Similar to a CPU Core but only with very basic Arithmetic Operations FP/INT32). The GPU excels in SIMD (Single Instrct. Multiple Data) operations. It is basically a huge parallel machine that tries to execute the same operation (Pixel coloring, coordinate calculation etc.) on a wide range of data. For this purpose, GPUs are used in a more abstract field other than simply \"graphics\"; General Purpose Compute on GPU (GPGPU), which is mainly what RAYX on Vulkan relies on. Vulkan? WHO?</p> <p>Nvidia and AMD are the main GPU manufacturers. As both GPU architectures slightly differ and Nvidia ... isn't a fan of open-source... we decided to use an All-in-One compatible tool to talk to the GPU. Enter Vulkan. A \"new\" API used to control the GPU for all (Not really, we'll talk about this later) purposes developed to compete against OpenGL and alike. But most of all, open-source! Vulkan is increasingly gaining popularity and is the new state of the art for developing GPU Solutions. However it is the most NOT beginner-friendly API that you can learn. Vulkan is created to give the user the uttermost control over hardware at the price of complexity and low-level execution. It can be very fast and performant but to reach that level you need to cover all aspects and gotchas that vulkan(the dev) might fall into.</p>"},{"location":"Vulkan/Vulkan-Beyond/#gpu-cpu-3","title":"GPU + CPU = &lt;3","text":"<p>We can talk about Vulkan and how it works for weeks and still have more topics that we haven't covered. By the way, a very effecient way to learn about it, is to simply read the Vulkan-Samples made by Khronos and others.  But let's suppose that we have already created a working Vulkan Environment and we are ready to talk with the GPU... \"GPU, do this!\".</p> <p>To do as such, we need to record a Command in a Command Buffer. The Vulkan Pipeline will know which installement we need and which Shader Module we intend to run the GPU. The Command is then stored in a Queue. The Queue can be seen as a stack memory that accepts commands sequenctually... A then B then C... The Queue is submitted to the GPU. Finally we simply wait until idle i.e wait until our gpu compute code is terminated as we don't need any render workload or such from the GPU. So that we can proceed with further code.</p> <p>All of this is executed on the CPU-side. The GPU takes the heavy-lifting and the actual execution of Compute only once queue is submitted. This is a good example of async computation which means that two things are doing seperate operations and they Synchronize with each other at different times. The CPU proceeds with data analysis or plotting only when the GPU is idle.</p> <p>Through Vulkan, the GPU offers about 16 Queue Families (Check your vkinfo) to stack commands inside for execution. Hence the described procedure does not happen once in a standard GPU pipeline and does not have to be unique. </p>"},{"location":"Vulkan/Vulkan-Beyond/#nvidia-ga102-dive","title":"Nvidia GA102 Dive","text":"<p>You can find GA102 Architecture whitepaper at Nvidia's</p> <p>Before discussing the issues at hand, now is a good chance to dip our hands a bit in the Hardware Side of Nvidia's latest GPU high-end architecture. Although, the dies become faster, and more power demanding, the idea behind a gpu still remains the same throughout the last generations. </p> <p>A full GPU is mainly made out of memory and execution cores.  The execution cores can be seen as a hierachical abstraction. The GPU (GA102 as reference) has 7 GPCs. Each GPC consists of 12 TPCs. Each TPC is made out of 2 SMs. Each SM has a Warp Scheduler, a 64KB register File (Registers), Load/Store Units and 32 CUDA FP32/INT32 cores.</p> <p>This GPU has 84 SMs overall and that is the most important unit in understanding the GPU Design. An SM (Streaming Multiprocessor) is a scalable core and a Cuda Core is the arithmetic brain for operations inside the SM.</p> <p></p> <p>Memory consists of a big VRAM (DRAM) outside of the SoC, L2 Cache and a smaller faster L1 Cache closer to every SM. The register file inside the SM is the fastest and it's used to store any temporary values or branch jump \"pointers\". </p> <p>L1 Cache can also be split into some shared memory that threads can concurrently share at the same time, depending on the configuration.</p> <p>In the Compute Model, we talk about Warps, hence the warp scheduler. Warps are a \"virtual\" budnel of threads (Also called Wavefronts at AMD) made out of a pack of 32 Threads that are executed together. The Warp Scheduler takes care of issueing and disaptching the warps from the Intstruction bank to the SMs and cuda cores. It's only up to the Dev to correctly set the size of the Workload and its scalability. The Warp Scheduler will handle the rest. </p>"},{"location":"Vulkan/Vulkan-Beyond/#warps-divergence","title":"Warps &amp; Divergence","text":"<p>SMs execute instructions in warps, each warp consists of 32 Threads. It is important to notice that all warps in one SM execute the same instruction. Once done the scheduler issues the next instruction or decides to schedule another warp if the current has to stall for e.g. (Priority scheduling). The GA102 can schedule 4 warps at one cycle as seen in the figure. The Warp Scheduler is still a black box and very few documents describe it's exact functional model. It's also a piece that changes from one architecture to another and handles data and execution differently. Furthermore, the Warps do not directly map to the local group size and global work size in Vulkan.</p> <p>A warp is considered active from the point its threads start executing until all threads have finished. SMs have a limit on the number of active warps, meaning the remaining inactive warps will need to wait until the current active ones are finished execuring. The ratio of active warps on an SM to the maximum number of active warps on the SM is called occupancy.</p> <p>If the code to be executed has if clauses then some threads inside the warp have to execute with masks (Not do anything as the if condition is false ) and the else branch would need to also execute AFTER the warp is done with the first part. This is called Warp Divergence. Even if modern GPUs are becoming better with handling the divergence. Compilers tend to also optimize the shader. It's still viewed as one of the DONT in parallel compute. </p>"},{"location":"Vulkan/Vulkan-Beyond/#the-current-vulkan-execution-pipeline","title":"The current Vulkan Execution Pipeline","text":""},{"location":"Vulkan/Vulkan-Beyond/#vkdispatch","title":"vkDispatch()","text":"<p>The current RAYX Tracer uses 1 Vulkan Pipeline consisting of 1 Shader Module. The Shader module is dispatched once with the amount of needed threads (Rays) through 1 Compute Queue and the GPU would handle the rest. </p> <p></p> <p>The fence shows that we are waiting for the GPU to become idle.</p>"},{"location":"Vulkan/Vulkan-Beyond/#shader-ifs","title":"Shader ifs","text":"<p>The current shader code has many if elif elif branchs which would cause internally a huge amount of divergence. According to nvidia's devoloper guide for tuning:</p> <p>The high-priority recommendations from those guides are as follows:</p> <ul> <li>Find ways to parallelize sequential code.</li> <li>Minimize data transfers between the host and the device.</li> <li>Adjust kernel launch configuration to maximize device utilization.</li> <li>Ensure global memory accesses are coalesced.</li> <li>Minimize redundant accesses to global memory whenever possible.</li> <li>Avoid long sequences of diverged execution by threads within the same warp.</li> </ul> <p>The divergence and the need to schedule each divergence is a waste of SMs. Our main function is an if clause by itself, inside of it are more ifs. This is one of the major flows of writing GLSL that we seem to be trapped in for now. Even with compiler optimization and the fact that modern GPUs can easily handle warp divergence, it's still one of the main issues that need to be fixed. New architectures include better divergence methods but we shouldn't rely only on that for better performance.</p> <p>One thing to consider is that usually most ray bundles react the same way in very small finite surfaces. The divergence only happens at the extremeties of said surfaces/objects or wasteboxes. </p>"},{"location":"Vulkan/Vulkan-Beyond/#creating-shader-modules","title":"Creating Shader Modules","text":"<p>To create a pipeline for anything-vulkan, we need to first upload the shader code to the GPU. The shader code is created inside a shader module with the main function as it's entry point. The GLSL code files in RAYX are all packed together and uploaded once. This bundle is too big for standard shader codes and it causes setup speed-loss as vulkan usually hangs in this step waiting for all instructions to be streamed to the GPU. </p>"},{"location":"Vulkan/Vulkan-Beyond/#nsight-graphics-metrics","title":"Nsight Graphics Metrics","text":"<p>Nvidia Nsight Graphics is a developer profiling tool that can run GPU Traces (And many other Profiling traces). It supports Vulkan natively which makes it the perfect candidate. The only problem is that RAYX still does not have a Vulkan Window as we only do compute. So Nsight Graphics is very limited and cannot catch \"frames\" for tracing. The GPU Trace produces a resource usage timeline and can also name the possible bottlenecks and reasons for low throughput if any. So what does Nsight Graphics say about RAYX Application?</p>"},{"location":"Vulkan/Vulkan-Beyond/#metrics","title":"Metrics","text":"<p>Well, not good stuff..  Below are the Metrics, recorded from a run of 1.5 million Rays:</p> <p></p> <p>Notice: - High \"CS Warp Can't Launch -  Register Limited\" - Low SM Throughput - High \"Active SM Unused Warp slots on ative SM\"</p> <p>The timeline shows more detailed information about the execution:</p> <p></p> <p>Notice the bottlneck in the Compute Warps, stopping at almost 25% and the constant CS Warp Can't launch.</p> <p>Aren't we supposed to get a higher SM Throughput?.. Shouldn't the compute warps reach 95% ?..</p>"},{"location":"Vulkan/Vulkan-Beyond/#problem-explained","title":"Problem Explained","text":"<p>The divergence and the massive amount of shader code to execute in one thread / Warp causes a register pressure. Furthermore we have plenty of loops inside the shader code that might have been unrolled which is causing stalled Warps and the SM being not able to issue to all available CUDA Cores at once. Per Cycle, we are only using 22% of Available Warps. The SM is only using very specific alu fonctions and not even close to hitting 10% mark of the different operations that it can do (FMA Pipe for Floating precision being 5%). This can be better improved by reducing the stalled Warps. </p> <p>Nsight also recommends that we solve the issue  as the SM is \"running out of register-file space\" by moving to async compute.</p> <p>It's however worth mentioning that this is one of the most common SM-occupancy limiters for pixel and compute shaders. [blog]</p>"},{"location":"Vulkan/Vulkan-Beyond/#suggested-vulkan-pipeline","title":"Suggested Vulkan pipeline","text":""},{"location":"Vulkan/Vulkan-Beyond/#async-compute","title":"Async Compute","text":"<p>To solve this we use the queue in vulkan and send as many small known commands as possible with smaller shader codes instead of one big block of GLSL. We use multiple Compute Queues if needed and let the Warp Scheduler control the rest. We obviously need  a few synchronization points as we are now out of the global scope i.e we need to wait until rays intersect before reflecting, to send more specific commands. This is getting closer an async ompute model! For each stage/compute step we dedicate a vkPipeline preloaded with the shader and all what's left is to correctly bind the Descriptor Sets and push the command at the right time into the Queue.</p> <p>The new Compute Pipeline Pass: </p> <p>A look into a standard usage of queues: </p> <p>One issue remains to be solved (or mainly discussed) is as now we are sending commands per Object and per run. We need to know what type of object the ray intersects to feed it the correct shader module. For that we propose these solutions:</p> <p></p> <p>The solutions are straight-forward. Solution 2 and 5 are the top-picks as they rely on on async compute the most.</p> <p>This is still a bound-to-fail idea as we are not sure if it will solve the register and idle Warps problem. But it will surely change some the vulkan code structure.</p>"},{"location":"Vulkan/Vulkan-Beyond/#pros","title":"Pros:","text":"<ul> <li>Better readability</li> <li>Easier debugging as now if the compute unit fails there is no way of finding where and what happened inside the GPU.</li> <li>Better SM occupancy and throughput as the code to be executed becomes more similar, smaller and easier to run in parallel on multiple Wraps at a time WITHOUT need for divergence scheduling.</li> </ul>"},{"location":"Vulkan/Vulkan-Beyond/#cons","title":"Cons:","text":"<ul> <li>More complicated</li> <li>Memory Synchronization is needed to avoid read before write and overwrite. This can hinder performance if done wrong.</li> <li>More Shaders, and the sum of all shaders combined will be bigger than one shader for all. (Duplicate help functions etc..)</li> </ul> <p>The main goal is that the pros and the wasted Unused Warps would overcome the cons mentioned.</p>"},{"location":"Vulkan/Vulkan-Beyond/#opencl-vs-vulkan","title":"OpenCL vs Vulkan","text":"<p>A big downset of the new implementation is that it's still being made inside Vulkan. For that we can replace all of Vulkan's API with a pure GPGPU API: OpenCL.</p> <p>As mentioned earlier Vulkan is not meant to be purely for compute as CUDA or OpenCL etc. but to include compute stages betweenn other render passes. Which makes the pure compute dev work even harder and more time consuming. </p> <p>OpenCL is lightweight and easier to understand and recreate than Vulkan. It's definitely not faster than OpenCL. It's also older. But still valid for such cases and most of all supported by nvidia and amd. </p>"},{"location":"Vulkan/Vulkan-Shader-Split/","title":"Vulkan multi-shaderfile support: Shader split","text":""},{"location":"Vulkan/Vulkan-Shader-Split/#why","title":"Why?","text":"<p>The current compute task in RAYX is crammed into one <code>main.comp</code> compute shader file. This shader file takes care of all the computation and runs all neccessary tracing operations (bounces, collision check, etc.). As expected though, this file is huge in size, even compared to the state of the art compute shaders. As a consequence, loading this file into the GPU as instructions through Vulkan takes a while.</p> <p>Moreover, although including one file, launching the task once and idle waiting are easy, massive flexibility and granuanilty are lost. Once the compute task starts, the CPU receives messages from the GPU only once this task has finished or failed. In the meantime, the GPU is a blackbox! To ensure correct result storage, the VRAM needs to allocate enough space for all recorded events, which leads to the output buffer's exponential increase in memory usage. </p>"},{"location":"Vulkan/Vulkan-Shader-Split/#how-to-solve","title":"How to solve?","text":"<p>The Vulkan Engine needs to undergo a refactor, so that it can create multiple compute tasks coming from different shader files. We only traget \"path tracing\" and already have the whole procedure in main.comp. A good start would be to split this shader file into coherent smaller files, which might help make the engine's tasks easier to handle. This would first reduce the size of each task therby help the GPU Scheduler and reduce the register load inside every Core (Nvidia SM Core). By dispatching smaller similar tasks to the GPU, these tasks are bound to finish sooner and more likely to be executed in parallel, as opposed to having idle cores due to register bottlneck or missing cache as reported by Nvidia Nsight tools in singular shader file. </p> <p>Futhermore, this enables more debugging features as we gain more control over the control flow of the tracing algorithm. But also, the output buffer can be merged with the input buffer and read to fetch results every time a new \"mini-task\" has finished. The engine is supposed to treat a specific chunk of data, so it makes senes to send the data to GPU and read it back at every checkpoint, while the GPU can execute more tasks on the same data.</p>"},{"location":"Vulkan/Vulkan-Shader-Split/#vkpipeline","title":"VKPipeline","text":"<p>AFAIK, a shader <code>VkShaderModule</code> can only be bound through a unique pipeline <code>VkPipeline</code>. Hence this refactoring will center itself around this principle in the goal of making an easy-to-understand API that still doesn't require much user input. </p>"},{"location":"Vulkan/Vulkan-Shader-Split/#how-it-works","title":"How it works","text":""},{"location":"Vulkan/Vulkan-Shader-Split/#a-pass-is-group-of-pipelines","title":"A Pass is group of Pipelines","text":"<p>The Vulkan Engine is made out of multiple passes. A (compute) Pass is the main class for executing a compute Program(Shader). Every Pass can have a group of pipelines to be executed sequentially. Each Pipeline is bound to a shader file. </p> <p>Let's suppose, we have Task A, B, and C to be executed on the GPU. If A and B can be ran sequentially, but C needs some CPU intervention before being also executed on GPU, then a possible composition would be to <code>createComputePipelinePass()</code> with A and B in the same Pass (containing 2 pipelines/shaders) and another Pass with only C. A Compute Command recorded for the first Pass will execute for both A and B. Another one is needed for C.</p> <p></p>"},{"location":"Vulkan/Vulkan-Shader-Split/#flow-management","title":"Flow management","text":"<p>To follow vulkan usage styles, the vulkan engine is initiliazed once. Then, as we use a batching system, we prepare the Passes (descirptor updating, necessary buffer reallocation, etc. ), run the the required compute task, cleanup, and repeat.</p> <p></p>"},{"location":"Vulkan/Vulkan-Shader-Split/#memory-management","title":"Memory management","text":"<p>For buffer-descriptor-Pass binding, a new <code>BufferHandler</code> is created. This manages and prepares the buffers needed for the compute tasks.</p> <p>The <code>BufferHandler</code> binds, following vulkan rules, the buffers to the correct pass, makes sure that the needed size is available and takes care of the transfer and write operation from and to the GPU.</p> <p>A new buffer is created <code>ray-meta</code> which contains unique data to each ray (seed, ctr or state). This data also persists between bounces. </p>"},{"location":"Vulkan/Vulkan-Shader-Split/#pros-and-cons","title":"Pros and Cons","text":""},{"location":"Vulkan/Vulkan-Shader-Split/#pros","title":"Pros:","text":"<ul> <li> <p>Multiple shader files:</p> <p>The engine supports more than one shader file, which was the main goal at the beginning. It is now easy to introduce a new shader into the engine, for example ray generation-only tasks, sorting and ray marching.</p> </li> <li> <p>More flexibility and ease of debugging: </p> <p>The vulkan engine now has more features and much more function calls that makes implementing new ideas faster. It is easier now to fetch more information from the GPU, since the CPU gets more messages in return (every bounce).</p> </li> <li> <p>Less memory usage:</p> <p>The same buffer <code>ray-buffer</code> is now input and output. The output-only buffer is removed. The size of this buffer is <code>rayAmount</code> instead of being <code>rayAmount*maxBounces</code>.</p> </li> <li> <p>More openings for optimization and parallelism. [Looks at Vulkan-Beyond page]</p> </li> <li> <p>Most of the classes (Pipelines, shaders, buffers, descriptors) are written in a way that graphic pipelines can also be supported (With more code obviously)</p> </li> <li> <p>OOP, destruction, and vulkan cleanup</p> <p>The new engine moves away from the C-style Vulkan version and creates objects with constructs, smart-pointers and destructors. As a consequence, memory leaks are less bound to happen and syntax is clearer. For example: <pre><code>// Create a buffer with rayList content\nbufferHandler\n        -&gt;createBuffer&lt;Ray&gt;({\"ray-buffer\", VKBUFFER_INOUT}, rayList); \n</code></pre></p> <pre><code>// @brief Use ComputePipelineCreateInfo to build a new computePipeline\nstruct ComputePassCreateInfo {\n    const char* passName;\n    std::vector&lt;Pass::PipelineCreateInfo&gt; pipelineCreateInfos = {};\n    int descriptorSetAmount = 1;\n};\n</code></pre> <pre><code>// Explicit passes cleanup\nfor (auto pass : m_computePasses) {\n    for (auto&amp; pipeline : pass-&gt;getPipelines()) {\n        pipeline-&gt;cleanPipeline(m_Device);\n    }\n}\n</code></pre> </li> </ul>"},{"location":"Vulkan/Vulkan-Shader-Split/#cons","title":"Cons","text":"<ul> <li>The internal vkAPI is now a relatively harder to understand as we offer the user more power with compute tasks.</li> <li>More advanced vulkan synchronization (Fences, multi-pass etc.) are used, which means more pitfalls.</li> <li>The new version is slower as it relies more on I/O Transfers from and to the GPU. However, this can be analyzed and further optimized. We believe that this version has potential to run faster then original single-shader version.</li> <li>Some vulkan aspects are obviously not optimized, but are ignored as this was planned to be an easy-to-understand prototype: (Descirptors are all still bound to once set, Pushconstants are global and still do not support multi-pass system)</li> <li>Unknown undefined behaviour (Hence this shader is not merged)</li> </ul>"},{"location":"Vulkan/Vulkan-Shader-Split/#conclusion","title":"Conclusion","text":"<p>This was rather a successful experiment. I (OS) learned much more about Vulkan and GPUs. Once it is time to work on the vulkan engine in RAYX. This is by far, a high priority.</p>"},{"location":"Vulkan/Vulkan/","title":"Vulkan","text":"<p>In this section we introduce our design decisions for Vulkan and how we use it to get efficient tracing on the GPU.</p>"},{"location":"Vulkan/VulkanTracer/","title":"VulkanTracer (rayx)","text":"<p>The VulkanTracer is a ray tracing module using VULKAN by KHRONOS GROUP to efficiently trace rays with hardware acceleration.</p> <p>In the current version the Vulkan Engine is a Compute Class that runs as much parallel as possible on the GPU.</p> <p>Current procedure:</p> <ul> <li>generate rays</li> <li>create input and output buffers</li> <li>initialize Vulkan</li> <li>run the main loop</li> <li>clean up</li> </ul> <p>initVulkan():</p> <ul> <li>create a Vulkan instance</li> <li>set up the debug messenger</li> <li>pick the physical device and create a logical device to access it</li> <li>create the input and output buffers</li> <li>create the descriptors to connect the buffers to the shader</li> <li>create a compute pipeline and a command buffer for the shader</li> </ul> <p>mainLoop():</p> <ul> <li>run the command buffer</li> <li>read the data from the output buffer</li> </ul>"},{"location":"Vulkan/VulkanTracer/#how-the-vulkantracer-works","title":"How the VulkanTracer works","text":""},{"location":"Vulkan/VulkanTracer/#buffer-types-used","title":"Buffer types used:","text":"<p>A uniform buffer (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>) is a descriptor type associated with a buffer resource directly, described in a shader as a structure with various members that load operations can be performed on. More here</p> <p>A storage buffer (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>) is a descriptor type associated with a buffer resource directly, described in a shader as a structure with various members that load, store, and atomic operations can be performed on.</p>"},{"location":"Vulkan/VulkanTracer/#buffers","title":"Buffers:","text":"Buffers Size ( vkDeviceSize) Usage Name 0 NumverOfRays*RAY_DOUBLE_AMOUNT Transfer_DST|STORAGE_BUFFER Ray Buffer 1 NumberOfRays*RAY_DOUBLE_AMOUNT Transfer_SRC|STORAGE_BUFFER Output Buffer 2 Quadric_parm+beamlineSize STORAGE_BUFFER Quadric Buffer 3 100 STORAGE_BUFFER Buffer for xyznull 4 xxxxxxxxxxxxxxx STORAGE_BUFFER materialIndexBuf 5 xxxxxxxxxxxxxxx STORAGE_BUFFER materialBuf 6 xxxxxxxxxxxxxxx STORAGE_BUFFER debugBuffer X min(GPU_MAX_STAGING,numberOfRays) STORAGE|DST|SRC Staging Buffer"},{"location":"Vulkan/VulkanTracer/#buffer-usages","title":"Buffer Usages:","text":"<p><code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> specifies that the buffer can be used as the source of a transfer command (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT).</p> <p><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> specifies that the buffer can be used as the destination of a transfer command.</p>"},{"location":"rayxCore/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace glm </li> <li>namespace rayx <ul> <li>class BeamlineNode Base class for all nodes in the beamline hierarchy (scene/model graph). </li> <li>namespace BlockSizeConstraint <ul> <li>struct AtLeast </li> <li>struct AtMost </li> <li>struct Exact </li> <li>struct InRange </li> <li>struct None </li> </ul> </li> <li>class CircleSource </li> <li>struct CollisionPoint </li> <li>struct CollisionWithElement </li> <li>struct ComplexFresnelCoeffs </li> <li>struct ConstState stores all constant buffers </li> <li>struct DatEntry </li> <li>struct DatFile </li> <li>struct Deg </li> <li>class DesignElement </li> <li>class DesignMap <ul> <li>class ConstIterator </li> <li>class Iterator </li> </ul> </li> <li>class DesignSource </li> <li>struct DeviceConfig <ul> <li>struct Device </li> </ul> </li> <li>class DeviceTracer DeviceTracer is an interface to a tracer implementation we need this interface to remove the actual implementation from the rayx api. </li> <li>class DipoleSource </li> <li>struct EnergyDistributionDataBase </li> <li>struct EnergyDistributionList </li> <li>struct Exit </li> <li>struct FresnelCoeffs </li> <li>struct GenRays <ul> <li>struct BatchConfig holds configuration state of one batch </li> <li>struct SourceConfig holds configuration state of sources </li> </ul> </li> <li>class Group </li> <li>struct HardEdge </li> <li>struct IgnoreLog </li> <li>class InstrumentationTimer </li> <li>class LightSourceBase </li> <li>struct Log </li> <li>struct MaterialTables </li> <li>class MatrixSource </li> <li>class MegaKernelTracer </li> <li>struct MutableState stores all mutable buffers </li> <li>struct NffEntry This struct represents one line of a .nff file. </li> <li>struct NffTable </li> <li>class ObjectIndexMask </li> <li>class ObjectMask </li> <li>struct ObjectTransform </li> <li>struct OpticalElement Structure to represent an element in the ray tracing simulation. </li> <li>struct OpticalElementAndTransform </li> <li>struct PalikEntry This struct represents one line of a .NKP file. </li> <li>struct PalikTable </li> <li>class PixelSource </li> <li>class PointSource </li> <li>struct PsiAndStokes </li> <li>struct Rad </li> <li>struct Rand </li> <li>struct RayListSource </li> <li>struct Rays A structure representing a collection of rays and their attributes. Each attribute is stored as a vector, allowing for efficient storage and manipulation of multiple rays. The Rays structure supports move semantics for efficient transfers, but disables copy semantics to prevent accidental costly copies. Use the<code>copy()</code> method to create an explicit copy when needed. </li> <li>struct RaysBuf </li> <li>struct RaysPtr </li> <li>class ResourceHandler </li> <li>struct Resources <ul> <li>struct BeamlineConfig holds configuration state of allocated resources. required to trace correctly </li> </ul> </li> <li>struct RotationBase </li> <li>struct SeparateEnergies If there is only one spike (i.e. m_numberOfEnergies = 1), then this spike is at <code>m_centerEnergy</code> . </li> <li>class SimpleUndulatorSource </li> <li>struct SlopeError Structure to represent slope error parameters. </li> <li>struct SoftEdge </li> <li>class Tracer </li> <li>class Undefined </li> <li>class Variant </li> <li>struct Verb </li> <li>struct Warn </li> <li>namespace complex </li> <li>namespace detail <ul> <li>struct BehaviourTypes <ul> <li>struct Crystal </li> <li>struct Foil </li> <li>struct Grating </li> <li>struct ImagePlane </li> <li>struct Mirror </li> <li>struct RZP </li> <li>struct Slit </li> </ul> </li> <li>struct CoatingTypes <ul> <li>struct MultilayerCoating </li> <li>struct OneCoating </li> <li>struct SubstrateOnly </li> </ul> </li> <li>struct CutoutTypes <ul> <li>struct Elliptical </li> <li>struct Rect </li> <li>struct Trapezoid </li> <li>struct Unlimited </li> </ul> </li> <li>struct Ray </li> <li>struct SurfaceTypes <ul> <li>struct Cubic </li> <li>struct Plane </li> <li>struct Quadric </li> <li>struct Toroid </li> </ul> </li> </ul> </li> <li>namespace xml <ul> <li>struct Parser </li> </ul> </li> </ul> </li> <li>namespace rayx </li> <li>namespace rayx </li> <li>struct SourceState </li> <li>struct All </li> <li>struct AllElements </li> <li>struct AllSources </li> <li>struct ByIndices </li> <li>struct None </li> </ul>"},{"location":"rayxCore/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Intern <ul> <li>dir rayx-core <ul> <li>dir src <ul> <li>file Angle.h </li> <li>file CanonicalizePath.h </li> <li>file Core.h </li> <li>file FileIO.h </li> <li>dir Beamline <ul> <li>file Beamline.h </li> <li>file DatFile.h </li> <li>file Definitions.h </li> <li>file EnergyDistribution.h </li> <li>file Node.h </li> <li>file StringConversion.h </li> </ul> </li> <li>dir Debug <ul> <li>file Debug.h </li> <li>file Instrumentor.h </li> </ul> </li> <li>dir Design <ul> <li>file DesignElement.h </li> <li>file DesignSource.h </li> <li>file Value.h </li> </ul> </li> <li>dir Element <ul> <li>file Behaviour.h </li> <li>file Coating.h </li> <li>file Cutout.h </li> <li>file Element.h </li> <li>file Surface.h </li> </ul> </li> <li>dir Material <ul> <li>file Material.h </li> <li>file NffTable.h </li> <li>file PalikTable.h </li> </ul> </li> <li>dir Rml <ul> <li>file DesignElementWriter.h </li> <li>file DesignSourceWriter.h </li> <li>file Importer.h </li> <li>file Locate.h </li> <li>file xml.h </li> </ul> </li> <li>dir Shader <ul> <li>file ApplySlopeError.h </li> <li>file Approx.h </li> <li>file Behave.h </li> <li>file Collision.h </li> <li>file Complex.h </li> <li>file Constants.h </li> <li>file Crystal.h </li> <li>file Cubic.h </li> <li>file CutoutFns.h </li> <li>file Diffraction.h </li> <li>file Efficiency.h </li> <li>file ElectricField.h </li> <li>file EventType.h </li> <li>file ImageType.h </li> <li>dir LightSources <ul> <li>file CircleSource.h </li> <li>file DipoleSource.h </li> <li>dir EnergyDistributions <ul> <li>file EnergyDistribution.h </li> </ul> </li> <li>file LightSource.h </li> <li>file MatrixSource.h </li> <li>file PixelSource.h </li> <li>file PointSource.h </li> <li>file RayListSource.h </li> <li>file SimpleUndulatorSource.h </li> </ul> </li> <li>file InvocationState.h </li> <li>file LineDensity.h </li> <li>file Rand.h </li> <li>file Ray.h </li> <li>file RaysPtr.h </li> <li>file RecordEvent.h </li> <li>file Refrac.h </li> <li>file RefractiveIndex.h </li> <li>file SlopeError.h </li> <li>file SphericalCoords.h </li> <li>file Throw.h </li> <li>file Trace.h </li> <li>file Transmission.h </li> <li>file Utils.h </li> </ul> </li> <li>dir Tracer <ul> <li>file Accelerator.h </li> <li>file DeviceConfig.h </li> <li>file DeviceTracer.h </li> <li>file GenRays.h </li> <li>file MegaKernelTracer.h </li> <li>file Tracer.h </li> <li>file Util.h </li> </ul> </li> <li>dir Writer <ul> <li>file CsvWriter.h </li> <li>file H5Writer.h </li> </ul> </li> <li>file ObjectMask.h </li> <li>file Random.h </li> <li>file RayAttrMask.h </li> <li>file Rays.h </li> <li>file Variant.h </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"rayxCore/namespaceglm/","title":"Namespace glm","text":"<p>Namespace List &gt; glm</p>"},{"location":"rayxCore/namespaceglm/#public-functions","title":"Public Functions","text":"Type Name GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v, T scalar)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (vec&lt; 3, T, Q &gt; const &amp; v, rayx::complex::tcomplex&lt; T &gt; scalar)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v, rayx::complex::tcomplex&lt; T &gt; scalar)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (T scalar, vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (rayx::complex::tcomplex&lt; T &gt; scalar, vec&lt; 3, T, Q &gt; const &amp; v)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (rayx::complex::tcomplex&lt; T &gt; scalar, vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::col_type operator* (mat&lt; 3, 3, T, Q &gt; const &amp; m, typename mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::row_type const &amp; v)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::row_type operator* (typename mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::col_type const &amp; v, mat&lt; 3, 3, T, Q &gt; const &amp; m)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (mat&lt; 3, 3, T, Q &gt; const &amp; m1, mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m2)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m1, mat&lt; 3, 3, T, Q &gt; const &amp; m2)  GLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; operator* (mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m1, mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m2)"},{"location":"rayxCore/namespaceglm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/namespaceglm/#function-operator","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v,\n    T scalar\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_1","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    vec&lt; 3, T, Q &gt; const &amp; v,\n    rayx::complex::tcomplex&lt; T &gt; scalar\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_2","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v,\n    rayx::complex::tcomplex&lt; T &gt; scalar\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_3","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    T scalar,\n    vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_4","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    rayx::complex::tcomplex&lt; T &gt; scalar,\n    vec&lt; 3, T, Q &gt; const &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_5","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    rayx::complex::tcomplex&lt; T &gt; scalar,\n    vec&lt; 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_6","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::col_type glm::operator* (\n    mat&lt; 3, 3, T, Q &gt; const &amp; m,\n    typename mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::row_type const &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_7","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::row_type glm::operator* (\n    typename mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt;::col_type const &amp; v,\n    mat&lt; 3, 3, T, Q &gt; const &amp; m\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_8","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    mat&lt; 3, 3, T, Q &gt; const &amp; m1,\n    mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m2\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_9","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m1,\n    mat&lt; 3, 3, T, Q &gt; const &amp; m2\n) \n</code></pre>"},{"location":"rayxCore/namespaceglm/#function-operator_10","title":"function operator*","text":"<pre><code>template&lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; glm::operator* (\n    mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m1,\n    mat&lt; 3, 3, rayx::complex::tcomplex&lt; T &gt;, Q &gt; const &amp; m2\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Complex.h</code></p>"},{"location":"rayxCore/namespacerayx/","title":"Namespace rayx","text":"<p>Namespace List &gt; rayx</p>"},{"location":"rayxCore/namespacerayx/#namespaces","title":"Namespaces","text":"Type Name namespace BlockSizeConstraint namespace complex namespace detail namespace xml"},{"location":"rayxCore/namespacerayx/#classes","title":"Classes","text":"Type Name class BeamlineNode Base class for all nodes in the beamline hierarchy (scene/model graph). class CircleSource struct CollisionPoint struct CollisionWithElement struct ComplexFresnelCoeffs struct ConstState stores all constant buffers struct DatEntry struct DatFile struct Deg class DesignElement class DesignMap class DesignSource struct DeviceConfig class DeviceTracer DeviceTracer is an interface to a tracer implementation we need this interface to remove the actual implementation from the rayx api. class DipoleSource struct EnergyDistributionDataBase struct EnergyDistributionList struct Exit struct FresnelCoeffs struct GenRays &lt;typename Acc&gt; class Group struct HardEdge struct IgnoreLog class InstrumentationTimer class LightSourceBase struct Log struct MaterialTables class MatrixSource class MegaKernelTracer &lt;typename AccTag&gt; struct MutableState stores all mutable buffers struct NffEntry This struct represents one line of a .nff file. struct NffTable class ObjectIndexMask class ObjectMask struct ObjectTransform struct OpticalElement Structure to represent an element in the ray tracing simulation. struct OpticalElementAndTransform struct PalikEntry This struct represents one line of a .NKP file. struct PalikTable class PixelSource class PointSource struct PsiAndStokes struct Rad struct Rand struct RayListSource struct Rays A structure representing a collection of rays and their attributes. Each attribute is stored as a vector, allowing for efficient storage and manipulation of multiple rays. The Rays structure supports move semantics for efficient transfers, but disables copy semantics to prevent accidental costly copies. Use the<code>copy()</code> method to create an explicit copy when needed. struct RaysBuf &lt;typename Acc&gt; struct RaysPtr class ResourceHandler struct Resources &lt;typename Acc&gt; struct RotationBase struct SeparateEnergies If there is only one spike (i.e. m_numberOfEnergies = 1), then this spike is at <code>m_centerEnergy</code> . class SimpleUndulatorSource struct SlopeError Structure to represent slope error parameters. struct SoftEdge class Tracer class Undefined class Variant &lt;typename Base, Ts&gt; struct Verb struct Warn"},{"location":"rayxCore/namespacerayx/#public-types","title":"Public Types","text":"Type Name typedef Group Beamline enum BehaveType typedef Variant&lt; detail::BehaviourTypes, detail::BehaviourTypes::Mirror, detail::BehaviourTypes::Grating, detail::BehaviourTypes::Slit, detail::BehaviourTypes::RZP, detail::BehaviourTypes::ImagePlane, detail::BehaviourTypes::Crystal, detail::BehaviourTypes::Foil &gt; Behaviour enum BehaviourType enum CentralBeamstop typedef Variant&lt; detail::CoatingTypes, detail::CoatingTypes::SubstrateOnly, detail::CoatingTypes::OneCoating, detail::CoatingTypes::MultilayerCoating &gt; Coating enum CurvatureType typedef Variant&lt; detail::CutoutTypes, detail::CutoutTypes::Rect, detail::CutoutTypes::Elliptical, detail::CutoutTypes::Trapezoid, detail::CutoutTypes::Unlimited &gt; Cutout enum CutoutType enum CylinderDirection typedef xml::Parser DesignObject enum DesignPlane typedef cvec3 ElectricField enum ElectronEnergyOrientation enum ElementType typedef Variant&lt; EnergyDistributionDataBase, EnergyDistributionDataBase::HardEdge, EnergyDistributionDataBase::SoftEdge, SeparateEnergies, EnergyDistributionDataBase::EnergyDistributionList &gt; EnergyDistributionDataVariant enum EnergyDistributionType typedef std::variant&lt; DatFile, HardEdge, SoftEdge, SeparateEnergies &gt; EnergyDistributionVariant enum EnergySpreadUnit enum uint32_t EventType enum std::underlying_type_t&lt; EventType &gt; EventTypeMask enum FigureRotation enum GratingMount typedef cvec2 LocalElectricField typedef std::unordered_map&lt; std::string, std::shared_ptr&lt; DesignMap &gt; &gt; Map enum Material typedef std::optional&lt; alpaka::Buf&lt; Acc, T, alpaka::DimInt&lt; 1 &gt;, int32_t &gt; &gt; OptBuf typedef std::optional&lt; CollisionPoint &gt; OptCollisionPoint typedef std::optional&lt; CollisionWithElement &gt; OptCollisionWithElement enum ParaboloidType enum RZPType typedef uint64_t RandCounter Internal type for the random counter-based RNG. enum Sequential enum SigmaType enum SourceDist enum SourcePulseType enum SpreadType typedef glm::dvec4 Stokes typedef Variant&lt; detail::SurfaceTypes, detail::SurfaceTypes::Plane, detail::SurfaceTypes::Quadric, detail::SurfaceTypes::Toroid, detail::SurfaceTypes::Cubic &gt; Surface enum SurfaceCoatingType enum ToroidType enum ValueType typedef glm::tmat3x3&lt; complex::Complex &gt; cmat3 typedef glm::tvec2&lt; complex::Complex &gt; cvec2 typedef glm::tvec3&lt; complex::Complex &gt; cvec3"},{"location":"rayxCore/namespacerayx/#public-attributes","title":"Public Attributes","text":"Type Name RAYX_X_MACRO_RAY_ATTR enum RAYX_API All   = <code>(1 &amp;lt;&amp;lt; RayAttrMaskCount) - 1</code> bool RAYX_API BENCH_FLAG const std::map&lt; BehaviourType, std::string &gt; BehaviourTypeToString   = <code>/* multi line expression */</code> const std::map&lt; CentralBeamstop, std::string &gt; CentralBeamstopToString   = <code>/* multi line expression */</code> const std::map&lt; CurvatureType, std::string &gt; CurvatureTypeToString   = <code>/* multi line expression */</code> const std::map&lt; CutoutType, std::string &gt; CutoutTypeToString   = <code>/* multi line expression */</code> constexpr int DEFAULT_BATCH_SIZE   = <code>100000</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API Direction   = <code>DirectionX \\| DirectionY \\| DirectionZ</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API DirectionX   = <code>1 &amp;lt;&amp;lt; 5</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API DirectionY   = <code>1 &amp;lt;&amp;lt; 6</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API DirectionZ   = <code>1 &amp;lt;&amp;lt; 7</code> constexpr double ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT   = <code>2.6544187279929558624e-3</code>electric permitivity multiplied by speed of light constexpr double ELECTRIC_PERMITTIVITY   = <code>8.8541878128e-12</code>\\(\\epsilon_0\\) [As/Vm]. vacuum electric permittivity. constexpr double ELECTRON_MASS   = <code>9.1093837015e-31</code>m_e [kg]. electron mass. constexpr double ELECTRON_RADIUS   = <code>2.8179403205e-6</code> constexpr double ELECTRON_VOLT   = <code>1.602176634e-19</code>eV_J ElectronVolt to Joule. constexpr double ELEMENTARY_CHARGE   = <code>1.602176634e-19</code>e_0 [As]. elementary charge. RAYX_X_MACRO_RAY_ATTR enum RAYX_API ElectricFieldX   = <code>1 &amp;lt;&amp;lt; 8</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API ElectricFieldY   = <code>1 &amp;lt;&amp;lt; 9</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API ElectricFieldZ   = <code>1 &amp;lt;&amp;lt; 10</code> const std::map&lt; ElectronEnergyOrientation, std::string &gt; ElectronEnergyOrientationToString   = <code>/* multi line expression */</code> const std::map&lt; ElementType, std::string &gt; ElementTypeToString   = <code>/* multi line expression */</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API Energy   = <code>1 &amp;lt;&amp;lt; 12</code> const std::map&lt; EnergyDistributionType, std::string &gt; EnergyDistributionTypeToString   = <code>/* multi line expression */</code> const std::map&lt; EnergySpreadUnit, std::string &gt; EnergySpreadUnitToString   = <code>{{EnergySpreadUnit::EU\\_PERCENT, \"Percent\"}, {EnergySpreadUnit::EU\\_eV, \"eV\"}}</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API EventType   = <code>1 &amp;lt;&amp;lt; 16</code> const std::map&lt; EventType, std::string &gt; EventTypeToString   = <code>/* multi line expression */</code> constexpr double FACTOR_ELECTRON_ENERGY_SC   = <code>1957</code>RAY-UI shortcut for getFactorElectronEnergy. constexpr double FACTOR_SCHWINGER_RAY   = <code>1.2556937e15</code>\\(G\\) [?]. RAY's factor appearing in Schwinger equation context constexpr double FINE_STRUCTURE_CONSTANT   = <code>7.2973525693e-3</code> const uint32_t FIXED_SEED   = <code>42</code> const std::map&lt; FigureRotation, std::string &gt; FigureRotationToString   = <code>/* multi line expression */</code> const std::map&lt; GratingMount, std::string &gt; GratingMountToString   = <code>{{GratingMount::Deviation, \"Deviation\"}, {GratingMount::Incidence, \"Incidence\"}}</code> constexpr double INV_NM_TO_EVOLT   = <code>1239.841984332002622</code>inverse nanometer-electron volt relationship / reziprocal factor constexpr int IT_ASTIGMATIC2ASTIGMATIC   = <code>12</code> constexpr int IT_POINT2HORIZONTAL_DIVERGENT_LINE   = <code>5</code> constexpr int IT_POINT2HORIZONTAL_LINE   = <code>4</code> constexpr int IT_POINT2POINT   = <code>0</code> const std::map&lt; Material, std::string &gt; MaterialToString   = <code>/* multi line expression */</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API None   = <code>0</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API ObjectId   = <code>1 &amp;lt;&amp;lt; 14</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API OpticalPathLength   = <code>1 &amp;lt;&amp;lt; 11</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API Order   = <code>1 &amp;lt;&amp;lt; 13</code> constexpr double PI   = <code>3.14159265358979323846264338327950</code> constexpr double PLANCK   = <code>6.62607015e-34</code> constexpr double PLANCK_BAR   = <code>PLANCK / (2 \\* PI)</code>\\(\\hbar\\) [Js]. Planck's bar constant. const std::map&lt; ParaboloidType, std::string &gt; ParaboloidTypeToString   = <code>/* multi line expression */</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API PathEventId   = <code>1 &amp;lt;&amp;lt; 1</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API Position   = <code>PositionX \\| PositionY \\| PositionZ</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API PositionX   = <code>1 &amp;lt;&amp;lt; 2</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API PositionY   = <code>1 &amp;lt;&amp;lt; 3</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API PositionZ   = <code>1 &amp;lt;&amp;lt; 4</code> const std::map&lt; RZPType, std::string &gt; RZPTypeToString   = <code>{{RZPType::Elliptical, \"Elliptical\"}, {RZPType::Meriodional, \"Meriodional\"}}</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API RayAttrMask Mask to specify ray attributes. Each attribute is represented as a bit flag, allowing for efficient combination and checking of multiple attributes. It is used to represent the various attributes that can be recorded for rays during ray tracing. RAYX_X_MACRO_RAY_ATTR enum RAYX_API RayAttrMaskCount   = <code>18</code> constexpr double SPEED_OF_LIGHT   = <code>299792458</code>c_0 [m/s]. speed of light in vacuum. const std::map&lt; SigmaType, std::string &gt; SigmaTypeToString   = <code>{{SigmaType::ST\\_STANDARD, \"Standard\"}, {SigmaType::ST\\_ACCURATE, \"Accurate\"}}</code> const std::map&lt; SourceDist, std::string &gt; SourceDistToString   = <code>/* multi line expression */</code> RAYX_X_MACRO_RAY_ATTR enum RAYX_API SourceId   = <code>1 &amp;lt;&amp;lt; 15</code> const std::map&lt; SpreadType, std::string &gt; SpreadTypeToString   = <code>/* multi line expression */</code> const std::map&lt; std::string, BehaviourType &gt; StringToBehaviourType   = <code>/* multi line expression */</code> const std::map&lt; std::string, CentralBeamstop &gt; StringToCentralBeamstop   = <code>/* multi line expression */</code> const std::map&lt; std::string, CurvatureType &gt; StringToCurvatureType   = <code>/* multi line expression */</code> const std::map&lt; std::string, CutoutType &gt; StringToCutoutType   = <code>/* multi line expression */</code> const std::map&lt; std::string, ElectronEnergyOrientation &gt; StringToElectronEnergyOrientation   = <code>/* multi line expression */</code> const std::map&lt; std::string, ElementType &gt; StringToElementType   = <code>/* multi line expression */</code> const std::map&lt; std::string, EnergyDistributionType &gt; StringToEnergyDistributionType   = <code>/* multi line expression */</code> const std::map&lt; std::string, EnergySpreadUnit &gt; StringToEnergySpreadUnit   = <code>{{\"Percent\", EnergySpreadUnit::EU\\_PERCENT}, {\"eV\", EnergySpreadUnit::EU\\_eV}}</code> const std::map&lt; std::string, EventType &gt; StringToEventType   = <code>/* multi line expression */</code> const std::map&lt; std::string, FigureRotation &gt; StringToFigureRotation   = <code>/* multi line expression */</code> const std::map&lt; std::string, GratingMount &gt; StringToGratingMount   = <code>{{\"Deviation\", GratingMount::Deviation}, {\"Incidence\", GratingMount::Incidence}}</code> const std::map&lt; std::string, Material &gt; StringToMaterial   = <code>/* multi line expression */</code> const std::map&lt; std::string, ParaboloidType &gt; StringToParaboloidType   = <code>/* multi line expression */</code> const std::map&lt; std::string, RZPType &gt; StringToRZPType   = <code>{{\"Elliptical\", RZPType::Elliptical}, {\"Meriodional\", RZPType::Meriodional}}</code> const std::map&lt; std::string, SigmaType &gt; StringToSigmaType   = <code>{{\"Standard\", SigmaType::ST\\_STANDARD}, {\"Accurate\", SigmaType::ST\\_ACCURATE}}</code> const std::map&lt; std::string, SourceDist &gt; StringToSourceDist   = <code>/* multi line expression */</code> const std::map&lt; std::string, SpreadType &gt; StringToSpreadType   = <code>/* multi line expression */</code> void RAYX_API(* error_fn"},{"location":"rayxCore/namespacerayx/#public-functions","title":"Public Functions","text":"Type Name RAYX_FN_ACC void RAYX_API RZPLineDensity (const glm::dvec3 &amp;__restrict position, const glm::dvec3 &amp;__restrict normal, const Behaviour::RZP &amp;__restrict b, double &amp;__restrict DX, double &amp;__restrict DZ)  RAYX_FN_ACC ElectricField advanceElectricField (const ElectricField field, double waveLength, const double opticalPathLength)  void allocBuf (Queue q, std::optional&lt; Buf &gt; &amp; buf, const int size)  void allocRaysBuf (Queue q, const RayAttrMask attrMask, RaysBuf&lt; Acc &gt; &amp; raysBuf, const int size)  RAYX_FN_ACC double angleBetweenUnitVectors (glm::dvec3 a, glm::dvec3 b) calculates the angle in rad, between two unit vectors RAYX_API void appendH5 (const std::filesystem::path &amp; filepath, const Rays &amp; rays, const RayAttrMask attr=RayAttrMask::All)  RAYX_FN_ACC glm::dvec3 applySlopeError (glm::dvec3 normal, SlopeError error, int O_type, Rand &amp;__restrict rand)  RAYX_FN_ACC void RAYX_API assertCutoutSubset (Cutout c1, Cutout c2)  RAYX_FN_ACC void behave (detail::Ray &amp;__restrict ray, const CollisionPoint &amp;__restrict col, const OpticalElement &amp;__restrict element, const int *__restrict materialIndices, const double *__restrict materialTable)  RAYX_FN_ACC void behaveCrystal (detail::Ray &amp;__restrict ray, const Behaviour::Crystal &amp;__restrict crystal, const CollisionPoint &amp;__restrict col)  RAYX_FN_ACC void behaveFoil (detail::Ray &amp;__restrict ray, const Behaviour::Foil &amp;__restrict foil, const CollisionPoint &amp;__restrict col, int material, const int *__restrict materialIndices, const double *__restrict materialTable)  RAYX_FN_ACC void behaveGrating (detail::Ray &amp;__restrict ray, const Behaviour::Grating &amp;__restrict grating, const CollisionPoint &amp;__restrict col)  RAYX_FN_ACC void behaveImagePlane (detail::Ray &amp;__restrict ray)  RAYX_FN_ACC void behaveMirror (detail::Ray &amp;__restrict ray, const CollisionPoint &amp;__restrict col, const Coating &amp;__restrict coating, int material, const int *__restrict materialIndices, const double *__restrict materialTable)  RAYX_FN_ACC void behaveRZP (detail::Ray &amp;__restrict ray, const Behaviour::RZP &amp;__restrict rzp, const CollisionPoint &amp;__restrict col)  RAYX_FN_ACC void behaveSlit (detail::Ray &amp;__restrict ray, const Behaviour::Slit &amp;__restrict slit)  RAYX_FN_ACC double RAYX_API bessel1 (double v)  RAYX_FN_ACC void bessel_diff (double radius, double wl, double &amp; dphi, double &amp; dpsi, Rand &amp; rand)  RAYX_FN_ACC complex::Complex calcBrewstersAngle (const complex::Complex iorI, const complex::Complex iorT)  RAYX_FN_ACC complex::Complex calcCriticalAngle (const complex::Complex iorI, const complex::Complex iorT)  RAYX_API RAYX_FN_ACC PsiAndStokes calcDipoleFold (double psi, double photonEnergy, double sigpsi, double electronEnergy, double criticalEnergy, ElectronEnergyOrientation electronEnergyOrientation, Rand &amp;__restrict rand)  RAYX_API double calcGamma (double electronEnergy)  RAYX_FN_ACC cmat3 calcJonesMatrix (const ComplexFresnelCoeffs amplitude)  RAYX_API double calcMaxFlux (double photonEnergy, double energySpread, double criticalEnergy, double gamma)  RAYX_API double calcMaxIntensity (double photonEnergy, double verDivergence, double electronEnergy, double criticalEnergy, ElectronEnergyOrientation electronEnergyOrientation, Rand &amp;__restrict rand)  RAYX_FN_ACC cmat3 calcPolaririzationMatrix (const glm::dvec3 incidentVec, const glm::dvec3 reflectOrRefractVec, const glm::dvec3 normalVec, const ComplexFresnelCoeffs amplitude)  RAYX_FN_ACC cmat3 calcPolaririzationMatrixFoil (const glm::dvec3 incidentVec, const glm::dvec3 normalVec, const ComplexFresnelCoeffs amplitude)  RAYX_FN_ACC ComplexFresnelCoeffs calcReflectAmplitude (const complex::Complex incidentAngle, const complex::Complex refractAngle, const complex::Complex iorI, const complex::Complex iorT)  RAYX_FN_ACC FresnelCoeffs calcReflectIntensity (const ComplexFresnelCoeffs reflectAmplitude)  RAYX_FN_ACC cmat3 calcReflectPolarizationMatrixAtNormalIncidence (const ComplexFresnelCoeffs amplitude)  RAYX_FN_ACC ComplexFresnelCoeffs calcRefractAmplitude (const complex::Complex incidentAngle, const complex::Complex refractAngle, const complex::Complex iorI, const complex::Complex iorT)  RAYX_FN_ACC complex::Complex calcRefractAngle (const complex::Complex incidentAngle, const complex::Complex iorI, const complex::Complex iorT)  RAYX_FN_ACC FresnelCoeffs calcRefractIntensity (const ComplexFresnelCoeffs refract_amplitude, const complex::Complex incidentAngle, const complex::Complex refractAngle, const complex::Complex iorI, const complex::Complex iorT)  RAYX_API glm::dmat4 calcTransformationMatrices (glm::dvec4 position, glm::dmat4 orientation, bool calcInMatrix, DesignPlane plane)  RAYX_API double calcVerDivergence (double energy, double sigv, double electronEnergy, double criticalEnergy)  std::filesystem::path RAYX_API canonicalizeRepositoryPath (const std::filesystem::path &amp; relPath)  std::filesystem::path RAYX_API canonicalizeUserPath (const std::filesystem::path &amp; relPath)  int ceilIntDivision (const int dividend, const int divisor)  RAYX_FN_ACC complex::Complex computeEta (double theta, double bragg, double asymmetry, double structureFactorReFH, double structureFactorImFH, double structureFactorReFHC, double structureFactorImFHC, double structureFactorReF0, double structureFactorImF0, double polFactor, double gamma) Computes the normalized angular deviation parameter \u03b7 (Eta) for dynamical X-ray diffraction. RAYX_FN_ACC ComplexFresnelCoeffs computeMultilayerReflectance (const complex::Complex incidentAngle, const double wavelength, int numLayers, const double *__restrict thicknesses, const complex::Complex *__restrict iors)  RAYX_FN_ACC complex::Complex computeR (complex::Complex eta, double structureFactorReFH, double structureFactorImFH, double structureFactorReFHC, double structureFactorImFHC) Computes the reflection coefficient R based on eta This function is based on Equation (103) from Batterman &amp; Cole (1964), p. 706,. RAYX_FN_ACC ComplexFresnelCoeffs computeSingleCoatingReflectance (const complex::Complex incidentAngle, const double wavelength, const double thickness, const complex::Complex iorI, const complex::Complex iorC, const complex::Complex iorS)  RAYX_FN_ACC ComplexFresnelCoeffs computeTransmittance (double wavelength, complex::Complex theta0, const complex::Complex &amp; indexVacuum, const complex::Complex &amp; indexMaterial, double thickness) Calculates the transmission through a single thin film layer using Fresnel equations. RAYX_API RAYX_FN_ACC constexpr bool contains (const RayAttrMask haystack, const RayAttrMask needle) Check if a RayAttrMask (haystack) contains another RayAttrMask (needle). RAYX_API int countSetBits (const RayAttrMask mask) Count the number of set bits (i.e., attributes) in a RayAttrMask. RAYX_FN_ACC glm::dvec3 RAYX_API cubicDirection (const glm::dvec3 &amp;__restrict rayDirection, double alph)  RAYX_FN_ACC glm::dvec3 RAYX_API cubicPosition (const glm::dvec3 &amp;__restrict rayPosition, const double alpha)  RAYX_FN_ACC glm::dvec2 RAYX_API cutoutBoundingBox (Cutout cutout)  void dbg (const std::string &amp; filename, int line, std::string name, std::vector&lt; double &gt; v)  constexpr int defaultMaxEvents (const int numObjects)  RAYX_FN_ACC double degreeOfPolarization (const Stokes stokes)  RAYX_API RAYX_FN_ACC double dipoleBessel (double hnue, double zeta)  RAYX_FN_ACC void RAYX_API directionToSphericalCoords (glm::dvec3 direction, double &amp; out_phi, double &amp; out_psi)  RAYX_FN_ACC double RAYX_API dpow (double a, int b)  RAYX_FN_ACC ElectricField electricFieldToStokes (const ElectricField field, const glm::dvec3 forward, const glm::dvec3 up)  RAYX_FN_ACC ElectricField electricFieldToStokes (const ElectricField field, const glm::dmat3 rotation)  RAYX_FN_ACC ElectricField electricFieldToStokesWithBaseConvention (const ElectricField field, const glm::dvec3 forward)  RAYX_FN_ACC double RAYX_API energyToWaveLength (double x)  RAYX_FN_ACC constexpr EventTypeMask eventTypeToMask (const EventType eventType)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask exclude (const RayAttrMask haystack, const RayAttrMask needle)  void execWithValidWorkDiv (DevAcc devAcc, Queue q, const int numElements, BlockSizeConstraint::Variant blockSizeConstraint, const Kernel &amp; kernel, Args &amp;&amp;... args)  RAYX_FN_ACC double RAYX_API fact (int n)  RAYX_FN_ACC OptCollisionPoint findCollisionInElementCoords (const glm::dvec3 &amp;__restrict rayPosition, const glm::dvec3 &amp;__restrict rayDirection, const OpticalElement &amp;__restrict element, Rand &amp;__restrict rand)  RAYX_FN_ACC OptCollisionPoint RAYX_API findCollisionInElementCoordsWithoutSlopeError (const glm::dvec3 &amp;__restrict rayPosition, const glm::dvec3 &amp;__restrict rayDirection, const Surface &amp;__restrict surface, const Cutout &amp;__restrict cutout, bool isTriangul)  RAYX_FN_ACC OptCollisionWithElement findCollisionWithElements (glm::dvec3 rayPosition, glm::dvec3 rayDirection, const OpticalElement *__restrict elements, const ObjectTransform * __restrict, const int numSources, const int numElements, Rand &amp;__restrict rand)  void RAYX_API fixSeed (uint32_t x)  std::vector&lt; double &gt; formatAsVec (T)  std::vector&lt; double &gt; formatAsVec (int arg)  std::vector&lt; double &gt; formatAsVec (RandCounter arg)  std::vector&lt; double &gt; formatAsVec (EventType arg)  std::vector&lt; double &gt; formatAsVec (double arg)  std::vector&lt; double &gt; formatAsVec (complex::Complex arg)  std::vector&lt; double &gt; formatAsVec (const glm::mat&lt; N, M, T &gt; arg)  std::vector&lt; double &gt; formatAsVec (const glm::vec&lt; N, T &gt; arg)  std::vector&lt; double &gt; formatAsVec (const std::array&lt; T, N &gt; arg)  std::vector&lt; double &gt; formatAsVec (const std::vector&lt; T &gt; arg)  std::vector&lt; double &gt; formatAsVec (const Rays &amp; rays)  std::vector&lt; double &gt; formatAsVec&lt; double &gt; (const std::vector&lt; double &gt; arg)  RAYX_FN_ACC RotationBase forwardVectorToBaseConvention (const glm::dvec3 forward)  RAYX_FN_ACC void fraun_diff (double dim, double wl, double &amp; dAngle, Rand &amp; rand)  RAYX_FN_ACC double getAsymmetryFactor (double braggAngle, double alpha) Computes the asymmetry factor b from the Bragg angle and surface tilt angle. RAYX_FN_ACC glm::dvec2 RAYX_API getAtomicMassAndRho (int material)  constexpr auto getBlockSize ()  RAYX_FN_ACC double getBraggAngle (double energy, double dSpacing2) Computes the bragg angle. void getCone (xml::Parser parser, DesignElement * de)  void getCrystal (xml::Parser parser, DesignElement * de)  RAYX_FN_ACC OptCollisionPoint getCubicCollision (const glm::dvec3 &amp;__restrict rayPosition, const glm::dvec3 &amp;__restrict rayDirection, const Surface::Cubic &amp;__restrict cu)  void getCylinder (xml::Parser parser, DesignElement * de)  bool RAYX_API getDebugVerbose ()  RAYX_FN_ACC double getDiffractionPrefactor (double wavelength, double unitCellVolume) Computes the diffraction prefactor \u0393 used in dynamical X-ray diffraction theory. Defined in Batterman &amp; Cole (1964), p. 685. RAYX_API RAYX_FN_ACC double getDipoleInterpolation (double energy)  void getEllipsoid (xml::Parser parser, DesignElement * de)  void getExpertsCubic (xml::Parser parser, DesignElement * de)  void getExpertsOptics (xml::Parser parser, DesignElement * de)  void getFoil (xml::Parser parser, DesignElement * de)  void getGrating (xml::Parser parser, DesignElement * de)  void getImageplane (xml::Parser parser, DesignElement * de)  RAYX_FN_ACC NffEntry RAYX_API getNffEntry (int index, int material, const int * materialIndices, const double * materialTable)  RAYX_FN_ACC int RAYX_API getNffEntryCount (int material, const int * materialIndices)  RAYX_FN_ACC PalikEntry RAYX_API getPalikEntry (int index, int material, const int * materialIndices, const double * materialTable)  RAYX_FN_ACC int RAYX_API getPalikEntryCount (int material, const int * materialIndices)  void getParaboloid (xml::Parser parser, DesignElement * de)  void getPlaneGrating (xml::Parser parser, DesignElement * de)  void getPlaneMirror (xml::Parser parser, DesignElement * de)  RAYX_FN_ACC OptCollisionPoint getQuadricCollision (const glm::dvec3 &amp;__restrict rayPosition, const glm::dvec3 &amp;__restrict rayDirection, const Surface::Quadric &amp;__restrict quadric)  void getRZP (xml::Parser parser, DesignElement * de)  RAYX_API std::vector&lt; std::string &gt; getRayAttrNames () Get a list of all possible ray attribute names. RAYX_FN_ACC int getRecordIndex (const int gid, const int numRecorded, const int gridStride)  RAYX_FN_ACC complex::Complex RAYX_API getRefractiveIndex (double energy, int material, const int * materialIndices, const double * materialTable)  void getSlit (xml::Parser parser, DesignElement * de)  void getSphereGrating (xml::Parser parser, DesignElement * de)  void getSphereMirror (xml::Parser parser, DesignElement * de)  RAYX_API RAYX_FN_ACC glm::dvec4 getStokesSyn (double energy, double psi1, double psi2, double electronEnergy, double criticalEnergy, ElectronEnergyOrientation electronEnergyOrientation)  void getSurfaceCoating (xml::Parser parser, DesignElement * de)  RAYX_FN_ACC double getTheta (const glm::dvec3 &amp;__restrict rayDirection, const glm::dvec3 &amp;__restrict normal, double offsetAngle)  RAYX_FN_ACC OptCollisionPoint getToroidCollision (const glm::dvec3 &amp;__restrict rayPosition, const glm::dvec3 &amp;__restrict rayDirection, const Surface::Toroid &amp;__restrict toroid, bool isTriangul)  void getToroidMirror (xml::Parser parser, DesignElement * de)  void getToroidalGrating (xml::Parser parser, DesignElement * de)  auto getWorkDivForAcc (alpaka::Idx&lt; Acc &gt; numElements)  RAYX_API double get_factorCriticalEnergy ()  RAYX_API double get_factorElectronEnergy ()  RAYX_API double get_factorOmega ()  RAYX_FN_ACC LocalElectricField globalToLocalElectricField (const ElectricField field, const glm::dvec3 forward, const glm::dvec3 up)  RAYX_FN_ACC LocalElectricField globalToLocalElectricField (const ElectricField field, const glm::dmat3 rotation)  RAYX_FN_ACC LocalElectricField globalToLocalElectricFieldWithBaseConvention (const ElectricField field, const glm::dvec3 forward)  RAYX_API Beamline importBeamline (const std::filesystem::path &amp;)  RAYX_FN_ACC bool RAYX_API inCutout (Cutout cutout, double x, double z)  RAYX_FN_ACC double intensity (const LocalElectricField field)  RAYX_FN_ACC double intensity (const ElectricField field)  RAYX_FN_ACC double intensity (const Stokes stokes)  RAYX_FN_ACC ElectricField interceptFoil (const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 normalVec, ComplexFresnelCoeffs transCoeffs)  RAYX_FN_ACC ElectricField interceptReflect (const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 reflectVec, const glm::dvec3 normalVec, const complex::Complex iorI, const complex::Complex iorT)  RAYX_FN_ACC ElectricField interceptReflectCrystal (const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 reflectVec, const glm::dvec3 normalVec, ComplexFresnelCoeffs reflectAmplitude)  RAYX_API bool isFlag (const RayAttrMask attr) Check if a RayAttrMask represents a single attribute (i.e., is a flag). RAYX_FN_ACC bool isRayTerminated (const EventType eventType)  RAYX_FN_ACC glm::dmat4 RAYX_API keyCutoutPoints (Cutout cutout)  MaterialTables RAYX_API loadMaterialTables (std::array&lt; bool, 92 &gt; relevantMaterials)  RAYX_FN_ACC detail::Ray loadRay (const int i, const RaysPtr &amp;__restrict rays)  RAYX_FN_ACC Stokes localElectricFieldToStokes (const LocalElectricField field)  RAYX_FN_ACC ElectricField localToGlobalElectricField (const LocalElectricField localField, const glm::dvec3 forward, const glm::dvec3 up)  RAYX_FN_ACC ElectricField localToGlobalElectricField (const LocalElectricField localField, const glm::dmat3 rotation)  RAYX_FN_ACC ElectricField localToGlobalElectricFieldWithBaseConvention (const LocalElectricField localField, const glm::dvec3 forward)  Behaviour makeBehaviour (const DesignElement &amp; dele)  Surface makeCone (const DesignElement &amp; dele)  Behaviour makeCrystal (const DesignElement &amp; dele)  Surface makeCubic (const DesignElement &amp; dele)  Surface makeCylinder (const DesignElement &amp; dele)  OpticalElementAndTransform makeElement (const DesignElement &amp; dele, Behaviour behaviour, Surface surface, DesignPlane plane=DesignPlane::XZ, std::optional&lt; Cutout &gt; cutout={})  Surface makeEllipsoid (const DesignElement &amp; dele)  Behaviour makeFoil (const DesignElement &amp; dele)  Behaviour makeGrating (const DesignElement &amp; dele)  Surface makeParaboloid (const DesignElement &amp; dele)  Surface makePlane ()  Surface makeQuadric (const DesignElement &amp; dele)  Behaviour makeRZPBehaviour (const DesignElement &amp; dele)  Behaviour makeSlit (const DesignElement &amp; dele)  Surface makeSphere (double radius)  Surface makeSurface (const DesignElement &amp; dele)  Surface makeToroid (const DesignElement &amp; dele)  bool materialFromString (const char * matname, Material * out)  int nextMultiple (const int value, const int divisor)  int nextPowerOfTwo (const int value)  RAYX_FN_ACC glm::dvec3 RAYX_API normalCartesian (glm::dvec3 normal, double x_rad, double z_rad)  RAYX_FN_ACC glm::dvec3 RAYX_API normalCylindrical (glm::dvec3 normal, double x_rad, double z_rad)  RAYX_API RAYX_FN_ACC constexpr bool operator! (const RayAttrMask lhs)  RAYX_FN_ACC constexpr bool operator! (const EventTypeMask lhs)  bool RAYX_API operator!= (const Rays &amp; lhs, const Rays &amp; rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask operator&amp; (const RayAttrMask lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator&amp; (const EventTypeMask lhs, const EventTypeMask rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; operator&amp;= (RayAttrMask &amp; lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator&amp;= (EventTypeMask &amp; lhs, const EventTypeMask rhs)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const SpreadType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const EnergyDistributionType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const SourceDist v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ElectronEnergyOrientation v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const EnergySpreadUnit v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const RZPType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const CentralBeamstop v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const GratingMount v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ParaboloidType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const CurvatureType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const BehaviourType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const FigureRotation v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const SigmaType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const Material v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ElementType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const EventType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const CutoutType v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const complex::Complex &amp; c)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const glm::tvec2&lt; T &gt; &amp; v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const glm::tvec3&lt; T &gt; &amp; v)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const glm::tvec4&lt; T &gt; &amp; v)  bool RAYX_API operator== (const Rays &amp; lhs, const Rays &amp; rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask operator^ (const RayAttrMask lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator^ (const EventTypeMask lhs, const EventTypeMask rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; operator^= (RayAttrMask &amp; lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator^= (EventTypeMask &amp; lhs, const EventTypeMask rhs)  RAYX_X_MACRO_RAY_ATTR enum RAYX_API RAYX_API RAYX_FN_ACC constexpr RayAttrMask operator| (const RayAttrMask lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator| (const EventTypeMask lhs, const EventTypeMask rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; operator|= (RayAttrMask &amp; lhs, const RayAttrMask rhs)  RAYX_FN_ACC constexpr EventTypeMask operator|= (EventTypeMask &amp; lhs, const EventTypeMask rhs)  RAYX_API RAYX_FN_ACC constexpr RayAttrMask operator~ (const RayAttrMask lhs)  RAYX_FN_ACC constexpr EventTypeMask operator~ (const EventTypeMask lhs)  double RAYX_API randomDouble ()  double RAYX_API randomDoubleInRange (double a, double b)  int randomIntInRange (int a, int b)  double RAYX_API randomNormal (double mean, double stddev)  void RAYX_API randomSeed ()  uint32_t randomUint ()  RAYX_API RayAttrMask rayAttrStringsToRayAttrMask (const std::vector&lt; std::string &gt; &amp; strings) Convert a list of ray attribute names to a RayAttrMask. RAYX_FN_ACC void RAYX_API rayMatrixMult (const glm::dmat4 &amp;__restrict m, glm::dvec3 &amp;__restrict rayPosition, glm::dvec3 &amp;__restrict rayDirection)  RAYX_FN_ACC void RAYX_API rayMatrixMult (const glm::dmat4 &amp;__restrict m, glm::dvec3 &amp;__restrict rayPosition, glm::dvec3 &amp;__restrict rayDirection, ElectricField &amp;__restrict rayElectricField)  RaysPtr raysBufToRaysPtr (RaysBuf&lt; Acc &gt; &amp; buf)  Rays RAYX_API readCsv (const std::filesystem::path &amp; filepath)  std::optional&lt; std::vector&lt; uint8_t &gt; &gt; RAYX_API readFile (const std::string &amp; filename, const uint32_t count=0)  std::optional&lt; std::vector&lt; uint32_t &gt; &gt; readFileAlign32 (const std::string &amp; filename, const uint32_t count=0)  RAYX_API std::vector&lt; std::string &gt; readH5ObjectNames (const std::filesystem::path &amp; filepath)  RAYX_API Rays readH5Rays (const std::filesystem::path &amp; filepath, const RayAttrMask attr=RayAttrMask::All)  RAYX_FN_ACC void refrac2D (detail::Ray &amp;__restrict ray, glm::dvec3 normal, double az, double ax)  RAYX_FN_ACC glm::dvec3 refract_dvec3 (glm::dvec3 I, glm::dvec3 N, double eta)  RAYX_FN_ACC glm::dmat3 rotationMatrix (const glm::dvec3 forward, const glm::dvec3 up)  RAYX_FN_ACC glm::dmat3 rotationMatrixWithBaseConvention (const glm::dvec3 forward)  RAYX_API RAYX_FN_ACC double schwinger (double energy, double gamma, double criticalEnergy) calculate probability for chosen energy with edge-cases according to H.Wiedemann Synchrotron Radiation P. 259 (D.21) RAYX_FN_ACC double selectEnergy (const HardEdge &amp;__restrict hardEdge, Rand &amp;__restrict rand)  RAYX_FN_ACC double selectEnergy (const SoftEdge &amp;__restrict softEdge, Rand &amp;__restrict rand)  RAYX_FN_ACC double selectEnergy (const SeparateEnergies &amp;__restrict separateEnergies, Rand &amp;__restrict rand)  RAYX_FN_ACC double selectEnergy (const EnergyDistributionList &amp;__restrict energyDistributionList, Rand &amp;__restrict rand)  RAYX_FN_ACC double selectEnergy (const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand)  void setAllMandatory (xml::Parser parser, DesignElement * de, DesignPlane dp)  void setAllMandatory (xml::Parser parser, DesignSource * ds)  void setCircleSource (xml::Parser parser, DesignSource * ds)  void RAYX_API setDebugVerbose (bool)  void setDefaultEnergy (xml::Parser parser, DesignSource * ds)  void setDefaultOrientation (xml::Parser parser, DesignSource * ds)  void setDefaultPosition (xml::Parser parser, DesignSource * ds)  void setDipoleSource (xml::Parser parser, DesignSource * ds)  void setMatrixSource (xml::Parser parser, DesignSource * ds)  void setPixelSource (xml::Parser parser, DesignSource * ds)  void setPointSource (xml::Parser parser, DesignSource * ds)  void setSimpleUndulatorSource (xml::Parser parser, DesignSource * ds)  void setStokes (xml::Parser parser, DesignSource * ds)  RAYX_FN_ACC void RAYX_API sphericalCoordsToDirection (double phi, double psi, glm::dvec3 &amp; out_direction)  RAYX_FN_ACC RandCounter RAYX_API squares64 (RandCounter &amp; ctr)  RAYX_FN_ACC double RAYX_API squaresDoubleRNG (RandCounter &amp; ctr)  RAYX_FN_ACC double RAYX_API squaresNormalRNG (RandCounter &amp; ctr, double mu, double sigma)  RAYX_FN_ACC ElectricField stokesToElectricField (const Stokes stokes, const glm::dvec3 forward, const glm::dvec3 up)  RAYX_FN_ACC ElectricField stokesToElectricField (const Stokes stokes, const glm::dmat3 rotation)  RAYX_FN_ACC ElectricField stokesToElectricFieldWithBaseConvention (const Stokes stokes, const glm::dvec3 forward)  RAYX_FN_ACC LocalElectricField stokesToLocalElectricField (const Stokes stokes)  RAYX_FN_ACC void storeRay (const int i, RaysPtr &amp;__restrict rays, const detail::Ray &amp;__restrict ray)  RAYX_FN_ACC bool storeRay (const int i, bool *__restrict storedFlags, RaysPtr &amp;__restrict rays, detail::Ray &amp;__restrict ray, const bool *__restrict objectRecordMask, const int objectIndex, const RayAttrMask attrRecordMask)  std::ostream &amp; streamEnum (std::ostream &amp; os, const Enum value, const std::map&lt; Enum, std::string &gt; &amp; toStringMap)  RAYX_FN_ACC void terminateRay (EventType &amp;__restrict dstEventType, const EventType srcEventType)  RAYX_API std::string to_string (const RayAttrMask attr)  RAYX_FN_ACC void traceNonSequential (const int gid, const ConstState &amp;__restrict constState, MutableState &amp;__restrict mutableState)  RAYX_FN_ACC void traceSequential (const int gid, const ConstState &amp;__restrict constState, MutableState &amp;__restrict mutableState)  RAYX_FN_ACC double RAYX_API vlsGrating (double lineDensity, glm::dvec3 normal, double z, const double vls)  RAYX_FN_ACC double waveLengthToEnergy (const double waveLength)  void RAYX_API writeCsv (const std::filesystem::path &amp; filepath, const Rays &amp; rays)  void RAYX_API writeFile (const std::vector&lt; uint8_t &gt; &amp; data, const std::string &amp; filename, const uint32_t count=0)  RAYX_API void writeH5 (const std::filesystem::path &amp; filepath, const std::vector&lt; std::string &gt; &amp; object_names, const Rays &amp; rays, const RayAttrMask attr=RayAttrMask::All, const bool overwrite=true)"},{"location":"rayxCore/namespacerayx/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/namespacerayx/#typedef-beamline","title":"typedef Beamline","text":"<pre><code>using rayx::Beamline = typedef Group;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-behavetype","title":"enum BehaveType","text":"<pre><code>enum rayx::BehaveType {\n    Mirror,\n    Grating,\n    Slit,\n    RZP,\n    ImagePlane,\n    Crystal,\n    Foil\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-behaviour","title":"typedef Behaviour","text":"<pre><code>using rayx::Behaviour = typedef Variant&lt;detail::BehaviourTypes, detail::BehaviourTypes::Mirror, detail::BehaviourTypes::Grating, detail::BehaviourTypes::Slit, detail::BehaviourTypes::RZP, detail::BehaviourTypes::ImagePlane, detail::BehaviourTypes::Crystal, detail::BehaviourTypes::Foil&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-behaviourtype","title":"enum BehaviourType","text":"<pre><code>enum rayx::BehaviourType {\n    Mirror,\n    Grating,\n    Slit,\n    Rzp,\n    ImagePlane,\n    Crystal,\n    Foil\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-centralbeamstop","title":"enum CentralBeamstop","text":"<pre><code>enum rayx::CentralBeamstop {\n    None,\n    Rectangle,\n    Elliptical\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-coating","title":"typedef Coating","text":"<pre><code>using rayx::Coating = typedef Variant&lt;detail::CoatingTypes, detail::CoatingTypes::SubstrateOnly, detail::CoatingTypes::OneCoating, detail::CoatingTypes::MultilayerCoating&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-curvaturetype","title":"enum CurvatureType","text":"<pre><code>enum rayx::CurvatureType {\n    Plane,\n    Toroidal,\n    Spherical,\n    Cubic,\n    Cone,\n    Cylinder,\n    Ellipsoid,\n    Paraboloid,\n    Quadric,\n    RzpSphere\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-cutout","title":"typedef Cutout","text":"<pre><code>using rayx::Cutout = typedef Variant&lt;detail::CutoutTypes, detail::CutoutTypes::Rect, detail::CutoutTypes::Elliptical, detail::CutoutTypes::Trapezoid, detail::CutoutTypes::Unlimited&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-cutouttype","title":"enum CutoutType","text":"<pre><code>enum rayx::CutoutType {\n    Rect,\n    Elliptical,\n    Trapezoid,\n    Unlimited\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-cylinderdirection","title":"enum CylinderDirection","text":"<pre><code>enum rayx::CylinderDirection {\n    LongRadiusR,\n    ShortRadiusRho\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-designobject","title":"typedef DesignObject","text":"<pre><code>using rayx::DesignObject = typedef xml::Parser;\n</code></pre> <p>The DesignObject contains the design parameters. But the actual OpticalElements does not contain them. The DesignObject is utilized to construct OpticalElements from it's parameters.</p> <p>For now objects can only be created from XML, but later on - when the GUI is around, we might want to add an abstract superclass DesignObject. DesignObject would have child classes xml::Parser and gui::ObjectBuilder or something. This superclass DesignObject could mostly keep the API of the xml::Parser, to make the transition trivial. </p>"},{"location":"rayxCore/namespacerayx/#enum-designplane","title":"enum DesignPlane","text":"<pre><code>enum rayx::DesignPlane {\n    XY,\n    XZ\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-electricfield","title":"typedef ElectricField","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::ElectricField;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-electronenergyorientation","title":"enum ElectronEnergyOrientation","text":"<pre><code>enum rayx::ElectronEnergyOrientation {\n    Clockwise,\n    Counterclockwise\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-elementtype","title":"enum ElementType","text":"<pre><code>enum rayx::ElementType {\n    Undefined,\n    ImagePlane,\n    ConeMirror,\n    Crystal,\n    CylinderMirror,\n    EllipsoidMirror,\n    ExpertsMirror,\n    Foil,\n    ParaboloidMirror,\n    PlaneGrating,\n    PlaneMirror,\n    ReflectionZoneplate,\n    Slit,\n    SphereGrating,\n    Sphere,\n    SphereMirror,\n    ToroidMirror,\n    ToroidGrating,\n    PointSource,\n    MatrixSource,\n    DipoleSource,\n    PixelSource,\n    CircleSource,\n    SimpleUndulatorSource,\n    RayListSource\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-energydistributiondatavariant","title":"typedef EnergyDistributionDataVariant","text":"<pre><code>using rayx::EnergyDistributionDataVariant = typedef Variant&lt;EnergyDistributionDataBase, EnergyDistributionDataBase::HardEdge, EnergyDistributionDataBase::SoftEdge, SeparateEnergies, EnergyDistributionDataBase::EnergyDistributionList&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-energydistributiontype","title":"enum EnergyDistributionType","text":"<pre><code>enum rayx::EnergyDistributionType {\n    File,\n    Values,\n    Total,\n    Param\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-energydistributionvariant","title":"typedef EnergyDistributionVariant","text":"<pre><code>using rayx::EnergyDistributionVariant = typedef std::variant&lt;DatFile, HardEdge, SoftEdge, SeparateEnergies&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-energyspreadunit","title":"enum EnergySpreadUnit","text":"<pre><code>enum rayx::EnergySpreadUnit {\n    EU_PERCENT,\n    EU_eV\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-eventtype","title":"enum EventType","text":"<pre><code>enum rayx::EventType {\n    Uninitialized = 0,\n    Emitted = 1,\n    HitElement = 2,\n    FatalError = 3,\n    Absorbed = 4,\n    BeyondHorizon = 5,\n    TooManyEvents = 6\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-eventtypemask","title":"enum EventTypeMask","text":"<pre><code>enum rayx::EventTypeMask {\n    None = 0,\n    Uninitialized = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Uninitialized),\n    Emitted = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Emitted),\n    HitElement = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::HitElement),\n    FatalError = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::FatalError),\n    Absorbed = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Absorbed),\n    BeyondHorizon = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::BeyondHorizon),\n    TooManyEvents = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::TooManyEvents)\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-figurerotation","title":"enum FigureRotation","text":"<pre><code>enum rayx::FigureRotation {\n    Yes,\n    Plane,\n    A11\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-gratingmount","title":"enum GratingMount","text":"<pre><code>enum rayx::GratingMount {\n    Deviation,\n    Incidence\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-localelectricfield","title":"typedef LocalElectricField","text":"<pre><code>using rayx::LocalElectricField = typedef cvec2;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-map","title":"typedef Map","text":"<pre><code>using rayx::Map = typedef std::unordered_map&lt;std::string, std::shared_ptr&lt;DesignMap&gt; &gt;;\n</code></pre> <p>This Map is the foundation for the DesignELement ad DesignSource All Parameter are defined by a string set in DesignElement.cpp and a Value. The Value describes the possible Types. It is defined as a shared pointer because of the recursive call. </p>"},{"location":"rayxCore/namespacerayx/#enum-material","title":"enum Material","text":"<pre><code>enum rayx::Material {\n    REFLECTIVE = -2,\n    VACUUM = -1,\n    X\n};\n</code></pre> <p>This enum class is the c++ perspective on the Materials stored in \"materials.xmacro\". Whenever you want to add a material, just add a line in materials.xmacro: everything else is done automagically. This makes heavy use of X Macros, see https://en.wikipedia.org/wiki/X_Macro </p>"},{"location":"rayxCore/namespacerayx/#typedef-optbuf","title":"typedef OptBuf","text":"<pre><code>using rayx::OptBuf = typedef std::optional&lt;alpaka::Buf&lt;Acc, T, alpaka::DimInt&lt;1&gt;, int32_t&gt; &gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-optcollisionpoint","title":"typedef OptCollisionPoint","text":"<pre><code>using rayx::OptCollisionPoint = typedef std::optional&lt;CollisionPoint&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-optcollisionwithelement","title":"typedef OptCollisionWithElement","text":"<pre><code>using rayx::OptCollisionWithElement = typedef std::optional&lt;CollisionWithElement&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-paraboloidtype","title":"enum ParaboloidType","text":"<pre><code>enum rayx::ParaboloidType {\n    Focussing,\n    Collimate\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-rzptype","title":"enum RZPType","text":"<pre><code>enum rayx::RZPType {\n    Elliptical,\n    Meriodional\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-randcounter","title":"typedef RandCounter","text":"<p>Internal type for the random counter-based RNG. <pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::RandCounter;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#enum-sequential","title":"enum Sequential","text":"<pre><code>enum rayx::Sequential {\n    No,\n    Yes\n};\n</code></pre> <p>Expresses whether we force sequential tracing, or we use dynamic tracing. We prefer this over a boolean, as calling eg. the trace function with an argument of <code>true</code> has no obvious meaning. On the other hand calling it with <code>Sequential::Yes</code> makes the meaning more clear. </p>"},{"location":"rayxCore/namespacerayx/#enum-sigmatype","title":"enum SigmaType","text":"<pre><code>enum rayx::SigmaType {\n    ST_STANDARD,\n    ST_ACCURATE\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-sourcedist","title":"enum SourceDist","text":"<pre><code>enum rayx::SourceDist {\n    Uniform,\n    Gaussian,\n    Thirds,\n    Circle\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-sourcepulsetype","title":"enum SourcePulseType","text":"<pre><code>enum rayx::SourcePulseType {\n    None\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-spreadtype","title":"enum SpreadType","text":"<pre><code>enum rayx::SpreadType {\n    HardEdge,\n    SoftEdge,\n    SeparateEnergies\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-stokes","title":"typedef Stokes","text":"<pre><code>using rayx::Stokes = typedef glm::dvec4;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-surface","title":"typedef Surface","text":"<pre><code>using rayx::Surface = typedef Variant&lt;detail::SurfaceTypes, detail::SurfaceTypes::Plane, detail::SurfaceTypes::Quadric, detail::SurfaceTypes::Toroid, detail::SurfaceTypes::Cubic&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-surfacecoatingtype","title":"enum SurfaceCoatingType","text":"<pre><code>enum rayx::SurfaceCoatingType {\n    SubstrateOnly,\n    OneCoating,\n    MultipleCoatings\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-toroidtype","title":"enum ToroidType","text":"<pre><code>enum rayx::ToroidType {\n    Convex,\n    Concave\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#enum-valuetype","title":"enum ValueType","text":"<pre><code>enum rayx::ValueType {\n    Undefined,\n    Double,\n    Int,\n    String,\n    Map,\n    Dvec4,\n    Dmat4x4,\n    Bool,\n    Rad,\n    Material,\n    CentralBeamstop,\n    Cutout,\n    CutoutType,\n    EventType,\n    CylinderDirection,\n    FigureRotation,\n    CurvatureType,\n    Surface,\n    SourceDist,\n    SpreadType,\n    EnergyDistributionType,\n    EnergySpreadUnit,\n    ElectronEnergyOrientation,\n    SigmaType,\n    BehaviourType,\n    ElementType,\n    GratingMount,\n    CrystalType,\n    DesignPlane,\n    SurfaceCoatingType,\n    RayList\n};\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-cmat3","title":"typedef cmat3","text":"<pre><code>using rayx::cmat3 = typedef glm::tmat3x3&lt;complex::Complex&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-cvec2","title":"typedef cvec2","text":"<pre><code>using rayx::cvec2 = typedef glm::tvec2&lt;complex::Complex&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#typedef-cvec3","title":"typedef cvec3","text":"<pre><code>using rayx::cvec3 = typedef glm::tvec3&lt;complex::Complex&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/namespacerayx/#variable-all","title":"variable All","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::All;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-bench_flag","title":"variable BENCH_FLAG","text":"<pre><code>bool RAYX_API rayx::BENCH_FLAG;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-behaviourtypetostring","title":"variable BehaviourTypeToString","text":"<pre><code>const std::map&lt;BehaviourType, std::string&gt; rayx::BehaviourTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-centralbeamstoptostring","title":"variable CentralBeamstopToString","text":"<pre><code>const std::map&lt;CentralBeamstop, std::string&gt; rayx::CentralBeamstopToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-curvaturetypetostring","title":"variable CurvatureTypeToString","text":"<pre><code>const std::map&lt;CurvatureType, std::string&gt; rayx::CurvatureTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-cutouttypetostring","title":"variable CutoutTypeToString","text":"<pre><code>const std::map&lt;CutoutType, std::string&gt; rayx::CutoutTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-default_batch_size","title":"variable DEFAULT_BATCH_SIZE","text":"<pre><code>constexpr int rayx::DEFAULT_BATCH_SIZE;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-direction","title":"variable Direction","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::Direction;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-directionx","title":"variable DirectionX","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::DirectionX;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-directiony","title":"variable DirectionY","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::DirectionY;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-directionz","title":"variable DirectionZ","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::DirectionZ;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-electric_permitivity_multiplies_speed_of_light","title":"variable ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT","text":"<p>electric permitivity multiplied by speed of light <pre><code>constexpr double rayx::ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-electric_permittivity","title":"variable ELECTRIC_PERMITTIVITY","text":"<p>\\(\\epsilon_0\\) [As/Vm]. vacuum electric permittivity. <pre><code>constexpr double rayx::ELECTRIC_PERMITTIVITY;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-electron_mass","title":"variable ELECTRON_MASS","text":"<p>m_e [kg]. electron mass. <pre><code>constexpr double rayx::ELECTRON_MASS;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-electron_radius","title":"variable ELECTRON_RADIUS","text":"<pre><code>constexpr double rayx::ELECTRON_RADIUS;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-electron_volt","title":"variable ELECTRON_VOLT","text":"<p>eV_J ElectronVolt to Joule. <pre><code>constexpr double rayx::ELECTRON_VOLT;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-elementary_charge","title":"variable ELEMENTARY_CHARGE","text":"<p>e_0 [As]. elementary charge. <pre><code>constexpr double rayx::ELEMENTARY_CHARGE;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-electricfieldx","title":"variable ElectricFieldX","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::ElectricFieldX;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-electricfieldy","title":"variable ElectricFieldY","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::ElectricFieldY;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-electricfieldz","title":"variable ElectricFieldZ","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::ElectricFieldZ;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-electronenergyorientationtostring","title":"variable ElectronEnergyOrientationToString","text":"<pre><code>const std::map&lt;ElectronEnergyOrientation, std::string&gt; rayx::ElectronEnergyOrientationToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-elementtypetostring","title":"variable ElementTypeToString","text":"<pre><code>const std::map&lt;ElementType, std::string&gt; rayx::ElementTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-energy","title":"variable Energy","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::Energy;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-energydistributiontypetostring","title":"variable EnergyDistributionTypeToString","text":"<pre><code>const std::map&lt;EnergyDistributionType, std::string&gt; rayx::EnergyDistributionTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-energyspreadunittostring","title":"variable EnergySpreadUnitToString","text":"<pre><code>const std::map&lt;EnergySpreadUnit, std::string&gt; rayx::EnergySpreadUnitToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-eventtype","title":"variable EventType","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::EventType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-eventtypetostring","title":"variable EventTypeToString","text":"<pre><code>const std::map&lt;EventType, std::string&gt; rayx::EventTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-factor_electron_energy_sc","title":"variable FACTOR_ELECTRON_ENERGY_SC","text":"<p>RAY-UI shortcut for getFactorElectronEnergy. <pre><code>constexpr double rayx::FACTOR_ELECTRON_ENERGY_SC;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-factor_schwinger_ray","title":"variable FACTOR_SCHWINGER_RAY","text":"<p>\\(G\\) [?]. RAY's factor appearing in Schwinger equation context <pre><code>constexpr double rayx::FACTOR_SCHWINGER_RAY;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-fine_structure_constant","title":"variable FINE_STRUCTURE_CONSTANT","text":"<pre><code>constexpr double rayx::FINE_STRUCTURE_CONSTANT;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-fixed_seed","title":"variable FIXED_SEED","text":"<pre><code>const uint32_t rayx::FIXED_SEED;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-figurerotationtostring","title":"variable FigureRotationToString","text":"<pre><code>const std::map&lt;FigureRotation, std::string&gt; rayx::FigureRotationToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-gratingmounttostring","title":"variable GratingMountToString","text":"<pre><code>const std::map&lt;GratingMount, std::string&gt; rayx::GratingMountToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-inv_nm_to_evolt","title":"variable INV_NM_TO_EVOLT","text":"<p>inverse nanometer-electron volt relationship / reziprocal factor <pre><code>constexpr double rayx::INV_NM_TO_EVOLT;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-it_astigmatic2astigmatic","title":"variable IT_ASTIGMATIC2ASTIGMATIC","text":"<pre><code>constexpr int rayx::IT_ASTIGMATIC2ASTIGMATIC;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-it_point2horizontal_divergent_line","title":"variable IT_POINT2HORIZONTAL_DIVERGENT_LINE","text":"<pre><code>constexpr int rayx::IT_POINT2HORIZONTAL_DIVERGENT_LINE;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-it_point2horizontal_line","title":"variable IT_POINT2HORIZONTAL_LINE","text":"<pre><code>constexpr int rayx::IT_POINT2HORIZONTAL_LINE;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-it_point2point","title":"variable IT_POINT2POINT","text":"<pre><code>constexpr int rayx::IT_POINT2POINT;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-materialtostring","title":"variable MaterialToString","text":"<pre><code>const std::map&lt;Material, std::string&gt; rayx::MaterialToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-none","title":"variable None","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::None;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-objectid","title":"variable ObjectId","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::ObjectId;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-opticalpathlength","title":"variable OpticalPathLength","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::OpticalPathLength;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-order","title":"variable Order","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::Order;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-pi","title":"variable PI","text":"<pre><code>constexpr double rayx::PI;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-planck","title":"variable PLANCK","text":"<pre><code>constexpr double rayx::PLANCK;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-planck_bar","title":"variable PLANCK_BAR","text":"<p>\\(\\hbar\\) [Js]. Planck's bar constant. <pre><code>constexpr double rayx::PLANCK_BAR;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-paraboloidtypetostring","title":"variable ParaboloidTypeToString","text":"<pre><code>const std::map&lt;ParaboloidType, std::string&gt; rayx::ParaboloidTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-patheventid","title":"variable PathEventId","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::PathEventId;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-position","title":"variable Position","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::Position;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-positionx","title":"variable PositionX","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::PositionX;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-positiony","title":"variable PositionY","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::PositionY;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-positionz","title":"variable PositionZ","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::PositionZ;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-rzptypetostring","title":"variable RZPTypeToString","text":"<pre><code>const std::map&lt;RZPType, std::string&gt; rayx::RZPTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-rayattrmask","title":"variable RayAttrMask","text":"<p>Mask to specify ray attributes. Each attribute is represented as a bit flag, allowing for efficient combination and checking of multiple attributes. It is used to represent the various attributes that can be recorded for rays during ray tracing. <pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::RayAttrMask;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-rayattrmaskcount","title":"variable RayAttrMaskCount","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::RayAttrMaskCount;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-speed_of_light","title":"variable SPEED_OF_LIGHT","text":"<p>c_0 [m/s]. speed of light in vacuum. <pre><code>constexpr double rayx::SPEED_OF_LIGHT;\n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#variable-sigmatypetostring","title":"variable SigmaTypeToString","text":"<pre><code>const std::map&lt;SigmaType, std::string&gt; rayx::SigmaTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-sourcedisttostring","title":"variable SourceDistToString","text":"<pre><code>const std::map&lt;SourceDist, std::string&gt; rayx::SourceDistToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-sourceid","title":"variable SourceId","text":"<pre><code>RAYX_X_MACRO_RAY_ATTR enum RAYX_API rayx::SourceId;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-spreadtypetostring","title":"variable SpreadTypeToString","text":"<pre><code>const std::map&lt;SpreadType, std::string&gt; rayx::SpreadTypeToString;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtobehaviourtype","title":"variable StringToBehaviourType","text":"<pre><code>const std::map&lt;std::string, BehaviourType&gt; rayx::StringToBehaviourType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtocentralbeamstop","title":"variable StringToCentralBeamstop","text":"<pre><code>const std::map&lt;std::string, CentralBeamstop&gt; rayx::StringToCentralBeamstop;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtocurvaturetype","title":"variable StringToCurvatureType","text":"<pre><code>const std::map&lt;std::string, CurvatureType&gt; rayx::StringToCurvatureType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtocutouttype","title":"variable StringToCutoutType","text":"<pre><code>const std::map&lt;std::string, CutoutType&gt; rayx::StringToCutoutType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoelectronenergyorientation","title":"variable StringToElectronEnergyOrientation","text":"<pre><code>const std::map&lt;std::string, ElectronEnergyOrientation&gt; rayx::StringToElectronEnergyOrientation;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoelementtype","title":"variable StringToElementType","text":"<pre><code>const std::map&lt;std::string, ElementType&gt; rayx::StringToElementType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoenergydistributiontype","title":"variable StringToEnergyDistributionType","text":"<pre><code>const std::map&lt;std::string, EnergyDistributionType&gt; rayx::StringToEnergyDistributionType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoenergyspreadunit","title":"variable StringToEnergySpreadUnit","text":"<pre><code>const std::map&lt;std::string, EnergySpreadUnit&gt; rayx::StringToEnergySpreadUnit;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoeventtype","title":"variable StringToEventType","text":"<pre><code>const std::map&lt;std::string, EventType&gt; rayx::StringToEventType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtofigurerotation","title":"variable StringToFigureRotation","text":"<pre><code>const std::map&lt;std::string, FigureRotation&gt; rayx::StringToFigureRotation;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtogratingmount","title":"variable StringToGratingMount","text":"<pre><code>const std::map&lt;std::string, GratingMount&gt; rayx::StringToGratingMount;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtomaterial","title":"variable StringToMaterial","text":"<pre><code>const std::map&lt;std::string, Material&gt; rayx::StringToMaterial;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtoparaboloidtype","title":"variable StringToParaboloidType","text":"<pre><code>const std::map&lt;std::string, ParaboloidType&gt; rayx::StringToParaboloidType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtorzptype","title":"variable StringToRZPType","text":"<pre><code>const std::map&lt;std::string, RZPType&gt; rayx::StringToRZPType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtosigmatype","title":"variable StringToSigmaType","text":"<pre><code>const std::map&lt;std::string, SigmaType&gt; rayx::StringToSigmaType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtosourcedist","title":"variable StringToSourceDist","text":"<pre><code>const std::map&lt;std::string, SourceDist&gt; rayx::StringToSourceDist;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-stringtospreadtype","title":"variable StringToSpreadType","text":"<pre><code>const std::map&lt;std::string, SpreadType&gt; rayx::StringToSpreadType;\n</code></pre>"},{"location":"rayxCore/namespacerayx/#variable-error_fn","title":"variable error_fn","text":"<pre><code>void RAYX_API(* rayx::error_fn) ();\n</code></pre>"},{"location":"rayxCore/namespacerayx/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/namespacerayx/#function-rzplinedensity","title":"function RZPLineDensity","text":"<pre><code>RAYX_FN_ACC void RAYX_API rayx::RZPLineDensity (\n    const glm::dvec3 &amp;__restrict position,\n    const glm::dvec3 &amp;__restrict normal,\n    const Behaviour::RZP &amp;__restrict b,\n    double &amp;__restrict DX,\n    double &amp;__restrict DZ\n) \n</code></pre> <p>calculates DX and DZ (line spacing in x and z direction) at a given point for a given direction on the grating @params: lots </p> <p>Returns:</p> <p>: (inplace) DX, DZ </p>"},{"location":"rayxCore/namespacerayx/#function-advanceelectricfield","title":"function advanceElectricField","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::advanceElectricField (\n    const ElectricField field,\n    double waveLength,\n    const double opticalPathLength\n) \n</code></pre> <p>Advances an electric field propagating along a given optical path length. </p> <p>Parameters:</p> <ul> <li><code>field</code> Electric field of incident photon </li> <li><code>waveLength</code> Wavelength of incident photon (in nanometers) </li> <li><code>opticalPathLength</code> Optical path length traveled (in millimeters) </li> </ul> <p>Returns:</p> <p>Advanced electric field </p>"},{"location":"rayxCore/namespacerayx/#function-allocbuf","title":"function allocBuf","text":"<pre><code>template&lt;typename Queue, typename Buf&gt;\ninline void rayx::allocBuf (\n    Queue q,\n    std::optional&lt; Buf &gt; &amp; buf,\n    const int size\n) \n</code></pre> <p>conditionally allocate buffer with specified minimum size. if the buffer already fulfills size requirements, this function does nothing. this function never shrinks a buffer. actual allocation size is nextPowerOfTwo(size). this function is designed to optimize the repetitive use of the buffer with potentially different size requirements (e.g. tracing multiple beamlines one after the other) </p>"},{"location":"rayxCore/namespacerayx/#function-allocraysbuf","title":"function allocRaysBuf","text":"<pre><code>template&lt;typename Queue, typename Acc&gt;\ninline void rayx::allocRaysBuf (\n    Queue q,\n    const RayAttrMask attrMask,\n    RaysBuf &lt; Acc &gt; &amp; raysBuf,\n    const int size\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-anglebetweenunitvectors","title":"function angleBetweenUnitVectors","text":"<p>calculates the angle in rad, between two unit vectors <pre><code>inline RAYX_FN_ACC double rayx::angleBetweenUnitVectors (\n    glm::dvec3 a,\n    glm::dvec3 b\n) \n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#function-appendh5","title":"function appendH5","text":"<pre><code>RAYX_API void rayx::appendH5 (\n    const std::filesystem::path &amp; filepath,\n    const Rays &amp; rays,\n    const RayAttrMask attr=RayAttrMask::All\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-applyslopeerror","title":"function applySlopeError","text":"<pre><code>RAYX_FN_ACC glm::dvec3 rayx::applySlopeError (\n    glm::dvec3 normal,\n    SlopeError error,\n    int O_type,\n    Rand &amp;__restrict rand\n) \n</code></pre> <p>adds slope error to the normal @params: normal: normal vector error: the slope error to apply O_type: cartesian or cylindrical type of slope error (0=cartesian, 1=cylindrical) (1 only for ellipsis relevant) returns new normal if there is a slope error in either x or z direction or the unmodified normal otherwise. </p>"},{"location":"rayxCore/namespacerayx/#function-assertcutoutsubset","title":"function assertCutoutSubset","text":"<pre><code>RAYX_FN_ACC void RAYX_API rayx::assertCutoutSubset (\n    Cutout c1,\n    Cutout c2\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behave","title":"function behave","text":"<pre><code>RAYX_FN_ACC void rayx::behave (\n    detail::Ray &amp;__restrict ray,\n    const CollisionPoint &amp;__restrict col,\n    const OpticalElement &amp;__restrict element,\n    const int *__restrict materialIndices,\n    const double *__restrict materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behavecrystal","title":"function behaveCrystal","text":"<pre><code>RAYX_FN_ACC void rayx::behaveCrystal (\n    detail::Ray &amp;__restrict ray,\n    const Behaviour::Crystal &amp;__restrict crystal,\n    const CollisionPoint &amp;__restrict col\n) \n</code></pre> <p>Each <code>behave*</code> function gets a <code>Ray ray</code> (in element-coords), the element itself, a randomness counter and the <code>Collision col</code>. <code>col.hitpoint</code> expresses where the given ray will hit the element (in element-coords). <code>col.normal</code> expresses the normal of the surface, at <code>col.hitpoint</code> (in element-coords). The ray has already been moved to the hitpoint, and it's lastElement has been set accordingly.</p> <p>The <code>behave*</code> functions, will * change the rays direction, typically by reflecting using the normal * change the rays stokes vector * potentially absorb the ray (by calling <code>recordFinalEvent(_, EventType::Absorbed)</code>) </p>"},{"location":"rayxCore/namespacerayx/#function-behavefoil","title":"function behaveFoil","text":"<pre><code>RAYX_FN_ACC void rayx::behaveFoil (\n    detail::Ray &amp;__restrict ray,\n    const Behaviour::Foil &amp;__restrict foil,\n    const CollisionPoint &amp;__restrict col,\n    int material,\n    const int *__restrict materialIndices,\n    const double *__restrict materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behavegrating","title":"function behaveGrating","text":"<pre><code>RAYX_FN_ACC void rayx::behaveGrating (\n    detail::Ray &amp;__restrict ray,\n    const Behaviour::Grating &amp;__restrict grating,\n    const CollisionPoint &amp;__restrict col\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behaveimageplane","title":"function behaveImagePlane","text":"<pre><code>RAYX_FN_ACC void rayx::behaveImagePlane (\n    detail::Ray &amp;__restrict ray\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behavemirror","title":"function behaveMirror","text":"<pre><code>RAYX_FN_ACC void rayx::behaveMirror (\n    detail::Ray &amp;__restrict ray,\n    const CollisionPoint &amp;__restrict col,\n    const Coating &amp;__restrict coating,\n    int material,\n    const int *__restrict materialIndices,\n    const double *__restrict materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behaverzp","title":"function behaveRZP","text":"<pre><code>RAYX_FN_ACC void rayx::behaveRZP (\n    detail::Ray &amp;__restrict ray,\n    const Behaviour::RZP &amp;__restrict rzp,\n    const CollisionPoint &amp;__restrict col\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-behaveslit","title":"function behaveSlit","text":"<pre><code>RAYX_FN_ACC void rayx::behaveSlit (\n    detail::Ray &amp;__restrict ray,\n    const Behaviour::Slit &amp;__restrict slit\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-bessel1","title":"function bessel1","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::bessel1 (\n    double v\n) \n</code></pre> <p>returns first bessel function of parameter v </p>"},{"location":"rayxCore/namespacerayx/#function-bessel_diff","title":"function bessel_diff","text":"<pre><code>RAYX_FN_ACC void rayx::bessel_diff (\n    double radius,\n    double wl,\n    double &amp; dphi,\n    double &amp; dpsi,\n    Rand &amp; rand\n) \n</code></pre> <p>calculates the Bessel diffraction effects on circular slits and on circular zoneplates @params: radius radius &lt; 0 (mm) wl wavelength (nm) dphi, dpsi angles of diffracted ray </p> <p>Returns:</p> <p>results stored in dphi, dpsi (inout) </p>"},{"location":"rayxCore/namespacerayx/#function-calcbrewstersangle","title":"function calcBrewstersAngle","text":"<pre><code>inline RAYX_FN_ACC complex::Complex rayx::calcBrewstersAngle (\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calccriticalangle","title":"function calcCriticalAngle","text":"<pre><code>inline RAYX_FN_ACC complex::Complex rayx::calcCriticalAngle (\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcdipolefold","title":"function calcDipoleFold","text":"<pre><code>RAYX_API RAYX_FN_ACC PsiAndStokes rayx::calcDipoleFold (\n    double psi,\n    double photonEnergy,\n    double sigpsi,\n    double electronEnergy,\n    double criticalEnergy,\n    ElectronEnergyOrientation electronEnergyOrientation,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcgamma","title":"function calcGamma","text":"<pre><code>RAYX_API double rayx::calcGamma (\n    double electronEnergy\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcjonesmatrix","title":"function calcJonesMatrix","text":"<pre><code>inline RAYX_FN_ACC cmat3 rayx::calcJonesMatrix (\n    const ComplexFresnelCoeffs amplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcmaxflux","title":"function calcMaxFlux","text":"<pre><code>RAYX_API double rayx::calcMaxFlux (\n    double photonEnergy,\n    double energySpread,\n    double criticalEnergy,\n    double gamma\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcmaxintensity","title":"function calcMaxIntensity","text":"<pre><code>RAYX_API double rayx::calcMaxIntensity (\n    double photonEnergy,\n    double verDivergence,\n    double electronEnergy,\n    double criticalEnergy,\n    ElectronEnergyOrientation electronEnergyOrientation,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcpolaririzationmatrix","title":"function calcPolaririzationMatrix","text":"<pre><code>inline RAYX_FN_ACC cmat3 rayx::calcPolaririzationMatrix (\n    const glm::dvec3 incidentVec,\n    const glm::dvec3 reflectOrRefractVec,\n    const glm::dvec3 normalVec,\n    const ComplexFresnelCoeffs amplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcpolaririzationmatrixfoil","title":"function calcPolaririzationMatrixFoil","text":"<pre><code>inline RAYX_FN_ACC cmat3 rayx::calcPolaririzationMatrixFoil (\n    const glm::dvec3 incidentVec,\n    const glm::dvec3 normalVec,\n    const ComplexFresnelCoeffs amplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcreflectamplitude","title":"function calcReflectAmplitude","text":"<pre><code>inline RAYX_FN_ACC ComplexFresnelCoeffs rayx::calcReflectAmplitude (\n    const complex::Complex incidentAngle,\n    const complex::Complex refractAngle,\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcreflectintensity","title":"function calcReflectIntensity","text":"<pre><code>inline RAYX_FN_ACC FresnelCoeffs rayx::calcReflectIntensity (\n    const ComplexFresnelCoeffs reflectAmplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcreflectpolarizationmatrixatnormalincidence","title":"function calcReflectPolarizationMatrixAtNormalIncidence","text":"<pre><code>inline RAYX_FN_ACC cmat3 rayx::calcReflectPolarizationMatrixAtNormalIncidence (\n    const ComplexFresnelCoeffs amplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcrefractamplitude","title":"function calcRefractAmplitude","text":"<pre><code>inline RAYX_FN_ACC ComplexFresnelCoeffs rayx::calcRefractAmplitude (\n    const complex::Complex incidentAngle,\n    const complex::Complex refractAngle,\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcrefractangle","title":"function calcRefractAngle","text":"<pre><code>inline RAYX_FN_ACC complex::Complex rayx::calcRefractAngle (\n    const complex::Complex incidentAngle,\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcrefractintensity","title":"function calcRefractIntensity","text":"<pre><code>inline RAYX_FN_ACC FresnelCoeffs rayx::calcRefractIntensity (\n    const ComplexFresnelCoeffs refract_amplitude,\n    const complex::Complex incidentAngle,\n    const complex::Complex refractAngle,\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calctransformationmatrices","title":"function calcTransformationMatrices","text":"<pre><code>RAYX_API glm::dmat4 rayx::calcTransformationMatrices (\n    glm::dvec4 position,\n    glm::dmat4 orientation,\n    bool calcInMatrix,\n    DesignPlane plane\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-calcverdivergence","title":"function calcVerDivergence","text":"<pre><code>RAYX_API double rayx::calcVerDivergence (\n    double energy,\n    double sigv,\n    double electronEnergy,\n    double criticalEnergy\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-canonicalizerepositorypath","title":"function canonicalizeRepositoryPath","text":"<pre><code>std::filesystem::path RAYX_API rayx::canonicalizeRepositoryPath (\n    const std::filesystem::path &amp; relPath\n) \n</code></pre> <p><code>relPath</code> is a path relative to the root of the RAY-X git repository (i.e. where .git lies). canonicalizeRepositoryPath(relPath) yields an absolute path representing the same path. Examples: * canonicalizeRepositoryPath(/home/username/foo) = /home/username/foo # absolute paths are unchanged! * canonicalizeRepositoryPath(build/bin/python) = /home/username/path/to/RAY-X/build/bin/python * canonicalizeRepositoryPath(Tests/input) = /home/username/path/to/RAY-X/Tests/input </p>"},{"location":"rayxCore/namespacerayx/#function-canonicalizeuserpath","title":"function canonicalizeUserPath","text":"<pre><code>std::filesystem::path RAYX_API rayx::canonicalizeUserPath (\n    const std::filesystem::path &amp; relPath\n) \n</code></pre> <p><code>relPath</code> is a path relative to the working directory of the user executing RAY-X at the point of execution. canonicalizeUserPath(relPath) yields an absolute path representing the same path. Examples: * canonicalizeUserPath(/home/username/file) = /home/username/file # absolute paths are unchanged! * if you are at /home/username/folder, then canonicalizeUserPath(file) = /home/username/folder/file</p> <p>This function is used to find the correct path when the user executes <code>./TerminalApp -i &lt;relPath&gt;</code> </p>"},{"location":"rayxCore/namespacerayx/#function-ceilintdivision","title":"function ceilIntDivision","text":"<pre><code>inline int rayx::ceilIntDivision (\n    const int dividend,\n    const int divisor\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-computeeta","title":"function computeEta","text":"<p>Computes the normalized angular deviation parameter \u03b7 (Eta) for dynamical X-ray diffraction. <pre><code>inline RAYX_FN_ACC complex::Complex rayx::computeEta (\n    double theta,\n    double bragg,\n    double asymmetry,\n    double structureFactorReFH,\n    double structureFactorImFH,\n    double structureFactorReFHC,\n    double structureFactorImFHC,\n    double structureFactorReF0,\n    double structureFactorImF0,\n    double polFactor,\n    double gamma\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>theta</code> Angle of incidence relative to the crystal surface (radians) </li> <li><code>bragg</code> Bragg angle (radians) </li> <li><code>asymmetry</code> Asymmetry factor </li> <li><code>structureFactorReFH</code> Real part of structure factor </li> <li><code>structureFactorImFH</code> Imaginary part of structure factor </li> <li><code>structureFactorReFHC</code> Real part of structure factor </li> <li><code>structureFactorImFHC</code> Imaginary part of structure factor </li> <li><code>structureFactorReF0</code> Real part of structure factor </li> <li><code>structureFactorImF0</code> Imaginary part of structure factor </li> <li><code>polFactor</code> Polarization factor </li> <li><code>gamma</code> Diffraction prefactor </li> </ul> <p>Returns:</p> <p>Complex \u03b7 parameter </p>"},{"location":"rayxCore/namespacerayx/#function-computemultilayerreflectance","title":"function computeMultilayerReflectance","text":"<pre><code>inline RAYX_FN_ACC ComplexFresnelCoeffs rayx::computeMultilayerReflectance (\n    const complex::Complex incidentAngle,\n    const double wavelength,\n    int numLayers,\n    const double *__restrict thicknesses,\n    const complex::Complex *__restrict iors\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-computer","title":"function computeR","text":"<p>Computes the reflection coefficient R based on eta This function is based on Equation (103) from Batterman &amp; Cole (1964), p. 706,. <pre><code>inline RAYX_FN_ACC complex::Complex rayx::computeR (\n    complex::Complex eta,\n    double structureFactorReFH,\n    double structureFactorImFH,\n    double structureFactorReFHC,\n    double structureFactorImFHC\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>eta</code> Complex deviation parameter </li> <li><code>structureFactorReFH</code> Real part of structure factor </li> <li><code>structureFactorImFH</code> Imaginary part of structure factor </li> <li><code>structureFactorReFHC</code> Real part of structure factor </li> <li><code>structureFactorImFHC</code> Imaginary part of structure factor </li> </ul> <p>Returns:</p> <p>Complex reflection coefficient R </p>"},{"location":"rayxCore/namespacerayx/#function-computesinglecoatingreflectance","title":"function computeSingleCoatingReflectance","text":"<pre><code>inline RAYX_FN_ACC ComplexFresnelCoeffs rayx::computeSingleCoatingReflectance (\n    const complex::Complex incidentAngle,\n    const double wavelength,\n    const double thickness,\n    const complex::Complex iorI,\n    const complex::Complex iorC,\n    const complex::Complex iorS\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-computetransmittance","title":"function computeTransmittance","text":"<p>Calculates the transmission through a single thin film layer using Fresnel equations. <pre><code>inline RAYX_FN_ACC ComplexFresnelCoeffs rayx::computeTransmittance (\n    double wavelength,\n    complex::Complex theta0,\n    const complex::Complex &amp; indexVacuum,\n    const complex::Complex &amp; indexMaterial,\n    double thickness\n) \n</code></pre></p> <p>This function computes the intensity transmission coefficient (T) for a plane wave incident on a single dielectric or absorbing film, including interference effects.</p> <p>Parameters:</p> <ul> <li><code>wavelength</code> Wavelength of light in nanometers. </li> <li><code>thickness</code> Thickness of the film in nanometers. </li> <li><code>n0</code> Complex refractive index of the incident medium (vakuum). </li> <li><code>n1</code> Complex refractive index of the film layer. </li> <li><code>incidentAngleRad</code> Angle of incidence in radians (from normal). </li> </ul> <p>Returns:</p> <p>double Intensity transmission coefficient (range 0 to 1). </p>"},{"location":"rayxCore/namespacerayx/#function-contains","title":"function contains","text":"<p>Check if a RayAttrMask (haystack) contains another RayAttrMask (needle). <pre><code>inline RAYX_API RAYX_FN_ACC constexpr bool rayx::contains (\n    const RayAttrMask haystack,\n    const RayAttrMask needle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>haystack</code> The RayAttrMask to check. </li> <li><code>needle</code> The RayAttrMask to look for. </li> </ul> <p>Returns:</p> <p>True if the haystack contains the needle, false otherwise. </p> <p>Note:</p> <p>When repeatedly checking on the same haystack, this function should be preferred over Rays::contains. </p>"},{"location":"rayxCore/namespacerayx/#function-countsetbits","title":"function countSetBits","text":"<p>Count the number of set bits (i.e., attributes) in a RayAttrMask. <pre><code>RAYX_API int rayx::countSetBits (\n    const RayAttrMask mask\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> The RayAttrMask to count the set bits in. </li> </ul> <p>Returns:</p> <p>The number of set bits in the RayAttrMask. </p>"},{"location":"rayxCore/namespacerayx/#function-cubicdirection","title":"function cubicDirection","text":"<pre><code>RAYX_FN_ACC glm::dvec3 RAYX_API rayx::cubicDirection (\n    const glm::dvec3 &amp;__restrict rayDirection,\n    double alph\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-cubicposition","title":"function cubicPosition","text":"<pre><code>RAYX_FN_ACC glm::dvec3 RAYX_API rayx::cubicPosition (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const double alpha\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-cutoutboundingbox","title":"function cutoutBoundingBox","text":"<pre><code>RAYX_FN_ACC glm::dvec2 RAYX_API rayx::cutoutBoundingBox (\n    Cutout cutout\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-dbg","title":"function dbg","text":"<pre><code>void rayx::dbg (\n    const std::string &amp; filename,\n    int line,\n    std::string name,\n    std::vector&lt; double &gt; v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-defaultmaxevents","title":"function defaultMaxEvents","text":"<pre><code>constexpr int rayx::defaultMaxEvents (\n    const int numObjects\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-degreeofpolarization","title":"function degreeOfPolarization","text":"<pre><code>inline RAYX_FN_ACC double rayx::degreeOfPolarization (\n    const Stokes stokes\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-dipolebessel","title":"function dipoleBessel","text":"<pre><code>RAYX_API RAYX_FN_ACC double rayx::dipoleBessel (\n    double hnue,\n    double zeta\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-directiontosphericalcoords","title":"function directionToSphericalCoords","text":"<pre><code>RAYX_FN_ACC void RAYX_API rayx::directionToSphericalCoords (\n    glm::dvec3 direction,\n    double &amp; out_phi,\n    double &amp; out_psi\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-dpow","title":"function dpow","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::dpow (\n    double a,\n    int b\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-electricfieldtostokes","title":"function electricFieldToStokes","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::electricFieldToStokes (\n    const ElectricField field,\n    const glm::dvec3 forward,\n    const glm::dvec3 up\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-electricfieldtostokes_1","title":"function electricFieldToStokes","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::electricFieldToStokes (\n    const ElectricField field,\n    const glm::dmat3 rotation\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-electricfieldtostokeswithbaseconvention","title":"function electricFieldToStokesWithBaseConvention","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::electricFieldToStokesWithBaseConvention (\n    const ElectricField field,\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-energytowavelength","title":"function energyToWaveLength","text":"<pre><code>inline RAYX_FN_ACC double RAYX_API rayx::energyToWaveLength (\n    double x\n) \n</code></pre> <p>converts energy (eV) to wavelength (nm) </p> <p>Parameters:</p> <ul> <li><code>energy</code> energy of a photon in eV. must not be 0 </li> </ul> <p>Returns:</p> <p>wavelength of photon in nm </p>"},{"location":"rayxCore/namespacerayx/#function-eventtypetomask","title":"function eventTypeToMask","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::eventTypeToMask (\n    const EventType eventType\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-exclude","title":"function exclude","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask rayx::exclude (\n    const RayAttrMask haystack,\n    const RayAttrMask needle\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-execwithvalidworkdiv","title":"function execWithValidWorkDiv","text":"<pre><code>template&lt;typename Acc, typename DevAcc, typename Queue, typename Kernel, typename... Args&gt;\ninline void rayx::execWithValidWorkDiv (\n    DevAcc devAcc,\n    Queue q,\n    const int numElements,\n    BlockSizeConstraint::Variant blockSizeConstraint,\n    const Kernel &amp; kernel,\n    Args &amp;&amp;... args\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-fact","title":"function fact","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::fact (\n    int n\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-findcollisioninelementcoords","title":"function findCollisionInElementCoords","text":"<pre><code>RAYX_FN_ACC OptCollisionPoint rayx::findCollisionInElementCoords (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const OpticalElement &amp;__restrict element,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-findcollisioninelementcoordswithoutslopeerror","title":"function findCollisionInElementCoordsWithoutSlopeError","text":"<pre><code>RAYX_FN_ACC OptCollisionPoint RAYX_API rayx::findCollisionInElementCoordsWithoutSlopeError (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const Surface &amp;__restrict surface,\n    const Cutout &amp;__restrict cutout,\n    bool isTriangul\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-findcollisionwithelements","title":"function findCollisionWithElements","text":"<pre><code>RAYX_FN_ACC OptCollisionWithElement rayx::findCollisionWithElements (\n    glm::dvec3 rayPosition,\n    glm::dvec3 rayDirection,\n    const OpticalElement *__restrict elements,\n    const ObjectTransform * __restrict,\n    const int numSources,\n    const int numElements,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-fixseed","title":"function fixSeed","text":"<pre><code>void RAYX_API rayx::fixSeed (\n    uint32_t x\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec","title":"function formatAsVec","text":"<pre><code>template&lt;typename T&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec (\n    T\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_1","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    int arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_2","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    RandCounter arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_3","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    EventType arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_4","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    double arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_5","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    complex::Complex arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_6","title":"function formatAsVec","text":"<pre><code>template&lt;int N, int M, typename T&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec (\n    const glm::mat&lt; N, M, T &gt; arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_7","title":"function formatAsVec","text":"<pre><code>template&lt;int N, typename T&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec (\n    const glm::vec&lt; N, T &gt; arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_8","title":"function formatAsVec","text":"<pre><code>template&lt;size_t N, typename T&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec (\n    const std::array&lt; T, N &gt; arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_9","title":"function formatAsVec","text":"<pre><code>template&lt;typename T&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec (\n    const std::vector&lt; T &gt; arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec_10","title":"function formatAsVec","text":"<pre><code>inline std::vector&lt; double &gt; rayx::formatAsVec (\n    const Rays &amp; rays\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-formatasvec-double","title":"function formatAsVec&lt; double &gt;","text":"<pre><code>template&lt;&gt;\ninline std::vector&lt; double &gt; rayx::formatAsVec&lt; double &gt; (\n    const std::vector&lt; double &gt; arg\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-forwardvectortobaseconvention","title":"function forwardVectorToBaseConvention","text":"<pre><code>inline RAYX_FN_ACC RotationBase rayx::forwardVectorToBaseConvention (\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-fraun_diff","title":"function fraun_diff","text":"<pre><code>RAYX_FN_ACC void rayx::fraun_diff (\n    double dim,\n    double wl,\n    double &amp; dAngle,\n    Rand &amp; rand\n) \n</code></pre> <p>calculates fraunhofer diffraction effects on rectangular slits </p> <p>Parameters:</p> <ul> <li><code>dim</code> dimension (x or y) (mm) </li> <li><code>wl</code> wavelength (nm) </li> <li><code>dAngle</code> diffraction angle (inout) </li> </ul> <p>Returns:</p> <p>result stored in dAngle </p>"},{"location":"rayxCore/namespacerayx/#function-getasymmetryfactor","title":"function getAsymmetryFactor","text":"<p>Computes the asymmetry factor b from the Bragg angle and surface tilt angle. <pre><code>inline RAYX_FN_ACC double rayx::getAsymmetryFactor (\n    double braggAngle,\n    double alpha\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>braggAngle</code> Bragg angle \u03b8_B (in radians) </li> <li><code>alpha</code> Tilt between surface and diffraction planes \u03b1 (in radians) (offset Angle) </li> </ul> <p>Returns:</p> <p>Asymmetry factor b (dimensionless) </p>"},{"location":"rayxCore/namespacerayx/#function-getatomicmassandrho","title":"function getAtomicMassAndRho","text":"<pre><code>RAYX_FN_ACC glm::dvec2 RAYX_API rayx::getAtomicMassAndRho (\n    int material\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getblocksize","title":"function getBlockSize","text":"<pre><code>template&lt;typename Acc&gt;\ninline constexpr auto rayx::getBlockSize () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getbraggangle","title":"function getBraggAngle","text":"<p>Computes the bragg angle. <pre><code>inline RAYX_FN_ACC double rayx::getBraggAngle (\n    double energy,\n    double dSpacing2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>energy</code> photonenergy of the ray </li> <li><code>d</code> lattice spacing*2 </li> <li><code>order</code> Diffraction order </li> </ul> <p>Returns:</p> <p>the bragg angle theta (rad) </p>"},{"location":"rayxCore/namespacerayx/#function-getcone","title":"function getCone","text":"<pre><code>void rayx::getCone (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getcrystal","title":"function getCrystal","text":"<pre><code>void rayx::getCrystal (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getcubiccollision","title":"function getCubicCollision","text":"<pre><code>RAYX_FN_ACC OptCollisionPoint rayx::getCubicCollision (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const Surface::Cubic &amp;__restrict cu\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getcylinder","title":"function getCylinder","text":"<pre><code>void rayx::getCylinder (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getdebugverbose","title":"function getDebugVerbose","text":"<pre><code>bool RAYX_API rayx::getDebugVerbose () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getdiffractionprefactor","title":"function getDiffractionPrefactor","text":"<p>Computes the diffraction prefactor \u0393 used in dynamical X-ray diffraction theory. Defined in Batterman &amp; Cole (1964), p. 685. <pre><code>inline RAYX_FN_ACC double rayx::getDiffractionPrefactor (\n    double wavelength,\n    double unitCellVolume\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>wavelength</code> X-ray wavelength (in nm) </li> <li><code>unitCellVolume</code> Unit cell volume (in nm\u00b3) </li> </ul> <p>Returns:</p> <p>Diffraction prefactor \u0393 </p>"},{"location":"rayxCore/namespacerayx/#function-getdipoleinterpolation","title":"function getDipoleInterpolation","text":"<pre><code>RAYX_API RAYX_FN_ACC double rayx::getDipoleInterpolation (\n    double energy\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getellipsoid","title":"function getEllipsoid","text":"<pre><code>void rayx::getEllipsoid (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getexpertscubic","title":"function getExpertsCubic","text":"<pre><code>void rayx::getExpertsCubic (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getexpertsoptics","title":"function getExpertsOptics","text":"<pre><code>void rayx::getExpertsOptics (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getfoil","title":"function getFoil","text":"<pre><code>void rayx::getFoil (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getgrating","title":"function getGrating","text":"<pre><code>void rayx::getGrating (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getimageplane","title":"function getImageplane","text":"<pre><code>void rayx::getImageplane (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getnffentry","title":"function getNffEntry","text":"<pre><code>RAYX_FN_ACC NffEntry RAYX_API rayx::getNffEntry (\n    int index,\n    int material,\n    const int * materialIndices,\n    const double * materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getnffentrycount","title":"function getNffEntryCount","text":"<pre><code>RAYX_FN_ACC int RAYX_API rayx::getNffEntryCount (\n    int material,\n    const int * materialIndices\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getpalikentry","title":"function getPalikEntry","text":"<pre><code>RAYX_FN_ACC PalikEntry RAYX_API rayx::getPalikEntry (\n    int index,\n    int material,\n    const int * materialIndices,\n    const double * materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getpalikentrycount","title":"function getPalikEntryCount","text":"<pre><code>RAYX_FN_ACC int RAYX_API rayx::getPalikEntryCount (\n    int material,\n    const int * materialIndices\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getparaboloid","title":"function getParaboloid","text":"<pre><code>void rayx::getParaboloid (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getplanegrating","title":"function getPlaneGrating","text":"<pre><code>void rayx::getPlaneGrating (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getplanemirror","title":"function getPlaneMirror","text":"<pre><code>void rayx::getPlaneMirror (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getquadriccollision","title":"function getQuadricCollision","text":"<pre><code>RAYX_FN_ACC OptCollisionPoint rayx::getQuadricCollision (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const Surface::Quadric &amp;__restrict quadric\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getrzp","title":"function getRZP","text":"<pre><code>void rayx::getRZP (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getrayattrnames","title":"function getRayAttrNames","text":"<p>Get a list of all possible ray attribute names. <pre><code>RAYX_API std::vector&lt; std::string &gt; rayx::getRayAttrNames () \n</code></pre></p> <p>Returns:</p> <p>A vector of strings containing all possible ray attribute names. </p>"},{"location":"rayxCore/namespacerayx/#function-getrecordindex","title":"function getRecordIndex","text":"<pre><code>inline RAYX_FN_ACC int rayx::getRecordIndex (\n    const int gid,\n    const int numRecorded,\n    const int gridStride\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getrefractiveindex","title":"function getRefractiveIndex","text":"<pre><code>RAYX_FN_ACC complex::Complex RAYX_API rayx::getRefractiveIndex (\n    double energy,\n    int material,\n    const int * materialIndices,\n    const double * materialTable\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getslit","title":"function getSlit","text":"<pre><code>void rayx::getSlit (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getspheregrating","title":"function getSphereGrating","text":"<pre><code>void rayx::getSphereGrating (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getspheremirror","title":"function getSphereMirror","text":"<pre><code>void rayx::getSphereMirror (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getstokessyn","title":"function getStokesSyn","text":"<pre><code>RAYX_API RAYX_FN_ACC glm::dvec4 rayx::getStokesSyn (\n    double energy,\n    double psi1,\n    double psi2,\n    double electronEnergy,\n    double criticalEnergy,\n    ElectronEnergyOrientation electronEnergyOrientation\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getsurfacecoating","title":"function getSurfaceCoating","text":"<pre><code>void rayx::getSurfaceCoating (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre> <p>Set all Parameters for each optical Element a RML file can define. Set all mandatory parameters is called for every element without exception. This only works in combi with the xml parser. </p>"},{"location":"rayxCore/namespacerayx/#function-gettheta","title":"function getTheta","text":"<pre><code>inline RAYX_FN_ACC double rayx::getTheta (\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const glm::dvec3 &amp;__restrict normal,\n    double offsetAngle\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-gettoroidcollision","title":"function getToroidCollision","text":"<pre><code>RAYX_FN_ACC OptCollisionPoint rayx::getToroidCollision (\n    const glm::dvec3 &amp;__restrict rayPosition,\n    const glm::dvec3 &amp;__restrict rayDirection,\n    const Surface::Toroid &amp;__restrict toroid,\n    bool isTriangul\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-gettoroidmirror","title":"function getToroidMirror","text":"<pre><code>void rayx::getToroidMirror (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-gettoroidalgrating","title":"function getToroidalGrating","text":"<pre><code>void rayx::getToroidalGrating (\n    xml::Parser parser,\n    DesignElement * de\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-getworkdivforacc","title":"function getWorkDivForAcc","text":"<pre><code>template&lt;typename Acc&gt;\ninline auto rayx::getWorkDivForAcc (\n    alpaka::Idx&lt; Acc &gt; numElements\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-get_factorcriticalenergy","title":"function get_factorCriticalEnergy","text":"<pre><code>RAYX_API double rayx::get_factorCriticalEnergy () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-get_factorelectronenergy","title":"function get_factorElectronEnergy","text":"<pre><code>RAYX_API double rayx::get_factorElectronEnergy () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-get_factoromega","title":"function get_factorOmega","text":"<pre><code>RAYX_API double rayx::get_factorOmega () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-globaltolocalelectricfield","title":"function globalToLocalElectricField","text":"<pre><code>inline RAYX_FN_ACC LocalElectricField rayx::globalToLocalElectricField (\n    const ElectricField field,\n    const glm::dvec3 forward,\n    const glm::dvec3 up\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-globaltolocalelectricfield_1","title":"function globalToLocalElectricField","text":"<pre><code>inline RAYX_FN_ACC LocalElectricField rayx::globalToLocalElectricField (\n    const ElectricField field,\n    const glm::dmat3 rotation\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-globaltolocalelectricfieldwithbaseconvention","title":"function globalToLocalElectricFieldWithBaseConvention","text":"<pre><code>inline RAYX_FN_ACC LocalElectricField rayx::globalToLocalElectricFieldWithBaseConvention (\n    const ElectricField field,\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-importbeamline","title":"function importBeamline","text":"<pre><code>RAYX_API Beamline rayx::importBeamline (\n    const std::filesystem::path &amp;\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-incutout","title":"function inCutout","text":"<pre><code>RAYX_FN_ACC bool RAYX_API rayx::inCutout (\n    Cutout cutout,\n    double x,\n    double z\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-intensity","title":"function intensity","text":"<pre><code>inline RAYX_FN_ACC double rayx::intensity (\n    const LocalElectricField field\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-intensity_1","title":"function intensity","text":"<pre><code>inline RAYX_FN_ACC double rayx::intensity (\n    const ElectricField field\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-intensity_2","title":"function intensity","text":"<pre><code>inline RAYX_FN_ACC double rayx::intensity (\n    const Stokes stokes\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-interceptfoil","title":"function interceptFoil","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::interceptFoil (\n    const ElectricField incidentElectricField,\n    const glm::dvec3 incidentVec,\n    const glm::dvec3 normalVec,\n    ComplexFresnelCoeffs transCoeffs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-interceptreflect","title":"function interceptReflect","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::interceptReflect (\n    const ElectricField incidentElectricField,\n    const glm::dvec3 incidentVec,\n    const glm::dvec3 reflectVec,\n    const glm::dvec3 normalVec,\n    const complex::Complex iorI,\n    const complex::Complex iorT\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-interceptreflectcrystal","title":"function interceptReflectCrystal","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::interceptReflectCrystal (\n    const ElectricField incidentElectricField,\n    const glm::dvec3 incidentVec,\n    const glm::dvec3 reflectVec,\n    const glm::dvec3 normalVec,\n    ComplexFresnelCoeffs reflectAmplitude\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-isflag","title":"function isFlag","text":"<p>Check if a RayAttrMask represents a single attribute (i.e., is a flag). <pre><code>RAYX_API bool rayx::isFlag (\n    const RayAttrMask attr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>attr</code> The RayAttrMask to check. </li> </ul> <p>Returns:</p> <p>True if the RayAttrMask represents a single attribute, false otherwise. </p>"},{"location":"rayxCore/namespacerayx/#function-israyterminated","title":"function isRayTerminated","text":"<pre><code>inline RAYX_FN_ACC bool rayx::isRayTerminated (\n    const EventType eventType\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-keycutoutpoints","title":"function keyCutoutPoints","text":"<pre><code>RAYX_FN_ACC glm::dmat4 RAYX_API rayx::keyCutoutPoints (\n    Cutout cutout\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-loadmaterialtables","title":"function loadMaterialTables","text":"<pre><code>MaterialTables RAYX_API rayx::loadMaterialTables (\n    std::array&lt; bool, 92 &gt; relevantMaterials\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-loadray","title":"function loadRay","text":"<pre><code>inline RAYX_FN_ACC detail::Ray rayx::loadRay (\n    const int i,\n    const RaysPtr &amp;__restrict rays\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-localelectricfieldtostokes","title":"function localElectricFieldToStokes","text":"<pre><code>inline RAYX_FN_ACC Stokes rayx::localElectricFieldToStokes (\n    const LocalElectricField field\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-localtoglobalelectricfield","title":"function localToGlobalElectricField","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::localToGlobalElectricField (\n    const LocalElectricField localField,\n    const glm::dvec3 forward,\n    const glm::dvec3 up\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-localtoglobalelectricfield_1","title":"function localToGlobalElectricField","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::localToGlobalElectricField (\n    const LocalElectricField localField,\n    const glm::dmat3 rotation\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-localtoglobalelectricfieldwithbaseconvention","title":"function localToGlobalElectricFieldWithBaseConvention","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::localToGlobalElectricFieldWithBaseConvention (\n    const LocalElectricField localField,\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makebehaviour","title":"function makeBehaviour","text":"<pre><code>Behaviour rayx::makeBehaviour (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makecone","title":"function makeCone","text":"<pre><code>Surface rayx::makeCone (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makecrystal","title":"function makeCrystal","text":"<pre><code>Behaviour rayx::makeCrystal (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makecubic","title":"function makeCubic","text":"<pre><code>Surface rayx::makeCubic (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makecylinder","title":"function makeCylinder","text":"<pre><code>Surface rayx::makeCylinder (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makeelement","title":"function makeElement","text":"<pre><code>OpticalElementAndTransform rayx::makeElement (\n    const DesignElement &amp; dele,\n    Behaviour behaviour,\n    Surface surface,\n    DesignPlane plane=DesignPlane::XZ,\n    std::optional&lt; Cutout &gt; cutout={}\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makeellipsoid","title":"function makeEllipsoid","text":"<pre><code>Surface rayx::makeEllipsoid (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makefoil","title":"function makeFoil","text":"<pre><code>Behaviour rayx::makeFoil (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makegrating","title":"function makeGrating","text":"<pre><code>Behaviour rayx::makeGrating (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makeparaboloid","title":"function makeParaboloid","text":"<pre><code>Surface rayx::makeParaboloid (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makeplane","title":"function makePlane","text":"<pre><code>Surface rayx::makePlane () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makequadric","title":"function makeQuadric","text":"<pre><code>Surface rayx::makeQuadric (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makerzpbehaviour","title":"function makeRZPBehaviour","text":"<pre><code>Behaviour rayx::makeRZPBehaviour (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makeslit","title":"function makeSlit","text":"<pre><code>Behaviour rayx::makeSlit (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makesphere","title":"function makeSphere","text":"<pre><code>Surface rayx::makeSphere (\n    double radius\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-makesurface","title":"function makeSurface","text":"<pre><code>Surface rayx::makeSurface (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-maketoroid","title":"function makeToroid","text":"<pre><code>Surface rayx::makeToroid (\n    const DesignElement &amp; dele\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-materialfromstring","title":"function materialFromString","text":"<pre><code>bool rayx::materialFromString (\n    const char * matname,\n    Material * out\n) \n</code></pre> <p>returns whether a Material with the name <code>matname</code> has been found. it will be stored in <code>out</code>. </p>"},{"location":"rayxCore/namespacerayx/#function-nextmultiple","title":"function nextMultiple","text":"<pre><code>inline int rayx::nextMultiple (\n    const int value,\n    const int divisor\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-nextpoweroftwo","title":"function nextPowerOfTwo","text":"<pre><code>inline int rayx::nextPowerOfTwo (\n    const int value\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-normalcartesian","title":"function normalCartesian","text":"<pre><code>RAYX_FN_ACC glm::dvec3 RAYX_API rayx::normalCartesian (\n    glm::dvec3 normal,\n    double x_rad,\n    double z_rad\n) \n</code></pre> <p>turn the normal vector through x_rad and z_rad @params: normal: the normal vector x_rad: angle in rad for x-axis z_rad: angle in rad for z-axis returns modified normal vector </p>"},{"location":"rayxCore/namespacerayx/#function-normalcylindrical","title":"function normalCylindrical","text":"<pre><code>RAYX_FN_ACC glm::dvec3 RAYX_API rayx::normalCylindrical (\n    glm::dvec3 normal,\n    double x_rad,\n    double z_rad\n) \n</code></pre> <p>turn the normal vector through x_rad and z_rad @params: normal: the normal vector x_rad: angle in rad for x-axis z_rad: angle in rad for z-axis returns modified normal vector </p>"},{"location":"rayxCore/namespacerayx/#function-operator","title":"function operator!","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr bool rayx::operator! (\n    const RayAttrMask lhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_1","title":"function operator!","text":"<pre><code>inline RAYX_FN_ACC constexpr bool rayx::operator! (\n    const EventTypeMask lhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_2","title":"function operator!=","text":"<pre><code>bool RAYX_API rayx::operator!= (\n    const Rays &amp; lhs,\n    const Rays &amp; rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_3","title":"function operator&amp;","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask rayx::operator&amp; (\n    const RayAttrMask lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_4","title":"function operator&amp;","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator&amp; (\n    const EventTypeMask lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_5","title":"function operator&amp;=","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; rayx::operator&amp;= (\n    RayAttrMask &amp; lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_6","title":"function operator&amp;=","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator&amp;= (\n    EventTypeMask &amp; lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_7","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const SpreadType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_8","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const EnergyDistributionType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_9","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const SourceDist v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_10","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ElectronEnergyOrientation v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_11","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const EnergySpreadUnit v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_12","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const RZPType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_13","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CentralBeamstop v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_14","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const GratingMount v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_15","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ParaboloidType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_16","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CurvatureType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_17","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const BehaviourType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_18","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const FigureRotation v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_19","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const SigmaType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_20","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const Material v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_21","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ElementType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_22","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const EventType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_23","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const CutoutType v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_24","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const complex::Complex &amp; c\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_25","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const glm::tvec2&lt; T &gt; &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_26","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const glm::tvec3&lt; T &gt; &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_27","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; rayx::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const glm::tvec4&lt; T &gt; &amp; v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_28","title":"function operator==","text":"<pre><code>bool RAYX_API rayx::operator== (\n    const Rays &amp; lhs,\n    const Rays &amp; rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_29","title":"function operator^","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask rayx::operator^ (\n    const RayAttrMask lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_30","title":"function operator^","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator^ (\n    const EventTypeMask lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_31","title":"function operator^=","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; rayx::operator^= (\n    RayAttrMask &amp; lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_32","title":"function operator^=","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator^= (\n    EventTypeMask &amp; lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_33","title":"function operator|","text":"<pre><code>inline RAYX_X_MACRO_RAY_ATTR enum RAYX_API RAYX_API RAYX_FN_ACC constexpr RayAttrMask rayx::operator| (\n    const RayAttrMask lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_34","title":"function operator|","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator| (\n    const EventTypeMask lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_35","title":"function operator|=","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask &amp; rayx::operator|= (\n    RayAttrMask &amp; lhs,\n    const RayAttrMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_36","title":"function operator|=","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator|= (\n    EventTypeMask &amp; lhs,\n    const EventTypeMask rhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_37","title":"function operator~","text":"<pre><code>inline RAYX_API RAYX_FN_ACC constexpr RayAttrMask rayx::operator~ (\n    const RayAttrMask lhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-operator_38","title":"function operator~","text":"<pre><code>inline RAYX_FN_ACC constexpr EventTypeMask rayx::operator~ (\n    const EventTypeMask lhs\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomdouble","title":"function randomDouble","text":"<pre><code>double RAYX_API rayx::randomDouble () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomdoubleinrange","title":"function randomDoubleInRange","text":"<pre><code>double RAYX_API rayx::randomDoubleInRange (\n    double a,\n    double b\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomintinrange","title":"function randomIntInRange","text":"<pre><code>int rayx::randomIntInRange (\n    int a,\n    int b\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomnormal","title":"function randomNormal","text":"<pre><code>double RAYX_API rayx::randomNormal (\n    double mean,\n    double stddev\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomseed","title":"function randomSeed","text":"<pre><code>void RAYX_API rayx::randomSeed () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-randomuint","title":"function randomUint","text":"<pre><code>uint32_t rayx::randomUint () \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-rayattrstringstorayattrmask","title":"function rayAttrStringsToRayAttrMask","text":"<p>Convert a list of ray attribute names to a RayAttrMask. <pre><code>RAYX_API RayAttrMask rayx::rayAttrStringsToRayAttrMask (\n    const std::vector&lt; std::string &gt; &amp; strings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>strings</code> A vector of strings containing ray attribute names. </li> </ul> <p>Returns:</p> <p>A RayAttrMask representing the specified attributes. </p>"},{"location":"rayxCore/namespacerayx/#function-raymatrixmult","title":"function rayMatrixMult","text":"<pre><code>inline RAYX_FN_ACC void RAYX_API rayx::rayMatrixMult (\n    const glm::dmat4 &amp;__restrict m,\n    glm::dvec3 &amp;__restrict rayPosition,\n    glm::dvec3 &amp;__restrict rayDirection\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-raymatrixmult_1","title":"function rayMatrixMult","text":"<pre><code>inline RAYX_FN_ACC void RAYX_API rayx::rayMatrixMult (\n    const glm::dmat4 &amp;__restrict m,\n    glm::dvec3 &amp;__restrict rayPosition,\n    glm::dvec3 &amp;__restrict rayDirection,\n    ElectricField &amp;__restrict rayElectricField\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-raysbuftoraysptr","title":"function raysBufToRaysPtr","text":"<pre><code>template&lt;typename Acc&gt;\nRaysPtr rayx::raysBufToRaysPtr (\n    RaysBuf &lt; Acc &gt; &amp; buf\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-readcsv","title":"function readCsv","text":"<pre><code>Rays RAYX_API rayx::readCsv (\n    const std::filesystem::path &amp; filepath\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-readfile","title":"function readFile","text":"<pre><code>std::optional&lt; std::vector&lt; uint8_t &gt; &gt; RAYX_API rayx::readFile (\n    const std::string &amp; filename,\n    const uint32_t count=0\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-readfilealign32","title":"function readFileAlign32","text":"<pre><code>std::optional&lt; std::vector&lt; uint32_t &gt; &gt; rayx::readFileAlign32 (\n    const std::string &amp; filename,\n    const uint32_t count=0\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-readh5objectnames","title":"function readH5ObjectNames","text":"<pre><code>RAYX_API std::vector&lt; std::string &gt; rayx::readH5ObjectNames (\n    const std::filesystem::path &amp; filepath\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-readh5rays","title":"function readH5Rays","text":"<pre><code>RAYX_API Rays rayx::readH5Rays (\n    const std::filesystem::path &amp; filepath,\n    const RayAttrMask attr=RayAttrMask::All\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-refrac2d","title":"function refrac2D","text":"<pre><code>RAYX_FN_ACC void rayx::refrac2D (\n    detail::Ray &amp;__restrict ray,\n    glm::dvec3 normal,\n    double az,\n    double ax\n) \n</code></pre> <p>calculates refracted ray @params: ray: Ray normal: normal at intersection point of ray and element -&gt; for planes normal is always the same (0,1,0) -&gt; no need to rotate but we do anyways. az: linedensity in z direction ax: linedensity in x direction </p> <p>Returns:</p> <p>: refracted ray (position unchanged, direction changed), weight = EventType::BeyondHorizon if \"ray beyond horizon\" </p>"},{"location":"rayxCore/namespacerayx/#function-refract_dvec3","title":"function refract_dvec3","text":"<pre><code>RAYX_FN_ACC glm::dvec3 rayx::refract_dvec3 (\n    glm::dvec3 I,\n    glm::dvec3 N,\n    double eta\n) \n</code></pre> <p>Simple refraction for double precision vectors @params: I: incident vector N: normal vector at the point of intersection eta: ratio of refractive indices (n1/n2) </p> <p>Returns:</p> <p>: refracted vector, or zero vector if total internal reflection occurs </p>"},{"location":"rayxCore/namespacerayx/#function-rotationmatrix","title":"function rotationMatrix","text":"<pre><code>inline RAYX_FN_ACC glm::dmat3 rayx::rotationMatrix (\n    const glm::dvec3 forward,\n    const glm::dvec3 up\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-rotationmatrixwithbaseconvention","title":"function rotationMatrixWithBaseConvention","text":"<pre><code>inline RAYX_FN_ACC glm::dmat3 rayx::rotationMatrixWithBaseConvention (\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-schwinger","title":"function schwinger","text":"<p>calculate probability for chosen energy with edge-cases according to H.Wiedemann Synchrotron Radiation P. 259 (D.21) <pre><code>RAYX_API RAYX_FN_ACC double rayx::schwinger (\n    double energy,\n    double gamma,\n    double criticalEnergy\n) \n</code></pre></p>"},{"location":"rayxCore/namespacerayx/#function-selectenergy","title":"function selectEnergy","text":"<pre><code>RAYX_FN_ACC double rayx::selectEnergy (\n    const HardEdge &amp;__restrict hardEdge,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-selectenergy_1","title":"function selectEnergy","text":"<pre><code>RAYX_FN_ACC double rayx::selectEnergy (\n    const SoftEdge &amp;__restrict softEdge,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-selectenergy_2","title":"function selectEnergy","text":"<pre><code>RAYX_FN_ACC double rayx::selectEnergy (\n    const SeparateEnergies &amp;__restrict separateEnergies,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-selectenergy_3","title":"function selectEnergy","text":"<pre><code>RAYX_FN_ACC double rayx::selectEnergy (\n    const EnergyDistributionList &amp;__restrict energyDistributionList,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-selectenergy_4","title":"function selectEnergy","text":"<pre><code>RAYX_FN_ACC double rayx::selectEnergy (\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setallmandatory","title":"function setAllMandatory","text":"<pre><code>void rayx::setAllMandatory (\n    xml::Parser parser,\n    DesignElement * de,\n    DesignPlane dp\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setallmandatory_1","title":"function setAllMandatory","text":"<pre><code>void rayx::setAllMandatory (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setcirclesource","title":"function setCircleSource","text":"<pre><code>void rayx::setCircleSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setdebugverbose","title":"function setDebugVerbose","text":"<pre><code>void RAYX_API rayx::setDebugVerbose (\n    bool\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setdefaultenergy","title":"function setDefaultEnergy","text":"<pre><code>void rayx::setDefaultEnergy (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setdefaultorientation","title":"function setDefaultOrientation","text":"<pre><code>void rayx::setDefaultOrientation (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setdefaultposition","title":"function setDefaultPosition","text":"<pre><code>void rayx::setDefaultPosition (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setdipolesource","title":"function setDipoleSource","text":"<pre><code>void rayx::setDipoleSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setmatrixsource","title":"function setMatrixSource","text":"<pre><code>void rayx::setMatrixSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setpixelsource","title":"function setPixelSource","text":"<pre><code>void rayx::setPixelSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setpointsource","title":"function setPointSource","text":"<pre><code>void rayx::setPointSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setsimpleundulatorsource","title":"function setSimpleUndulatorSource","text":"<pre><code>void rayx::setSimpleUndulatorSource (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-setstokes","title":"function setStokes","text":"<pre><code>void rayx::setStokes (\n    xml::Parser parser,\n    DesignSource * ds\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-sphericalcoordstodirection","title":"function sphericalCoordsToDirection","text":"<pre><code>RAYX_FN_ACC void RAYX_API rayx::sphericalCoordsToDirection (\n    double phi,\n    double psi,\n    glm::dvec3 &amp; out_direction\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-squares64","title":"function squares64","text":"<pre><code>RAYX_FN_ACC RandCounter RAYX_API rayx::squares64 (\n    RandCounter &amp; ctr\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-squaresdoublerng","title":"function squaresDoubleRNG","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::squaresDoubleRNG (\n    RandCounter &amp; ctr\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-squaresnormalrng","title":"function squaresNormalRNG","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::squaresNormalRNG (\n    RandCounter &amp; ctr,\n    double mu,\n    double sigma\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-stokestoelectricfield","title":"function stokesToElectricField","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::stokesToElectricField (\n    const Stokes stokes,\n    const glm::dvec3 forward,\n    const glm::dvec3 up\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-stokestoelectricfield_1","title":"function stokesToElectricField","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::stokesToElectricField (\n    const Stokes stokes,\n    const glm::dmat3 rotation\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-stokestoelectricfieldwithbaseconvention","title":"function stokesToElectricFieldWithBaseConvention","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::stokesToElectricFieldWithBaseConvention (\n    const Stokes stokes,\n    const glm::dvec3 forward\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-stokestolocalelectricfield","title":"function stokesToLocalElectricField","text":"<pre><code>inline RAYX_FN_ACC LocalElectricField rayx::stokesToLocalElectricField (\n    const Stokes stokes\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-storeray","title":"function storeRay","text":"<pre><code>inline RAYX_FN_ACC void rayx::storeRay (\n    const int i,\n    RaysPtr &amp;__restrict rays,\n    const detail::Ray &amp;__restrict ray\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-storeray_1","title":"function storeRay","text":"<pre><code>inline RAYX_FN_ACC bool rayx::storeRay (\n    const int i,\n    bool *__restrict storedFlags,\n    RaysPtr &amp;__restrict rays,\n    detail::Ray &amp;__restrict ray,\n    const bool *__restrict objectRecordMask,\n    const int objectIndex,\n    const RayAttrMask attrRecordMask\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-streamenum","title":"function streamEnum","text":"<pre><code>template&lt;typename Enum&gt;\nstd::ostream &amp; rayx::streamEnum (\n    std::ostream &amp; os,\n    const Enum value,\n    const std::map&lt; Enum, std::string &gt; &amp; toStringMap\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-terminateray","title":"function terminateRay","text":"<pre><code>inline RAYX_FN_ACC void rayx::terminateRay (\n    EventType &amp;__restrict dstEventType,\n    const EventType srcEventType\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-to_string","title":"function to_string","text":"<pre><code>RAYX_API std::string rayx::to_string (\n    const RayAttrMask attr\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-tracenonsequential","title":"function traceNonSequential","text":"<pre><code>RAYX_FN_ACC void rayx::traceNonSequential (\n    const int gid,\n    const ConstState &amp;__restrict constState,\n    MutableState &amp;__restrict mutableState\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-tracesequential","title":"function traceSequential","text":"<pre><code>RAYX_FN_ACC void rayx::traceSequential (\n    const int gid,\n    const ConstState &amp;__restrict constState,\n    MutableState &amp;__restrict mutableState\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-vlsgrating","title":"function vlsGrating","text":"<pre><code>RAYX_FN_ACC double RAYX_API rayx::vlsGrating (\n    double lineDensity,\n    glm::dvec3 normal,\n    double z,\n    const double vls\n) \n</code></pre> <p>variable line spacing for gratings @params lineDensity: general line density? z: z-coordinate of ray position vls[6]: 6 vls parameters given by user </p> <p>Returns:</p> <p>line density specifically for this z-coordinate </p>"},{"location":"rayxCore/namespacerayx/#function-wavelengthtoenergy","title":"function waveLengthToEnergy","text":"<pre><code>inline RAYX_FN_ACC double rayx::waveLengthToEnergy (\n    const double waveLength\n) \n</code></pre> <p>Convert photon wavelength (nm) to energy (eV) </p> <p>Parameters:</p> <ul> <li><code>wavelength</code> of photon in nm. must not be 0 </li> </ul> <p>Returns:</p> <p>energy energy of a photon in eV </p>"},{"location":"rayxCore/namespacerayx/#function-writecsv","title":"function writeCsv","text":"<pre><code>void RAYX_API rayx::writeCsv (\n    const std::filesystem::path &amp; filepath,\n    const Rays &amp; rays\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-writefile","title":"function writeFile","text":"<pre><code>void RAYX_API rayx::writeFile (\n    const std::vector&lt; uint8_t &gt; &amp; data,\n    const std::string &amp; filename,\n    const uint32_t count=0\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx/#function-writeh5","title":"function writeH5","text":"<pre><code>RAYX_API void rayx::writeH5 (\n    const std::filesystem::path &amp; filepath,\n    const std::vector&lt; std::string &gt; &amp; object_names,\n    const Rays &amp; rays,\n    const RayAttrMask attr=RayAttrMask::All,\n    const bool overwrite=true\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Angle.h</code></p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/","title":"Class rayx::BeamlineNode","text":"<p>ClassList &gt; rayx &gt; BeamlineNode</p> <p>Base class for all nodes in the beamline hierarchy (scene/model graph). More...</p> <ul> <li><code>#include &lt;Node.h&gt;</code></li> </ul> <p>Inherited by the following classes: rayx::DesignElement,  rayx::DesignSource,  rayx::Group</p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#public-functions","title":"Public Functions","text":"Type Name const DesignElement * asElement () const DesignElement * asElement ()  const Group * asGroup () const Group * asGroup ()  const DesignSource * asSource () const DesignSource * asSource ()  virtual std::unique_ptr&lt; BeamlineNode &gt; clone () const = 0Creates a deep copy (clone) of this BeamlineNode . virtual std::string getName () const = 0 int getObjectId () const virtual glm::dmat4 getOrientation () const = 0Gets the local orientation (rotation/transform) of this node. const BeamlineNode * getParent () const BeamlineNode * getParent ()  virtual glm::dvec4 getPosition () const = 0Gets the local position of this node. const BeamlineNode * getRoot () const BeamlineNode * getRoot ()  glm::dmat4 getWorldOrientation () constComputes the absolute/world orientation of this node. glm::dvec4 getWorldPosition () constComputes the absolute/world position of this node. bool hasParent () const virtual bool isElement () const virtual bool isGroup () const virtual bool isSource () const virtual const BeamlineNode * operator[] (size_t index) const virtual BeamlineNode * operator[] (size_t index)  virtual const BeamlineNode * operator[] (const std::string &amp; name) const virtual BeamlineNode * operator[] (const std::string &amp; name)  virtual void setName (std::string name) = 0 virtual ~BeamlineNode () = default"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#detailed-description","title":"Detailed Description","text":"<p>This abstract class defines the common interface for any node in a beamline. Nodes can be groups, elements, or sources, each providing their own logic for position/orientation and potential child relationships. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-aselement-12","title":"function asElement [1/2]","text":"<pre><code>const DesignElement * rayx::BeamlineNode::asElement () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-aselement-22","title":"function asElement [2/2]","text":"<pre><code>DesignElement * rayx::BeamlineNode::asElement () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-asgroup-12","title":"function asGroup [1/2]","text":"<pre><code>const Group * rayx::BeamlineNode::asGroup () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-asgroup-22","title":"function asGroup [2/2]","text":"<pre><code>Group * rayx::BeamlineNode::asGroup () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-assource-12","title":"function asSource [1/2]","text":"<pre><code>const DesignSource * rayx::BeamlineNode::asSource () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-assource-22","title":"function asSource [2/2]","text":"<pre><code>DesignSource * rayx::BeamlineNode::asSource () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-clone","title":"function clone","text":"<p>Creates a deep copy (clone) of this BeamlineNode . <pre><code>virtual std::unique_ptr&lt; BeamlineNode &gt; rayx::BeamlineNode::clone () const = 0\n</code></pre></p> <p>Derived classes must implement this to allow duplication of their internal state. </p> <p>Returns:</p> <p>A unique_ptr to the newly cloned BeamlineNode. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getname","title":"function getName","text":"<pre><code>virtual std::string rayx::BeamlineNode::getName () const = 0\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getobjectid","title":"function getObjectId","text":"<pre><code>int rayx::BeamlineNode::getObjectId () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getorientation","title":"function getOrientation","text":"<p>Gets the local orientation (rotation/transform) of this node. <pre><code>virtual glm::dmat4 rayx::BeamlineNode::getOrientation () const = 0\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the local orientation. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getparent-12","title":"function getParent [1/2]","text":"<pre><code>inline const BeamlineNode * rayx::BeamlineNode::getParent () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getparent-22","title":"function getParent [2/2]","text":"<pre><code>inline BeamlineNode * rayx::BeamlineNode::getParent () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getposition","title":"function getPosition","text":"<p>Gets the local position of this node. <pre><code>virtual glm::dvec4 rayx::BeamlineNode::getPosition () const = 0\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4D vector (dvec4) representing the local position. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getroot-12","title":"function getRoot [1/2]","text":"<pre><code>const BeamlineNode * rayx::BeamlineNode::getRoot () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getroot-22","title":"function getRoot [2/2]","text":"<pre><code>BeamlineNode * rayx::BeamlineNode::getRoot () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getworldorientation","title":"function getWorldOrientation","text":"<p>Computes the absolute/world orientation of this node. <pre><code>glm::dmat4 rayx::BeamlineNode::getWorldOrientation () const\n</code></pre></p> <p>Recursively multiplies the parent's world orientation by the node's local orientation. If there is no parent, the local orientation is already in world space. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the orientation in world coordinates. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-getworldposition","title":"function getWorldPosition","text":"<p>Computes the absolute/world position of this node. <pre><code>glm::dvec4 rayx::BeamlineNode::getWorldPosition () const\n</code></pre></p> <p>Recursively applies parent transformations until the root of the hierarchy is reached. If there is no parent, the local position is already in world space. </p> <p>Returns:</p> <p>A 4D vector (dvec4) representing the position in world coordinates. </p>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-hasparent","title":"function hasParent","text":"<pre><code>inline bool rayx::BeamlineNode::hasParent () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-iselement","title":"function isElement","text":"<pre><code>inline virtual bool rayx::BeamlineNode::isElement () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-isgroup","title":"function isGroup","text":"<pre><code>inline virtual bool rayx::BeamlineNode::isGroup () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-issource","title":"function isSource","text":"<pre><code>inline virtual bool rayx::BeamlineNode::isSource () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-operator","title":"function operator[]","text":"<pre><code>virtual const BeamlineNode * rayx::BeamlineNode::operator[] (\n    size_t index\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-operator_1","title":"function operator[]","text":"<pre><code>virtual BeamlineNode * rayx::BeamlineNode::operator[] (\n    size_t index\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-operator_2","title":"function operator[]","text":"<pre><code>virtual const BeamlineNode * rayx::BeamlineNode::operator[] (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-operator_3","title":"function operator[]","text":"<pre><code>virtual BeamlineNode * rayx::BeamlineNode::operator[] (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-setname","title":"function setName","text":"<pre><code>virtual void rayx::BeamlineNode::setName (\n    std::string name\n) = 0\n</code></pre>"},{"location":"rayxCore/classrayx_1_1BeamlineNode/#function-beamlinenode","title":"function ~BeamlineNode","text":"<pre><code>virtual rayx::BeamlineNode::~BeamlineNode () = default\n</code></pre> <p>Ensures proper cleanup of derived classes when deleting through a pointer to BeamlineNode. </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/Node.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1BlockSizeConstraint/","title":"Namespace rayx::BlockSizeConstraint","text":"<p>Namespace List &gt; rayx &gt; BlockSizeConstraint</p>"},{"location":"rayxCore/namespacerayx_1_1BlockSizeConstraint/#classes","title":"Classes","text":"Type Name struct AtLeast struct AtMost struct Exact struct InRange struct None"},{"location":"rayxCore/namespacerayx_1_1BlockSizeConstraint/#public-types","title":"Public Types","text":"Type Name typedef std::variant&lt; None, Exact, AtLeast, AtMost, InRange &gt; Variant"},{"location":"rayxCore/namespacerayx_1_1BlockSizeConstraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/namespacerayx_1_1BlockSizeConstraint/#typedef-variant","title":"typedef Variant","text":"<pre><code>using rayx::BlockSizeConstraint::Variant = typedef std::variant&lt;None, Exact, AtLeast, AtMost, InRange&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtLeast/","title":"Struct rayx::BlockSizeConstraint::AtLeast","text":"<p>ClassList &gt; rayx &gt; BlockSizeConstraint &gt; AtLeast</p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtLeast/#public-attributes","title":"Public Attributes","text":"Type Name int value"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtLeast/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtLeast/#variable-value","title":"variable value","text":"<pre><code>int rayx::BlockSizeConstraint::AtLeast::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtMost/","title":"Struct rayx::BlockSizeConstraint::AtMost","text":"<p>ClassList &gt; rayx &gt; BlockSizeConstraint &gt; AtMost</p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtMost/#public-attributes","title":"Public Attributes","text":"Type Name int value"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtMost/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1AtMost/#variable-value","title":"variable value","text":"<pre><code>int rayx::BlockSizeConstraint::AtMost::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1Exact/","title":"Struct rayx::BlockSizeConstraint::Exact","text":"<p>ClassList &gt; rayx &gt; BlockSizeConstraint &gt; Exact</p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1Exact/#public-attributes","title":"Public Attributes","text":"Type Name int value"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1Exact/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1Exact/#variable-value","title":"variable value","text":"<pre><code>int rayx::BlockSizeConstraint::Exact::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1InRange/","title":"Struct rayx::BlockSizeConstraint::InRange","text":"<p>ClassList &gt; rayx &gt; BlockSizeConstraint &gt; InRange</p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1InRange/#public-attributes","title":"Public Attributes","text":"Type Name int atLeast int atMost"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1InRange/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1InRange/#variable-atleast","title":"variable atLeast","text":"<pre><code>int rayx::BlockSizeConstraint::InRange::atLeast;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1InRange/#variable-atmost","title":"variable atMost","text":"<pre><code>int rayx::BlockSizeConstraint::InRange::atMost;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1BlockSizeConstraint_1_1None/","title":"Struct rayx::BlockSizeConstraint::None","text":"<p>ClassList &gt; rayx &gt; BlockSizeConstraint &gt; None</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/classrayx_1_1CircleSource/","title":"Class rayx::CircleSource","text":"<p>ClassList &gt; rayx &gt; CircleSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1CircleSource/#public-functions","title":"Public Functions","text":"Type Name CircleSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand) const RAYX_FN_ACC glm::dvec3 getDirection (Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1CircleSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1CircleSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1CircleSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1CircleSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1CircleSource/#function-circlesource","title":"function CircleSource","text":"<pre><code>rayx::CircleSource::CircleSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1CircleSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::CircleSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1CircleSource/#function-getdirection","title":"function getDirection","text":"<pre><code>RAYX_FN_ACC glm::dvec3 rayx::CircleSource::getDirection (\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/CircleSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1CollisionPoint/","title":"Struct rayx::CollisionPoint","text":"<p>ClassList &gt; rayx &gt; CollisionPoint</p>"},{"location":"rayxCore/structrayx_1_1CollisionPoint/#public-attributes","title":"Public Attributes","text":"Type Name glm::dvec3 hitpoint glm::dvec3 normal"},{"location":"rayxCore/structrayx_1_1CollisionPoint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1CollisionPoint/#variable-hitpoint","title":"variable hitpoint","text":"<pre><code>glm::dvec3 rayx::CollisionPoint::hitpoint;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1CollisionPoint/#variable-normal","title":"variable normal","text":"<pre><code>glm::dvec3 rayx::CollisionPoint::normal;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Collision.h</code></p>"},{"location":"rayxCore/structrayx_1_1CollisionWithElement/","title":"Struct rayx::CollisionWithElement","text":"<p>ClassList &gt; rayx &gt; CollisionWithElement</p>"},{"location":"rayxCore/structrayx_1_1CollisionWithElement/#public-attributes","title":"Public Attributes","text":"Type Name int elementIndex CollisionPoint point"},{"location":"rayxCore/structrayx_1_1CollisionWithElement/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1CollisionWithElement/#variable-elementindex","title":"variable elementIndex","text":"<pre><code>int rayx::CollisionWithElement::elementIndex;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1CollisionWithElement/#variable-point","title":"variable point","text":"<pre><code>CollisionPoint rayx::CollisionWithElement::point;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Collision.h</code></p>"},{"location":"rayxCore/structrayx_1_1ComplexFresnelCoeffs/","title":"Struct rayx::ComplexFresnelCoeffs","text":"<p>ClassList &gt; rayx &gt; ComplexFresnelCoeffs</p>"},{"location":"rayxCore/structrayx_1_1ComplexFresnelCoeffs/#public-attributes","title":"Public Attributes","text":"Type Name complex::Complex p complex::Complex s"},{"location":"rayxCore/structrayx_1_1ComplexFresnelCoeffs/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1ComplexFresnelCoeffs/#variable-p","title":"variable p","text":"<pre><code>complex::Complex rayx::ComplexFresnelCoeffs::p;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ComplexFresnelCoeffs/#variable-s","title":"variable s","text":"<pre><code>complex::Complex rayx::ComplexFresnelCoeffs::s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Efficiency.h</code></p>"},{"location":"rayxCore/structrayx_1_1ConstState/","title":"Struct rayx::ConstState","text":"<p>ClassList &gt; rayx &gt; ConstState</p> <p>stores all constant buffers </p> <ul> <li><code>#include &lt;InvocationState.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1ConstState/#public-attributes","title":"Public Attributes","text":"Type Name RayAttrMask attrRecordMask OpticalElement *__restrict elements int *__restrict materialIndices double *__restrict materialTable int maxEvents int numElements int numSources bool *__restrict objectRecordMask ObjectTransform *__restrict objectTransforms int outputEventsGridStride RaysPtr rays Sequential sequential   = <code>Sequential::No</code>"},{"location":"rayxCore/structrayx_1_1ConstState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1ConstState/#variable-attrrecordmask","title":"variable attrRecordMask","text":"<pre><code>RayAttrMask rayx::ConstState::attrRecordMask;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-elements","title":"variable elements","text":"<pre><code>OpticalElement* __restrict rayx::ConstState::elements;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-materialindices","title":"variable materialIndices","text":"<pre><code>int* __restrict rayx::ConstState::materialIndices;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-materialtable","title":"variable materialTable","text":"<pre><code>double* __restrict rayx::ConstState::materialTable;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-maxevents","title":"variable maxEvents","text":"<pre><code>int rayx::ConstState::maxEvents;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-numelements","title":"variable numElements","text":"<pre><code>int rayx::ConstState::numElements;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-numsources","title":"variable numSources","text":"<pre><code>int rayx::ConstState::numSources;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-objectrecordmask","title":"variable objectRecordMask","text":"<pre><code>bool* __restrict rayx::ConstState::objectRecordMask;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-objecttransforms","title":"variable objectTransforms","text":"<pre><code>ObjectTransform* __restrict rayx::ConstState::objectTransforms;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-outputeventsgridstride","title":"variable outputEventsGridStride","text":"<pre><code>int rayx::ConstState::outputEventsGridStride;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-rays","title":"variable rays","text":"<pre><code>RaysPtr rayx::ConstState::rays;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1ConstState/#variable-sequential","title":"variable sequential","text":"<pre><code>Sequential rayx::ConstState::sequential;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/InvocationState.h</code></p>"},{"location":"rayxCore/structrayx_1_1DatEntry/","title":"Struct rayx::DatEntry","text":"<p>ClassList &gt; rayx &gt; DatEntry</p> <p>More...</p> <ul> <li><code>#include &lt;DatFile.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1DatEntry/#public-attributes","title":"Public Attributes","text":"Type Name double m_energy double m_weight"},{"location":"rayxCore/structrayx_1_1DatEntry/#detailed-description","title":"Detailed Description","text":"<p>This struct represents one line of a .DAT file. </p>"},{"location":"rayxCore/structrayx_1_1DatEntry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1DatEntry/#variable-m_energy","title":"variable m_energy","text":"<pre><code>double rayx::DatEntry::m_energy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatEntry/#variable-m_weight","title":"variable m_weight","text":"<pre><code>double rayx::DatEntry::m_weight;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/DatFile.h</code></p>"},{"location":"rayxCore/structrayx_1_1DatFile/","title":"Struct rayx::DatFile","text":"<p>ClassList &gt; rayx &gt; DatFile</p> <p>More...</p> <ul> <li><code>#include &lt;DatFile.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1DatFile/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; DatEntry &gt; m_Lines bool m_continuous double m_end uint32_t m_lineCount double m_start double m_step std::string m_title double m_weightSum"},{"location":"rayxCore/structrayx_1_1DatFile/#public-functions","title":"Public Functions","text":"Type Name std::string dump ()"},{"location":"rayxCore/structrayx_1_1DatFile/#public-static-functions","title":"Public Static Functions","text":"Type Name bool load (const std::filesystem::path &amp; filename, DatFile * out)"},{"location":"rayxCore/structrayx_1_1DatFile/#detailed-description","title":"Detailed Description","text":"<p>This struct represents the contents of a .DAT file. </p>"},{"location":"rayxCore/structrayx_1_1DatFile/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_lines","title":"variable m_Lines","text":"<pre><code>std::vector&lt;DatEntry&gt; rayx::DatFile::m_Lines;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_continuous","title":"variable m_continuous","text":"<pre><code>bool rayx::DatFile::m_continuous;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_end","title":"variable m_end","text":"<pre><code>double rayx::DatFile::m_end;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_linecount","title":"variable m_lineCount","text":"<pre><code>uint32_t rayx::DatFile::m_lineCount;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_start","title":"variable m_start","text":"<pre><code>double rayx::DatFile::m_start;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_step","title":"variable m_step","text":"<pre><code>double rayx::DatFile::m_step;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_title","title":"variable m_title","text":"<pre><code>std::string rayx::DatFile::m_title;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#variable-m_weightsum","title":"variable m_weightSum","text":"<pre><code>double rayx::DatFile::m_weightSum;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DatFile/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1DatFile/#function-dump","title":"function dump","text":"<pre><code>std::string rayx::DatFile::dump () \n</code></pre> <p>creates a valid .DAT file from this struct (may be used for testing) </p>"},{"location":"rayxCore/structrayx_1_1DatFile/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1DatFile/#function-load","title":"function load","text":"<pre><code>static bool rayx::DatFile::load (\n    const std::filesystem::path &amp; filename,\n    DatFile * out\n) \n</code></pre> <p>loads the .DAT file <code>filename</code> and writes it's contents to <code>out</code> </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/DatFile.h</code></p>"},{"location":"rayxCore/structrayx_1_1Deg/","title":"Struct rayx::Deg","text":"<p>ClassList &gt; rayx &gt; Deg</p>"},{"location":"rayxCore/structrayx_1_1Deg/#public-attributes","title":"Public Attributes","text":"Type Name double deg"},{"location":"rayxCore/structrayx_1_1Deg/#public-functions","title":"Public Functions","text":"Type Name Deg () = default Deg (double d)  Rad toRad () const"},{"location":"rayxCore/structrayx_1_1Deg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Deg/#variable-deg","title":"variable deg","text":"<pre><code>double rayx::Deg::deg;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Deg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Deg/#function-deg-12","title":"function Deg [1/2]","text":"<pre><code>rayx::Deg::Deg () = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Deg/#function-deg-22","title":"function Deg [2/2]","text":"<pre><code>inline rayx::Deg::Deg (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Deg/#function-torad","title":"function toRad","text":"<pre><code>Rad rayx::Deg::toRad () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Angle.h</code></p>"},{"location":"rayxCore/classrayx_1_1DesignElement/","title":"Class rayx::DesignElement","text":"<p>ClassList &gt; rayx &gt; DesignElement</p> <p>Inherits the following classes: rayx::BeamlineNode</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#public-attributes","title":"Public Attributes","text":"Type Name DesignMap m_elementParameters"},{"location":"rayxCore/classrayx_1_1DesignElement/#public-functions","title":"Public Functions","text":"Type Name DesignElement ()  DesignElement (std::string name)  DesignElement (const DesignElement &amp; other) = delete DesignElement (DesignElement &amp;&amp; other) noexcept virtual std::unique_ptr&lt; BeamlineNode &gt; clone () override constCreates a deep copy (clone) of this BeamlineNode . OpticalElementAndTransform compile (const glm::dvec4 &amp; groupPosition, const glm::dmat4 &amp; groupOrientation) const int getAdditionalOrder () const double getArmLength () const Rad getAzimuthalAngle () const BehaviourType getBehaviourType () const CentralBeamstop getCentralBeamstop () const Coating getCoating () const std::string getCrystalMaterial () const CrystalType getCrystalType () const CurvatureType getCurvatureType () const Cutout getCutout () const double getDSpacing2 () const Rad getDesignAlphaAngle () const Rad getDesignBetaAngle () const double getDesignEnergy () const Rad getDesignGrazingIncAngle () const double getDesignMeridionalEntranceArmLength () const double getDesignMeridionalExitArmLength () const int getDesignOrderOfDiffraction () const DesignPlane getDesignPlane () const double getDesignSagittalEntranceArmLength () const double getDesignSagittalExitArmLength () const Rad getDeviationAngle () const double getDistancePreceding () const double getEntranceArmLength () const double getExitArmLength () const Surface getExpertsCubic () const Surface getExpertsOptics () const FigureRotation getFigureRotation () const double getFresnelZOffset () const Cutout getGlobalCutout () const Rad getGrazingIncAngle () const int getImageType () const double getLineDensity () const double getLongHalfAxisA () const double getLongRadius () const Material getMaterial () const Material getMaterialCoating () const virtual std::string getName () override const Rad getOffsetAngle () const OffsetAngleType getOffsetAngleType () const double getOpeningHeight () const CutoutType getOpeningShape () const double getOpeningWidth () const int getOrderOfDiffraction () const virtual glm::dmat4x4 getOrientation () override constGets the local orientation (rotation/transform) of this node. double getParameterA11 () const double getParameterP () const double getParameterPType () const virtual glm::dvec4 getPosition () override constGets the local position of this node. double getProfileFile () const int getProfileKind () const double getRadius () const CylinderDirection getRadiusDirection () const double getRoughnessCoating () const double getRoughnessSubstrate () const double getShortHalfAxisB () const double getShortRadius () const SlopeError getSlopeError () const double getStopHeight () const double getStopWidth () const double getStructureFactorImF0 () const double getStructureFactorImFH () const double getStructureFactorImFHC () const double getStructureFactorReF0 () const double getStructureFactorReFH () const double getStructureFactorReFHC () const SurfaceCoatingType getSurfaceCoatingType () const double getThicknessCoating () const double getThicknessSubstrate () const double getTotalHeight () const double getTotalLength () const double getTotalWidth () const ElementType getType () const double getUnitCellVolume () const std::array&lt; double, 6 &gt; getVLSParameters () const virtual bool isElement () override const DesignElement &amp; operator= (const DesignElement &amp; other) = delete DesignElement &amp; operator= (DesignElement &amp;&amp; other) noexcept void setAdditionalOrder (int value)  void setArmLength (double value)  void setAzimuthalAngle (Rad r)  void setBehaviourType (BehaviourType value)  void setCalcRadius ()  void setCalcRadiusDeviationAngle ()  void setCentralBeamstop (CentralBeamstop d)  void setCrystalMaterial (const std::string &amp; value)  void setCrystalType (CrystalType value)  void setCurvatureType (CurvatureType value)  void setCutout (Cutout c)  void setDSpacing2 (double value)  void setDesignAlphaAngle (Rad value)  void setDesignBetaAngle (Rad value)  void setDesignEnergy (double value)  void setDesignGrazingIncAngle (Rad value)  void setDesignMeridionalEntranceArmLength (double value)  void setDesignMeridionalExitArmLength (double value)  void setDesignOrderOfDiffraction (int value)  void setDesignPlane (DesignPlane value)  void setDesignSagittalEntranceArmLength (double value)  void setDesignSagittalExitArmLength (double value)  void setDeviationAngle (Rad value)  void setDistancePreceding (double d)  void setEntranceArmLength (double value)  void setExitArmLength (double value)  void setExpertsCubic (Surface value)  void setExpertsOptics (Surface value)  void setFigureRotation (FigureRotation value)  void setFresnelZOffset (double value)  void setGrazingIncAngle (Rad value)  void setImageType (int value)  void setLineDensity (double value)  void setLongHalfAxisA (double value)  void setLongRadius (double value)  void setMaterial (Material m)  void setMaterialCoating (Material value)  void setMultilayerCoating (const Coating::MultilayerCoating &amp; coating)  virtual void setName (std::string s) override void setOffsetAngle (Rad value)  void setOffsetAngleType (OffsetAngleType value)  void setOpeningHeight (double d)  void setOpeningShape (CutoutType shape)  void setOpeningWidth (double d)  void setOrderOfDiffraction (int value)  void setOrientation (glm::dmat4x4 o)  void setParameterA11 (double value)  void setParameterP (double value)  void setParameterPType (double value)  void setPosition (glm::dvec4 p)  void setProfileFile (double value)  void setProfileKind (int value)  void setRadius (double value)  void setRadiusDirection (CylinderDirection value)  void setRoughnessCoating (double value)  void setRoughnessSubstrate (double value)  void setShortHalfAxisB (double value)  void setShortRadius (double value)  void setSlopeError (SlopeError s)  void setStopHeight (double height)  void setStopWidth (double d)  void setStructureFactorImF0 (double value)  void setStructureFactorImFH (double value)  void setStructureFactorImFHC (double value)  void setStructureFactorReF0 (double value)  void setStructureFactorReFH (double value)  void setStructureFactorReFHC (double value)  void setSurfaceCoatingType (SurfaceCoatingType value)  void setThicknessCoating (double value)  void setThicknessSubstrate (double value)  void setTotalHeight (double d)  void setTotalLength (double value)  void setTotalWidth (double width)  void setType (ElementType s)  void setUnitCellVolume (double value)  void setVLSParameters (const std::array&lt; double, 6 &gt; &amp; values)  ~DesignElement () = default"},{"location":"rayxCore/classrayx_1_1DesignElement/#public-functions-inherited-from-rayxbeamlinenode","title":"Public Functions inherited from rayx::BeamlineNode","text":"<p>See rayx::BeamlineNode</p> Type Name const DesignElement * asElement () const DesignElement * asElement ()  const Group * asGroup () const Group * asGroup ()  const DesignSource * asSource () const DesignSource * asSource ()  virtual std::unique_ptr&lt; BeamlineNode &gt; clone () const = 0Creates a deep copy (clone) of this BeamlineNode . virtual std::string getName () const = 0 int getObjectId () const virtual glm::dmat4 getOrientation () const = 0Gets the local orientation (rotation/transform) of this node. const BeamlineNode * getParent () const BeamlineNode * getParent ()  virtual glm::dvec4 getPosition () const = 0Gets the local position of this node. const BeamlineNode * getRoot () const BeamlineNode * getRoot ()  glm::dmat4 getWorldOrientation () constComputes the absolute/world orientation of this node. glm::dvec4 getWorldPosition () constComputes the absolute/world position of this node. bool hasParent () const virtual bool isElement () const virtual bool isGroup () const virtual bool isSource () const virtual const BeamlineNode * operator[] (size_t index) const virtual BeamlineNode * operator[] (size_t index)  virtual const BeamlineNode * operator[] (const std::string &amp; name) const virtual BeamlineNode * operator[] (const std::string &amp; name)  virtual void setName (std::string name) = 0 virtual ~BeamlineNode () = default"},{"location":"rayxCore/classrayx_1_1DesignElement/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignElement/#variable-m_elementparameters","title":"variable m_elementParameters","text":"<pre><code>DesignMap rayx::DesignElement::m_elementParameters;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignElement/#function-designelement-14","title":"function DesignElement [1/4]","text":"<pre><code>rayx::DesignElement::DesignElement () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-designelement-24","title":"function DesignElement [2/4]","text":"<pre><code>rayx::DesignElement::DesignElement (\n    std::string name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-designelement-34","title":"function DesignElement [3/4]","text":"<pre><code>rayx::DesignElement::DesignElement (\n    const DesignElement &amp; other\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-designelement-44","title":"function DesignElement [4/4]","text":"<pre><code>rayx::DesignElement::DesignElement (\n    DesignElement &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-clone","title":"function clone","text":"<p>Creates a deep copy (clone) of this BeamlineNode . <pre><code>virtual std::unique_ptr&lt; BeamlineNode &gt; rayx::DesignElement::clone () override const\n</code></pre></p> <p>Derived classes must implement this to allow duplication of their internal state. </p> <p>Returns:</p> <p>A unique_ptr to the newly cloned BeamlineNode. </p> <p>Implements rayx::BeamlineNode::clone</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-compile","title":"function compile","text":"<pre><code>OpticalElementAndTransform rayx::DesignElement::compile (\n    const glm::dvec4 &amp; groupPosition,\n    const glm::dmat4 &amp; groupOrientation\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getadditionalorder","title":"function getAdditionalOrder","text":"<pre><code>int rayx::DesignElement::getAdditionalOrder () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getarmlength","title":"function getArmLength","text":"<pre><code>double rayx::DesignElement::getArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getazimuthalangle","title":"function getAzimuthalAngle","text":"<pre><code>Rad rayx::DesignElement::getAzimuthalAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getbehaviourtype","title":"function getBehaviourType","text":"<pre><code>BehaviourType rayx::DesignElement::getBehaviourType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcentralbeamstop","title":"function getCentralBeamstop","text":"<pre><code>CentralBeamstop rayx::DesignElement::getCentralBeamstop () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcoating","title":"function getCoating","text":"<pre><code>Coating rayx::DesignElement::getCoating () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcrystalmaterial","title":"function getCrystalMaterial","text":"<pre><code>std::string rayx::DesignElement::getCrystalMaterial () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcrystaltype","title":"function getCrystalType","text":"<pre><code>CrystalType rayx::DesignElement::getCrystalType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcurvaturetype","title":"function getCurvatureType","text":"<pre><code>CurvatureType rayx::DesignElement::getCurvatureType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getcutout","title":"function getCutout","text":"<pre><code>Cutout rayx::DesignElement::getCutout () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdspacing2","title":"function getDSpacing2","text":"<pre><code>double rayx::DesignElement::getDSpacing2 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignalphaangle","title":"function getDesignAlphaAngle","text":"<pre><code>Rad rayx::DesignElement::getDesignAlphaAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignbetaangle","title":"function getDesignBetaAngle","text":"<pre><code>Rad rayx::DesignElement::getDesignBetaAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignenergy","title":"function getDesignEnergy","text":"<pre><code>double rayx::DesignElement::getDesignEnergy () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesigngrazingincangle","title":"function getDesignGrazingIncAngle","text":"<pre><code>Rad rayx::DesignElement::getDesignGrazingIncAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignmeridionalentrancearmlength","title":"function getDesignMeridionalEntranceArmLength","text":"<pre><code>double rayx::DesignElement::getDesignMeridionalEntranceArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignmeridionalexitarmlength","title":"function getDesignMeridionalExitArmLength","text":"<pre><code>double rayx::DesignElement::getDesignMeridionalExitArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignorderofdiffraction","title":"function getDesignOrderOfDiffraction","text":"<pre><code>int rayx::DesignElement::getDesignOrderOfDiffraction () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignplane","title":"function getDesignPlane","text":"<pre><code>DesignPlane rayx::DesignElement::getDesignPlane () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignsagittalentrancearmlength","title":"function getDesignSagittalEntranceArmLength","text":"<pre><code>double rayx::DesignElement::getDesignSagittalEntranceArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdesignsagittalexitarmlength","title":"function getDesignSagittalExitArmLength","text":"<pre><code>double rayx::DesignElement::getDesignSagittalExitArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdeviationangle","title":"function getDeviationAngle","text":"<pre><code>Rad rayx::DesignElement::getDeviationAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getdistancepreceding","title":"function getDistancePreceding","text":"<pre><code>double rayx::DesignElement::getDistancePreceding () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getentrancearmlength","title":"function getEntranceArmLength","text":"<pre><code>double rayx::DesignElement::getEntranceArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getexitarmlength","title":"function getExitArmLength","text":"<pre><code>double rayx::DesignElement::getExitArmLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getexpertscubic","title":"function getExpertsCubic","text":"<pre><code>Surface rayx::DesignElement::getExpertsCubic () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getexpertsoptics","title":"function getExpertsOptics","text":"<pre><code>Surface rayx::DesignElement::getExpertsOptics () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getfigurerotation","title":"function getFigureRotation","text":"<pre><code>FigureRotation rayx::DesignElement::getFigureRotation () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getfresnelzoffset","title":"function getFresnelZOffset","text":"<pre><code>double rayx::DesignElement::getFresnelZOffset () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getglobalcutout","title":"function getGlobalCutout","text":"<pre><code>Cutout rayx::DesignElement::getGlobalCutout () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getgrazingincangle","title":"function getGrazingIncAngle","text":"<pre><code>Rad rayx::DesignElement::getGrazingIncAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getimagetype","title":"function getImageType","text":"<pre><code>int rayx::DesignElement::getImageType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getlinedensity","title":"function getLineDensity","text":"<pre><code>double rayx::DesignElement::getLineDensity () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getlonghalfaxisa","title":"function getLongHalfAxisA","text":"<pre><code>double rayx::DesignElement::getLongHalfAxisA () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getlongradius","title":"function getLongRadius","text":"<pre><code>double rayx::DesignElement::getLongRadius () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getmaterial","title":"function getMaterial","text":"<pre><code>Material rayx::DesignElement::getMaterial () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getmaterialcoating","title":"function getMaterialCoating","text":"<pre><code>Material rayx::DesignElement::getMaterialCoating () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getname","title":"function getName","text":"<pre><code>virtual std::string rayx::DesignElement::getName () override const\n</code></pre> <p>Implements rayx::BeamlineNode::getName</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getoffsetangle","title":"function getOffsetAngle","text":"<pre><code>Rad rayx::DesignElement::getOffsetAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getoffsetangletype","title":"function getOffsetAngleType","text":"<pre><code>OffsetAngleType rayx::DesignElement::getOffsetAngleType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getopeningheight","title":"function getOpeningHeight","text":"<pre><code>double rayx::DesignElement::getOpeningHeight () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getopeningshape","title":"function getOpeningShape","text":"<pre><code>CutoutType rayx::DesignElement::getOpeningShape () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getopeningwidth","title":"function getOpeningWidth","text":"<pre><code>double rayx::DesignElement::getOpeningWidth () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getorderofdiffraction","title":"function getOrderOfDiffraction","text":"<pre><code>int rayx::DesignElement::getOrderOfDiffraction () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getorientation","title":"function getOrientation","text":"<p>Gets the local orientation (rotation/transform) of this node. <pre><code>virtual glm::dmat4x4 rayx::DesignElement::getOrientation () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the local orientation. </p> <p>Implements rayx::BeamlineNode::getOrientation</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getparametera11","title":"function getParameterA11","text":"<pre><code>double rayx::DesignElement::getParameterA11 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getparameterp","title":"function getParameterP","text":"<pre><code>double rayx::DesignElement::getParameterP () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getparameterptype","title":"function getParameterPType","text":"<pre><code>double rayx::DesignElement::getParameterPType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getposition","title":"function getPosition","text":"<p>Gets the local position of this node. <pre><code>virtual glm::dvec4 rayx::DesignElement::getPosition () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4D vector (dvec4) representing the local position. </p> <p>Implements rayx::BeamlineNode::getPosition</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getprofilefile","title":"function getProfileFile","text":"<pre><code>double rayx::DesignElement::getProfileFile () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getprofilekind","title":"function getProfileKind","text":"<pre><code>int rayx::DesignElement::getProfileKind () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getradius","title":"function getRadius","text":"<pre><code>double rayx::DesignElement::getRadius () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getradiusdirection","title":"function getRadiusDirection","text":"<pre><code>CylinderDirection rayx::DesignElement::getRadiusDirection () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getroughnesscoating","title":"function getRoughnessCoating","text":"<pre><code>double rayx::DesignElement::getRoughnessCoating () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getroughnesssubstrate","title":"function getRoughnessSubstrate","text":"<pre><code>double rayx::DesignElement::getRoughnessSubstrate () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getshorthalfaxisb","title":"function getShortHalfAxisB","text":"<pre><code>double rayx::DesignElement::getShortHalfAxisB () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getshortradius","title":"function getShortRadius","text":"<pre><code>double rayx::DesignElement::getShortRadius () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getslopeerror","title":"function getSlopeError","text":"<pre><code>SlopeError rayx::DesignElement::getSlopeError () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstopheight","title":"function getStopHeight","text":"<pre><code>double rayx::DesignElement::getStopHeight () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstopwidth","title":"function getStopWidth","text":"<pre><code>double rayx::DesignElement::getStopWidth () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorimf0","title":"function getStructureFactorImF0","text":"<pre><code>double rayx::DesignElement::getStructureFactorImF0 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorimfh","title":"function getStructureFactorImFH","text":"<pre><code>double rayx::DesignElement::getStructureFactorImFH () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorimfhc","title":"function getStructureFactorImFHC","text":"<pre><code>double rayx::DesignElement::getStructureFactorImFHC () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorref0","title":"function getStructureFactorReF0","text":"<pre><code>double rayx::DesignElement::getStructureFactorReF0 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorrefh","title":"function getStructureFactorReFH","text":"<pre><code>double rayx::DesignElement::getStructureFactorReFH () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getstructurefactorrefhc","title":"function getStructureFactorReFHC","text":"<pre><code>double rayx::DesignElement::getStructureFactorReFHC () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getsurfacecoatingtype","title":"function getSurfaceCoatingType","text":"<pre><code>SurfaceCoatingType rayx::DesignElement::getSurfaceCoatingType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getthicknesscoating","title":"function getThicknessCoating","text":"<pre><code>double rayx::DesignElement::getThicknessCoating () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getthicknesssubstrate","title":"function getThicknessSubstrate","text":"<pre><code>double rayx::DesignElement::getThicknessSubstrate () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-gettotalheight","title":"function getTotalHeight","text":"<pre><code>double rayx::DesignElement::getTotalHeight () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-gettotallength","title":"function getTotalLength","text":"<pre><code>double rayx::DesignElement::getTotalLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-gettotalwidth","title":"function getTotalWidth","text":"<pre><code>double rayx::DesignElement::getTotalWidth () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-gettype","title":"function getType","text":"<pre><code>ElementType rayx::DesignElement::getType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getunitcellvolume","title":"function getUnitCellVolume","text":"<pre><code>double rayx::DesignElement::getUnitCellVolume () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-getvlsparameters","title":"function getVLSParameters","text":"<pre><code>std::array&lt; double, 6 &gt; rayx::DesignElement::getVLSParameters () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-iselement","title":"function isElement","text":"<pre><code>inline virtual bool rayx::DesignElement::isElement () override const\n</code></pre> <p>Implements rayx::BeamlineNode::isElement</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-operator","title":"function operator=","text":"<pre><code>DesignElement &amp; rayx::DesignElement::operator= (\n    const DesignElement &amp; other\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-operator_1","title":"function operator=","text":"<pre><code>DesignElement &amp; rayx::DesignElement::operator= (\n    DesignElement &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setadditionalorder","title":"function setAdditionalOrder","text":"<pre><code>void rayx::DesignElement::setAdditionalOrder (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setarmlength","title":"function setArmLength","text":"<pre><code>void rayx::DesignElement::setArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setazimuthalangle","title":"function setAzimuthalAngle","text":"<pre><code>void rayx::DesignElement::setAzimuthalAngle (\n    Rad r\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setbehaviourtype","title":"function setBehaviourType","text":"<pre><code>void rayx::DesignElement::setBehaviourType (\n    BehaviourType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcalcradius","title":"function setCalcRadius","text":"<pre><code>void rayx::DesignElement::setCalcRadius () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcalcradiusdeviationangle","title":"function setCalcRadiusDeviationAngle","text":"<pre><code>void rayx::DesignElement::setCalcRadiusDeviationAngle () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcentralbeamstop","title":"function setCentralBeamstop","text":"<pre><code>void rayx::DesignElement::setCentralBeamstop (\n    CentralBeamstop d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcrystalmaterial","title":"function setCrystalMaterial","text":"<pre><code>void rayx::DesignElement::setCrystalMaterial (\n    const std::string &amp; value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcrystaltype","title":"function setCrystalType","text":"<pre><code>void rayx::DesignElement::setCrystalType (\n    CrystalType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcurvaturetype","title":"function setCurvatureType","text":"<pre><code>void rayx::DesignElement::setCurvatureType (\n    CurvatureType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setcutout","title":"function setCutout","text":"<pre><code>void rayx::DesignElement::setCutout (\n    Cutout c\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdspacing2","title":"function setDSpacing2","text":"<pre><code>void rayx::DesignElement::setDSpacing2 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignalphaangle","title":"function setDesignAlphaAngle","text":"<pre><code>void rayx::DesignElement::setDesignAlphaAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignbetaangle","title":"function setDesignBetaAngle","text":"<pre><code>void rayx::DesignElement::setDesignBetaAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignenergy","title":"function setDesignEnergy","text":"<pre><code>void rayx::DesignElement::setDesignEnergy (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesigngrazingincangle","title":"function setDesignGrazingIncAngle","text":"<pre><code>void rayx::DesignElement::setDesignGrazingIncAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignmeridionalentrancearmlength","title":"function setDesignMeridionalEntranceArmLength","text":"<pre><code>void rayx::DesignElement::setDesignMeridionalEntranceArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignmeridionalexitarmlength","title":"function setDesignMeridionalExitArmLength","text":"<pre><code>void rayx::DesignElement::setDesignMeridionalExitArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignorderofdiffraction","title":"function setDesignOrderOfDiffraction","text":"<pre><code>void rayx::DesignElement::setDesignOrderOfDiffraction (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignplane","title":"function setDesignPlane","text":"<pre><code>void rayx::DesignElement::setDesignPlane (\n    DesignPlane value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignsagittalentrancearmlength","title":"function setDesignSagittalEntranceArmLength","text":"<pre><code>void rayx::DesignElement::setDesignSagittalEntranceArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdesignsagittalexitarmlength","title":"function setDesignSagittalExitArmLength","text":"<pre><code>void rayx::DesignElement::setDesignSagittalExitArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdeviationangle","title":"function setDeviationAngle","text":"<pre><code>void rayx::DesignElement::setDeviationAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setdistancepreceding","title":"function setDistancePreceding","text":"<pre><code>void rayx::DesignElement::setDistancePreceding (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setentrancearmlength","title":"function setEntranceArmLength","text":"<pre><code>void rayx::DesignElement::setEntranceArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setexitarmlength","title":"function setExitArmLength","text":"<pre><code>void rayx::DesignElement::setExitArmLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setexpertscubic","title":"function setExpertsCubic","text":"<pre><code>void rayx::DesignElement::setExpertsCubic (\n    Surface value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setexpertsoptics","title":"function setExpertsOptics","text":"<pre><code>void rayx::DesignElement::setExpertsOptics (\n    Surface value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setfigurerotation","title":"function setFigureRotation","text":"<pre><code>void rayx::DesignElement::setFigureRotation (\n    FigureRotation value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setfresnelzoffset","title":"function setFresnelZOffset","text":"<pre><code>void rayx::DesignElement::setFresnelZOffset (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setgrazingincangle","title":"function setGrazingIncAngle","text":"<pre><code>void rayx::DesignElement::setGrazingIncAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setimagetype","title":"function setImageType","text":"<pre><code>void rayx::DesignElement::setImageType (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setlinedensity","title":"function setLineDensity","text":"<pre><code>void rayx::DesignElement::setLineDensity (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setlonghalfaxisa","title":"function setLongHalfAxisA","text":"<pre><code>void rayx::DesignElement::setLongHalfAxisA (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setlongradius","title":"function setLongRadius","text":"<pre><code>void rayx::DesignElement::setLongRadius (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setmaterial","title":"function setMaterial","text":"<pre><code>void rayx::DesignElement::setMaterial (\n    Material m\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setmaterialcoating","title":"function setMaterialCoating","text":"<pre><code>void rayx::DesignElement::setMaterialCoating (\n    Material value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setmultilayercoating","title":"function setMultilayerCoating","text":"<pre><code>void rayx::DesignElement::setMultilayerCoating (\n    const Coating::MultilayerCoating &amp; coating\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setname","title":"function setName","text":"<pre><code>virtual void rayx::DesignElement::setName (\n    std::string s\n) override\n</code></pre> <p>Implements rayx::BeamlineNode::setName</p>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setoffsetangle","title":"function setOffsetAngle","text":"<pre><code>void rayx::DesignElement::setOffsetAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setoffsetangletype","title":"function setOffsetAngleType","text":"<pre><code>void rayx::DesignElement::setOffsetAngleType (\n    OffsetAngleType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setopeningheight","title":"function setOpeningHeight","text":"<pre><code>void rayx::DesignElement::setOpeningHeight (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setopeningshape","title":"function setOpeningShape","text":"<pre><code>void rayx::DesignElement::setOpeningShape (\n    CutoutType shape\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setopeningwidth","title":"function setOpeningWidth","text":"<pre><code>void rayx::DesignElement::setOpeningWidth (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setorderofdiffraction","title":"function setOrderOfDiffraction","text":"<pre><code>void rayx::DesignElement::setOrderOfDiffraction (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setorientation","title":"function setOrientation","text":"<pre><code>void rayx::DesignElement::setOrientation (\n    glm::dmat4x4 o\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setparametera11","title":"function setParameterA11","text":"<pre><code>void rayx::DesignElement::setParameterA11 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setparameterp","title":"function setParameterP","text":"<pre><code>void rayx::DesignElement::setParameterP (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setparameterptype","title":"function setParameterPType","text":"<pre><code>void rayx::DesignElement::setParameterPType (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setposition","title":"function setPosition","text":"<pre><code>void rayx::DesignElement::setPosition (\n    glm::dvec4 p\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setprofilefile","title":"function setProfileFile","text":"<pre><code>void rayx::DesignElement::setProfileFile (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setprofilekind","title":"function setProfileKind","text":"<pre><code>void rayx::DesignElement::setProfileKind (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setradius","title":"function setRadius","text":"<pre><code>void rayx::DesignElement::setRadius (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setradiusdirection","title":"function setRadiusDirection","text":"<pre><code>void rayx::DesignElement::setRadiusDirection (\n    CylinderDirection value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setroughnesscoating","title":"function setRoughnessCoating","text":"<pre><code>void rayx::DesignElement::setRoughnessCoating (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setroughnesssubstrate","title":"function setRoughnessSubstrate","text":"<pre><code>void rayx::DesignElement::setRoughnessSubstrate (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setshorthalfaxisb","title":"function setShortHalfAxisB","text":"<pre><code>void rayx::DesignElement::setShortHalfAxisB (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setshortradius","title":"function setShortRadius","text":"<pre><code>void rayx::DesignElement::setShortRadius (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setslopeerror","title":"function setSlopeError","text":"<pre><code>void rayx::DesignElement::setSlopeError (\n    SlopeError s\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstopheight","title":"function setStopHeight","text":"<pre><code>void rayx::DesignElement::setStopHeight (\n    double height\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstopwidth","title":"function setStopWidth","text":"<pre><code>void rayx::DesignElement::setStopWidth (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorimf0","title":"function setStructureFactorImF0","text":"<pre><code>void rayx::DesignElement::setStructureFactorImF0 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorimfh","title":"function setStructureFactorImFH","text":"<pre><code>void rayx::DesignElement::setStructureFactorImFH (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorimfhc","title":"function setStructureFactorImFHC","text":"<pre><code>void rayx::DesignElement::setStructureFactorImFHC (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorref0","title":"function setStructureFactorReF0","text":"<pre><code>void rayx::DesignElement::setStructureFactorReF0 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorrefh","title":"function setStructureFactorReFH","text":"<pre><code>void rayx::DesignElement::setStructureFactorReFH (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setstructurefactorrefhc","title":"function setStructureFactorReFHC","text":"<pre><code>void rayx::DesignElement::setStructureFactorReFHC (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setsurfacecoatingtype","title":"function setSurfaceCoatingType","text":"<pre><code>void rayx::DesignElement::setSurfaceCoatingType (\n    SurfaceCoatingType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setthicknesscoating","title":"function setThicknessCoating","text":"<pre><code>void rayx::DesignElement::setThicknessCoating (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setthicknesssubstrate","title":"function setThicknessSubstrate","text":"<pre><code>void rayx::DesignElement::setThicknessSubstrate (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-settotalheight","title":"function setTotalHeight","text":"<pre><code>void rayx::DesignElement::setTotalHeight (\n    double d\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-settotallength","title":"function setTotalLength","text":"<pre><code>void rayx::DesignElement::setTotalLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-settotalwidth","title":"function setTotalWidth","text":"<pre><code>void rayx::DesignElement::setTotalWidth (\n    double width\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-settype","title":"function setType","text":"<pre><code>void rayx::DesignElement::setType (\n    ElementType s\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setunitcellvolume","title":"function setUnitCellVolume","text":"<pre><code>void rayx::DesignElement::setUnitCellVolume (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-setvlsparameters","title":"function setVLSParameters","text":"<pre><code>void rayx::DesignElement::setVLSParameters (\n    const std::array&lt; double, 6 &gt; &amp; values\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignElement/#function-designelement","title":"function ~DesignElement","text":"<pre><code>rayx::DesignElement::~DesignElement () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/DesignElement.h</code></p>"},{"location":"rayxCore/classrayx_1_1DesignMap/","title":"Class rayx::DesignMap","text":"<p>ClassList &gt; rayx &gt; DesignMap</p> <p>More...</p> <ul> <li><code>#include &lt;Value.h&gt;</code></li> </ul>"},{"location":"rayxCore/classrayx_1_1DesignMap/#classes","title":"Classes","text":"Type Name class ConstIterator class Iterator"},{"location":"rayxCore/classrayx_1_1DesignMap/#public-functions","title":"Public Functions","text":"Type Name DesignMap ()  DesignMap (double x)  DesignMap (int x)  DesignMap (bool x)  DesignMap (const std::string &amp; x)  DesignMap (Map x)  DesignMap (glm::dvec4 x)  DesignMap (glm::dmat4x4 x)  DesignMap (Rad x)  DesignMap (Material x)  DesignMap (CentralBeamstop x)  DesignMap (Cutout x)  DesignMap (CutoutType x)  DesignMap (EventType x)  DesignMap (CylinderDirection x)  DesignMap (FigureRotation x)  DesignMap (CurvatureType x)  DesignMap (Surface x)  DesignMap (SourceDist x)  DesignMap (SpreadType x)  DesignMap (EnergyDistributionType x)  DesignMap (EnergySpreadUnit x)  DesignMap (SigmaType x)  DesignMap (BehaviourType x)  DesignMap (ElementType x)  DesignMap (GratingMount x)  DesignMap (CrystalType x)  DesignMap (DesignPlane x)  DesignMap (SurfaceCoatingType x)  DesignMap (std::shared_ptr&lt; Rays &gt; x)  BehaviourType as_behaviourType () const bool as_bool () const CentralBeamstop as_centralBeamStop () const CrystalType as_crystalType () const CurvatureType as_curvatureType () const Cutout as_cutout () const CylinderDirection as_cylinderDirection () const DesignPlane as_designPlane () const glm::dmat4 as_dmat4x4 () const double as_double () const glm::dvec4 as_dvec4 () const ElectronEnergyOrientation as_electronEnergyOrientation () const ElementType as_elementType () const EnergyDistributionType as_energyDistType () const EnergyDistributionType as_energyDistributionType () const SpreadType as_energySpreadType () const EnergySpreadUnit as_energySpreadUnit () const EventType as_eventType () const FigureRotation as_figureRotation () const GratingMount as_gratingMount () const int as_int () const Map as_map () const Material as_material () const CutoutType as_openingShape () const Rad as_rad () const std::shared_ptr&lt; Rays &gt; as_rayList () const SigmaType as_sigmaType () const SourceDist as_sourceDist () const std::string as_string () const Surface as_surface () const SurfaceCoatingType as_surfaceCoatingType () const Iterator begin ()  ConstIterator begin () const DesignMap clone () const Iterator end ()  ConstIterator end () const bool hasKey (const std::string &amp; s) const void operator= (double x)  void operator= (int x)  void operator= (bool x)  void operator= (const std::string &amp; x)  void operator= (Map x)  void operator= (glm::dvec4 x)  void operator= (glm::dmat4 x)  void operator= (Rad x)  void operator= (Material x)  void operator= (CentralBeamstop x)  void operator= (Cutout x)  void operator= (CutoutType x)  void operator= (EventType x)  void operator= (CylinderDirection x)  void operator= (FigureRotation x)  void operator= (CurvatureType x)  void operator= (Surface x)  void operator= (SourceDist x)  void operator= (SpreadType x)  void operator= (EnergyDistributionType x)  void operator= (EnergySpreadUnit x)  void operator= (ElectronEnergyOrientation x)  void operator= (SigmaType x)  void operator= (BehaviourType x)  void operator= (GratingMount x)  void operator= (ElementType x)  void operator= (CrystalType x)  void operator= (DesignPlane x)  void operator= (SurfaceCoatingType x)  void operator= (std::shared_ptr&lt; Rays &gt; x)  const DesignMap &amp; operator[] (const std::string &amp; s) const DesignMap &amp; operator[] (const std::string &amp; s)  ValueType type () const"},{"location":"rayxCore/classrayx_1_1DesignMap/#detailed-description","title":"Detailed Description","text":"<p>To ensure a typesafe Map all possible options are defined in the Value class bellow </p>"},{"location":"rayxCore/classrayx_1_1DesignMap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-130","title":"function DesignMap [1/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-230","title":"function DesignMap [2/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    double x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-330","title":"function DesignMap [3/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    int x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-430","title":"function DesignMap [4/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    bool x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-530","title":"function DesignMap [5/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    const std::string &amp; x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-630","title":"function DesignMap [6/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    Map x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-730","title":"function DesignMap [7/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    glm::dvec4 x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-830","title":"function DesignMap [8/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    glm::dmat4x4 x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-930","title":"function DesignMap [9/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    Rad x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1030","title":"function DesignMap [10/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    Material x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1130","title":"function DesignMap [11/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    CentralBeamstop x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1230","title":"function DesignMap [12/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    Cutout x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1330","title":"function DesignMap [13/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    CutoutType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1430","title":"function DesignMap [14/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    EventType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1530","title":"function DesignMap [15/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    CylinderDirection x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1630","title":"function DesignMap [16/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    FigureRotation x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1730","title":"function DesignMap [17/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    CurvatureType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1830","title":"function DesignMap [18/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    Surface x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-1930","title":"function DesignMap [19/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    SourceDist x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2030","title":"function DesignMap [20/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    SpreadType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2130","title":"function DesignMap [21/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    EnergyDistributionType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2230","title":"function DesignMap [22/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    EnergySpreadUnit x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2330","title":"function DesignMap [23/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    SigmaType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2430","title":"function DesignMap [24/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    BehaviourType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2530","title":"function DesignMap [25/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    ElementType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2630","title":"function DesignMap [26/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    GratingMount x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2730","title":"function DesignMap [27/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    CrystalType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2830","title":"function DesignMap [28/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    DesignPlane x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-2930","title":"function DesignMap [29/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    SurfaceCoatingType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-designmap-3030","title":"function DesignMap [30/30]","text":"<pre><code>inline rayx::DesignMap::DesignMap (\n    std::shared_ptr&lt; Rays &gt; x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_behaviourtype","title":"function as_behaviourType","text":"<pre><code>BehaviourType rayx::DesignMap::as_behaviourType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_bool","title":"function as_bool","text":"<pre><code>bool rayx::DesignMap::as_bool () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_centralbeamstop","title":"function as_centralBeamStop","text":"<pre><code>CentralBeamstop rayx::DesignMap::as_centralBeamStop () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_crystaltype","title":"function as_crystalType","text":"<pre><code>CrystalType rayx::DesignMap::as_crystalType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_curvaturetype","title":"function as_curvatureType","text":"<pre><code>CurvatureType rayx::DesignMap::as_curvatureType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_cutout","title":"function as_cutout","text":"<pre><code>Cutout rayx::DesignMap::as_cutout () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_cylinderdirection","title":"function as_cylinderDirection","text":"<pre><code>CylinderDirection rayx::DesignMap::as_cylinderDirection () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_designplane","title":"function as_designPlane","text":"<pre><code>DesignPlane rayx::DesignMap::as_designPlane () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_dmat4x4","title":"function as_dmat4x4","text":"<pre><code>glm::dmat4 rayx::DesignMap::as_dmat4x4 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_double","title":"function as_double","text":"<pre><code>double rayx::DesignMap::as_double () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_dvec4","title":"function as_dvec4","text":"<pre><code>glm::dvec4 rayx::DesignMap::as_dvec4 () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_electronenergyorientation","title":"function as_electronEnergyOrientation","text":"<pre><code>ElectronEnergyOrientation rayx::DesignMap::as_electronEnergyOrientation () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_elementtype","title":"function as_elementType","text":"<pre><code>ElementType rayx::DesignMap::as_elementType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_energydisttype","title":"function as_energyDistType","text":"<pre><code>EnergyDistributionType rayx::DesignMap::as_energyDistType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_energydistributiontype","title":"function as_energyDistributionType","text":"<pre><code>inline EnergyDistributionType rayx::DesignMap::as_energyDistributionType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_energyspreadtype","title":"function as_energySpreadType","text":"<pre><code>SpreadType rayx::DesignMap::as_energySpreadType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_energyspreadunit","title":"function as_energySpreadUnit","text":"<pre><code>EnergySpreadUnit rayx::DesignMap::as_energySpreadUnit () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_eventtype","title":"function as_eventType","text":"<pre><code>EventType rayx::DesignMap::as_eventType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_figurerotation","title":"function as_figureRotation","text":"<pre><code>FigureRotation rayx::DesignMap::as_figureRotation () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_gratingmount","title":"function as_gratingMount","text":"<pre><code>GratingMount rayx::DesignMap::as_gratingMount () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_int","title":"function as_int","text":"<pre><code>int rayx::DesignMap::as_int () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_map","title":"function as_map","text":"<pre><code>Map rayx::DesignMap::as_map () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_material","title":"function as_material","text":"<pre><code>Material rayx::DesignMap::as_material () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_openingshape","title":"function as_openingShape","text":"<pre><code>CutoutType rayx::DesignMap::as_openingShape () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_rad","title":"function as_rad","text":"<pre><code>Rad rayx::DesignMap::as_rad () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_raylist","title":"function as_rayList","text":"<pre><code>std::shared_ptr&lt; Rays &gt; rayx::DesignMap::as_rayList () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_sigmatype","title":"function as_sigmaType","text":"<pre><code>SigmaType rayx::DesignMap::as_sigmaType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_sourcedist","title":"function as_sourceDist","text":"<pre><code>SourceDist rayx::DesignMap::as_sourceDist () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_string","title":"function as_string","text":"<pre><code>std::string rayx::DesignMap::as_string () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_surface","title":"function as_surface","text":"<pre><code>Surface rayx::DesignMap::as_surface () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-as_surfacecoatingtype","title":"function as_surfaceCoatingType","text":"<pre><code>SurfaceCoatingType rayx::DesignMap::as_surfaceCoatingType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>Iterator rayx::DesignMap::begin () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>ConstIterator rayx::DesignMap::begin () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-clone","title":"function clone","text":"<pre><code>DesignMap rayx::DesignMap::clone () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-end-12","title":"function end [1/2]","text":"<pre><code>Iterator rayx::DesignMap::end () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-end-22","title":"function end [2/2]","text":"<pre><code>ConstIterator rayx::DesignMap::end () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-haskey","title":"function hasKey","text":"<pre><code>bool rayx::DesignMap::hasKey (\n    const std::string &amp; s\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    double x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_1","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    int x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_2","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    bool x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_3","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    const std::string &amp; x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_4","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    Map x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_5","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    glm::dvec4 x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_6","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    glm::dmat4 x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_7","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    Rad x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_8","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    Material x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_9","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    CentralBeamstop x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_10","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    Cutout x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_11","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    CutoutType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_12","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    EventType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_13","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    CylinderDirection x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_14","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    FigureRotation x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_15","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    CurvatureType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_16","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    Surface x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_17","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    SourceDist x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_18","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    SpreadType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_19","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    EnergyDistributionType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_20","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    EnergySpreadUnit x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_21","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    ElectronEnergyOrientation x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_22","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    SigmaType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_23","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    BehaviourType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_24","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    GratingMount x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_25","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    ElementType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_26","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    CrystalType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_27","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    DesignPlane x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_28","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    SurfaceCoatingType x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_29","title":"function operator=","text":"<pre><code>inline void rayx::DesignMap::operator= (\n    std::shared_ptr&lt; Rays &gt; x\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_30","title":"function operator[]","text":"<pre><code>const DesignMap &amp; rayx::DesignMap::operator[] (\n    const std::string &amp; s\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-operator_31","title":"function operator[]","text":"<pre><code>DesignMap &amp; rayx::DesignMap::operator[] (\n    const std::string &amp; s\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap/#function-type","title":"function type","text":"<pre><code>ValueType rayx::DesignMap::type () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/Value.h</code></p>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/","title":"Class rayx::DesignMap::ConstIterator","text":"<p>ClassList &gt; rayx &gt; DesignMap &gt; ConstIterator</p>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#public-types","title":"Public Types","text":"Type Name typedef std::ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef const value_type * pointer typedef const value_type &amp; reference typedef const std::pair&lt; const std::string, std::shared_ptr&lt; DesignMap &gt; &gt; value_type"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#public-functions","title":"Public Functions","text":"Type Name ConstIterator (Map::const_iterator it)  reference operator* () const ConstIterator &amp; operator++ ()  ConstIterator operator++ (int)  pointer operator-&gt; ()"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using rayx::DesignMap::ConstIterator::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using rayx::DesignMap::ConstIterator::iterator_category =  std::forward_iterator_tag;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using rayx::DesignMap::ConstIterator::pointer =  const value_type*;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#typedef-reference","title":"typedef reference","text":"<pre><code>using rayx::DesignMap::ConstIterator::reference =  const value_type&amp;;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using rayx::DesignMap::ConstIterator::value_type =  const std::pair&lt;const std::string, std::shared_ptr&lt;DesignMap&gt; &gt;;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#function-constiterator","title":"function ConstIterator","text":"<pre><code>inline rayx::DesignMap::ConstIterator::ConstIterator (\n    Map::const_iterator it\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#function-operator","title":"function operator*","text":"<pre><code>inline reference rayx::DesignMap::ConstIterator::operator* () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#function-operator_1","title":"function operator++","text":"<pre><code>inline ConstIterator &amp; rayx::DesignMap::ConstIterator::operator++ () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline ConstIterator rayx::DesignMap::ConstIterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline pointer rayx::DesignMap::ConstIterator::operator-&gt; () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#friends-documentation","title":"Friends Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool rayx::DesignMap::ConstIterator::operator!= (\n    const ConstIterator &amp; a,\n    const ConstIterator &amp; b\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1ConstIterator/#friend-operator_1","title":"friend operator==","text":"<pre><code>inline bool rayx::DesignMap::ConstIterator::operator== (\n    const ConstIterator &amp; a,\n    const ConstIterator &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/Value.h</code></p>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/","title":"Class rayx::DesignMap::Iterator","text":"<p>ClassList &gt; rayx &gt; DesignMap &gt; Iterator</p>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#public-types","title":"Public Types","text":"Type Name typedef std::ptrdiff_t difference_type typedef std::forward_iterator_tag iterator_category typedef value_type * pointer typedef value_type &amp; reference typedef std::pair&lt; const std::string, std::shared_ptr&lt; DesignMap &gt; &gt; value_type"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#public-functions","title":"Public Functions","text":"Type Name Iterator (Map::iterator it)  reference operator* () const Iterator &amp; operator++ ()  Iterator operator++ (int)  pointer operator-&gt; ()"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using rayx::DesignMap::Iterator::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using rayx::DesignMap::Iterator::iterator_category =  std::forward_iterator_tag;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using rayx::DesignMap::Iterator::pointer =  value_type*;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#typedef-reference","title":"typedef reference","text":"<pre><code>using rayx::DesignMap::Iterator::reference =  value_type&amp;;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using rayx::DesignMap::Iterator::value_type =  std::pair&lt;const std::string, std::shared_ptr&lt;DesignMap&gt; &gt;;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#function-iterator","title":"function Iterator","text":"<pre><code>inline rayx::DesignMap::Iterator::Iterator (\n    Map::iterator it\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#function-operator","title":"function operator*","text":"<pre><code>inline reference rayx::DesignMap::Iterator::operator* () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#function-operator_1","title":"function operator++","text":"<pre><code>inline Iterator &amp; rayx::DesignMap::Iterator::operator++ () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#function-operator_2","title":"function operator++","text":"<pre><code>inline Iterator rayx::DesignMap::Iterator::operator++ (\n    int\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline pointer rayx::DesignMap::Iterator::operator-&gt; () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#friends-documentation","title":"Friends Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool rayx::DesignMap::Iterator::operator!= (\n    const Iterator &amp; a,\n    const Iterator &amp; b\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignMap_1_1Iterator/#friend-operator_1","title":"friend operator==","text":"<pre><code>inline bool rayx::DesignMap::Iterator::operator== (\n    const Iterator &amp; a,\n    const Iterator &amp; b\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/Value.h</code></p>"},{"location":"rayxCore/classrayx_1_1DesignSource/","title":"Class rayx::DesignSource","text":"<p>ClassList &gt; rayx &gt; DesignSource</p> <p>Inherits the following classes: rayx::BeamlineNode</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#public-attributes","title":"Public Attributes","text":"Type Name DesignMap m_elementParameters"},{"location":"rayxCore/classrayx_1_1DesignSource/#public-functions","title":"Public Functions","text":"Type Name DesignSource ()  DesignSource (std::string name)  DesignSource (const DesignSource &amp; other) = delete DesignSource (DesignSource &amp;&amp; other) noexcept virtual std::unique_ptr&lt; BeamlineNode &gt; clone () override constCreates a deep copy (clone) of this BeamlineNode . double getBendingRadius () const Rad getDeltaOpeningAngle () const double getElectronEnergy () const ElectronEnergyOrientation getElectronEnergyOrientation () const double getElectronSigmaX () const double getElectronSigmaXs () const double getElectronSigmaY () const double getElectronSigmaYs () const double getEnergy () const EnergyDistributionVariant getEnergyDistribution () const EnergyDistributionType getEnergyDistributionType () const double getEnergySpread () const SpreadType getEnergySpreadType () const EnergySpreadUnit getEnergySpreadUnit () const SourceDist getHeightDist () const SourceDist getHorDist () const double getHorDivergence () const Rad getMaxOpeningAngle () const Rad getMinOpeningAngle () const virtual std::string getName () override const int getNumOfCircles () const int getNumberOfRays () const int getNumberOfSeparateEnergies () const virtual glm::dmat4x4 getOrientation () override constGets the local orientation (rotation/transform) of this node. double getPhotonFlux () const virtual glm::dvec4 getPosition () override constGets the local position of this node. std::shared_ptr&lt; Rays &gt; getRayList () const SigmaType getSigmaType () const double getSourceDepth () const double getSourceHeight () const double getSourceWidth () const glm::dvec4 getStokes () const ElementType getType () const double getUndulatorLength () const SourceDist getVerDist () const double getVerDivergence () const double getVerEBeamDivergence () const SourceDist getWidthDist () const virtual bool isSource () override const DesignSource &amp; operator= (const DesignSource &amp; other) = delete DesignSource &amp; operator= (DesignSource &amp;&amp; other) noexcept void setBendingRadius (double value)  void setDeltaOpeningAngle (Rad value)  void setElectronEnergy (double value)  void setElectronEnergyOrientation (ElectronEnergyOrientation value)  void setElectronSigmaX (double value)  void setElectronSigmaXs (double value)  void setElectronSigmaY (double value)  void setElectronSigmaYs (double value)  void setEnergy (double value)  void setEnergyDistributionFile (std::string value)  void setEnergyDistributionType (EnergyDistributionType value)  void setEnergySpread (double value)  void setEnergySpreadType (SpreadType value)  void setEnergySpreadUnit (EnergySpreadUnit value)  void setHeightDist (SourceDist value)  void setHorDist (SourceDist value)  void setHorDivergence (double value)  void setMaxOpeningAngle (Rad value)  void setMinOpeningAngle (Rad value)  virtual void setName (std::string s) override void setNumOfCircles (int value)  void setNumberOfRays (int value)  void setNumberOfSeparateEnergies (int value)  void setOrientation (glm::dmat4x4 o)  void setPhotonFlux (double value)  void setPosition (glm::dvec4 p)  void setRayList (Rays rays)  void setRayList (std::shared_ptr&lt; Rays &gt; &amp; rays)  void setSigmaType (SigmaType value)  void setSourceDepth (double value)  void setSourceHeight (double value)  void setSourceWidth (double value)  void setStokescirc (double value)  void setStokeslin0 (double value)  void setStokeslin45 (double value)  void setType (ElementType s)  void setUndulatorLength (double value)  void setVerDist (SourceDist value)  void setVerDivergence (double value)  void setVerEBeamDivergence (double value)  void setWidthDist (SourceDist value)  ~DesignSource () = default"},{"location":"rayxCore/classrayx_1_1DesignSource/#public-functions-inherited-from-rayxbeamlinenode","title":"Public Functions inherited from rayx::BeamlineNode","text":"<p>See rayx::BeamlineNode</p> Type Name const DesignElement * asElement () const DesignElement * asElement ()  const Group * asGroup () const Group * asGroup ()  const DesignSource * asSource () const DesignSource * asSource ()  virtual std::unique_ptr&lt; BeamlineNode &gt; clone () const = 0Creates a deep copy (clone) of this BeamlineNode . virtual std::string getName () const = 0 int getObjectId () const virtual glm::dmat4 getOrientation () const = 0Gets the local orientation (rotation/transform) of this node. const BeamlineNode * getParent () const BeamlineNode * getParent ()  virtual glm::dvec4 getPosition () const = 0Gets the local position of this node. const BeamlineNode * getRoot () const BeamlineNode * getRoot ()  glm::dmat4 getWorldOrientation () constComputes the absolute/world orientation of this node. glm::dvec4 getWorldPosition () constComputes the absolute/world position of this node. bool hasParent () const virtual bool isElement () const virtual bool isGroup () const virtual bool isSource () const virtual const BeamlineNode * operator[] (size_t index) const virtual BeamlineNode * operator[] (size_t index)  virtual const BeamlineNode * operator[] (const std::string &amp; name) const virtual BeamlineNode * operator[] (const std::string &amp; name)  virtual void setName (std::string name) = 0 virtual ~BeamlineNode () = default"},{"location":"rayxCore/classrayx_1_1DesignSource/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignSource/#variable-m_elementparameters","title":"variable m_elementParameters","text":"<pre><code>DesignMap rayx::DesignSource::m_elementParameters;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DesignSource/#function-designsource-14","title":"function DesignSource [1/4]","text":"<pre><code>rayx::DesignSource::DesignSource () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-designsource-24","title":"function DesignSource [2/4]","text":"<pre><code>rayx::DesignSource::DesignSource (\n    std::string name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-designsource-34","title":"function DesignSource [3/4]","text":"<pre><code>rayx::DesignSource::DesignSource (\n    const DesignSource &amp; other\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-designsource-44","title":"function DesignSource [4/4]","text":"<pre><code>rayx::DesignSource::DesignSource (\n    DesignSource &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-clone","title":"function clone","text":"<p>Creates a deep copy (clone) of this BeamlineNode . <pre><code>virtual std::unique_ptr&lt; BeamlineNode &gt; rayx::DesignSource::clone () override const\n</code></pre></p> <p>Derived classes must implement this to allow duplication of their internal state. </p> <p>Returns:</p> <p>A unique_ptr to the newly cloned BeamlineNode. </p> <p>Implements rayx::BeamlineNode::clone</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getbendingradius","title":"function getBendingRadius","text":"<pre><code>double rayx::DesignSource::getBendingRadius () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getdeltaopeningangle","title":"function getDeltaOpeningAngle","text":"<pre><code>Rad rayx::DesignSource::getDeltaOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronenergy","title":"function getElectronEnergy","text":"<pre><code>double rayx::DesignSource::getElectronEnergy () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronenergyorientation","title":"function getElectronEnergyOrientation","text":"<pre><code>ElectronEnergyOrientation rayx::DesignSource::getElectronEnergyOrientation () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronsigmax","title":"function getElectronSigmaX","text":"<pre><code>double rayx::DesignSource::getElectronSigmaX () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronsigmaxs","title":"function getElectronSigmaXs","text":"<pre><code>double rayx::DesignSource::getElectronSigmaXs () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronsigmay","title":"function getElectronSigmaY","text":"<pre><code>double rayx::DesignSource::getElectronSigmaY () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getelectronsigmays","title":"function getElectronSigmaYs","text":"<pre><code>double rayx::DesignSource::getElectronSigmaYs () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergy","title":"function getEnergy","text":"<pre><code>double rayx::DesignSource::getEnergy () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergydistribution","title":"function getEnergyDistribution","text":"<pre><code>EnergyDistributionVariant rayx::DesignSource::getEnergyDistribution () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergydistributiontype","title":"function getEnergyDistributionType","text":"<pre><code>EnergyDistributionType rayx::DesignSource::getEnergyDistributionType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergyspread","title":"function getEnergySpread","text":"<pre><code>double rayx::DesignSource::getEnergySpread () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergyspreadtype","title":"function getEnergySpreadType","text":"<pre><code>SpreadType rayx::DesignSource::getEnergySpreadType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getenergyspreadunit","title":"function getEnergySpreadUnit","text":"<pre><code>EnergySpreadUnit rayx::DesignSource::getEnergySpreadUnit () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getheightdist","title":"function getHeightDist","text":"<pre><code>SourceDist rayx::DesignSource::getHeightDist () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-gethordist","title":"function getHorDist","text":"<pre><code>SourceDist rayx::DesignSource::getHorDist () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-gethordivergence","title":"function getHorDivergence","text":"<pre><code>double rayx::DesignSource::getHorDivergence () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getmaxopeningangle","title":"function getMaxOpeningAngle","text":"<pre><code>Rad rayx::DesignSource::getMaxOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getminopeningangle","title":"function getMinOpeningAngle","text":"<pre><code>Rad rayx::DesignSource::getMinOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getname","title":"function getName","text":"<pre><code>virtual std::string rayx::DesignSource::getName () override const\n</code></pre> <p>Implements rayx::BeamlineNode::getName</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getnumofcircles","title":"function getNumOfCircles","text":"<pre><code>int rayx::DesignSource::getNumOfCircles () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getnumberofrays","title":"function getNumberOfRays","text":"<pre><code>int rayx::DesignSource::getNumberOfRays () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getnumberofseparateenergies","title":"function getNumberOfSeparateEnergies","text":"<pre><code>int rayx::DesignSource::getNumberOfSeparateEnergies () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getorientation","title":"function getOrientation","text":"<p>Gets the local orientation (rotation/transform) of this node. <pre><code>virtual glm::dmat4x4 rayx::DesignSource::getOrientation () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the local orientation. </p> <p>Implements rayx::BeamlineNode::getOrientation</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getphotonflux","title":"function getPhotonFlux","text":"<pre><code>double rayx::DesignSource::getPhotonFlux () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getposition","title":"function getPosition","text":"<p>Gets the local position of this node. <pre><code>virtual glm::dvec4 rayx::DesignSource::getPosition () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4D vector (dvec4) representing the local position. </p> <p>Implements rayx::BeamlineNode::getPosition</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getraylist","title":"function getRayList","text":"<pre><code>std::shared_ptr&lt; Rays &gt; rayx::DesignSource::getRayList () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getsigmatype","title":"function getSigmaType","text":"<pre><code>SigmaType rayx::DesignSource::getSigmaType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getsourcedepth","title":"function getSourceDepth","text":"<pre><code>double rayx::DesignSource::getSourceDepth () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getsourceheight","title":"function getSourceHeight","text":"<pre><code>double rayx::DesignSource::getSourceHeight () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getsourcewidth","title":"function getSourceWidth","text":"<pre><code>double rayx::DesignSource::getSourceWidth () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getstokes","title":"function getStokes","text":"<pre><code>glm::dvec4 rayx::DesignSource::getStokes () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-gettype","title":"function getType","text":"<pre><code>ElementType rayx::DesignSource::getType () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getundulatorlength","title":"function getUndulatorLength","text":"<pre><code>double rayx::DesignSource::getUndulatorLength () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getverdist","title":"function getVerDist","text":"<pre><code>SourceDist rayx::DesignSource::getVerDist () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getverdivergence","title":"function getVerDivergence","text":"<pre><code>double rayx::DesignSource::getVerDivergence () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getverebeamdivergence","title":"function getVerEBeamDivergence","text":"<pre><code>double rayx::DesignSource::getVerEBeamDivergence () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-getwidthdist","title":"function getWidthDist","text":"<pre><code>SourceDist rayx::DesignSource::getWidthDist () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-issource","title":"function isSource","text":"<pre><code>inline virtual bool rayx::DesignSource::isSource () override const\n</code></pre> <p>Implements rayx::BeamlineNode::isSource</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-operator","title":"function operator=","text":"<pre><code>DesignSource &amp; rayx::DesignSource::operator= (\n    const DesignSource &amp; other\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-operator_1","title":"function operator=","text":"<pre><code>DesignSource &amp; rayx::DesignSource::operator= (\n    DesignSource &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setbendingradius","title":"function setBendingRadius","text":"<pre><code>void rayx::DesignSource::setBendingRadius (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setdeltaopeningangle","title":"function setDeltaOpeningAngle","text":"<pre><code>void rayx::DesignSource::setDeltaOpeningAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronenergy","title":"function setElectronEnergy","text":"<pre><code>void rayx::DesignSource::setElectronEnergy (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronenergyorientation","title":"function setElectronEnergyOrientation","text":"<pre><code>void rayx::DesignSource::setElectronEnergyOrientation (\n    ElectronEnergyOrientation value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronsigmax","title":"function setElectronSigmaX","text":"<pre><code>void rayx::DesignSource::setElectronSigmaX (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronsigmaxs","title":"function setElectronSigmaXs","text":"<pre><code>void rayx::DesignSource::setElectronSigmaXs (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronsigmay","title":"function setElectronSigmaY","text":"<pre><code>void rayx::DesignSource::setElectronSigmaY (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setelectronsigmays","title":"function setElectronSigmaYs","text":"<pre><code>void rayx::DesignSource::setElectronSigmaYs (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergy","title":"function setEnergy","text":"<pre><code>void rayx::DesignSource::setEnergy (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergydistributionfile","title":"function setEnergyDistributionFile","text":"<pre><code>void rayx::DesignSource::setEnergyDistributionFile (\n    std::string value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergydistributiontype","title":"function setEnergyDistributionType","text":"<pre><code>void rayx::DesignSource::setEnergyDistributionType (\n    EnergyDistributionType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergyspread","title":"function setEnergySpread","text":"<pre><code>void rayx::DesignSource::setEnergySpread (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergyspreadtype","title":"function setEnergySpreadType","text":"<pre><code>void rayx::DesignSource::setEnergySpreadType (\n    SpreadType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setenergyspreadunit","title":"function setEnergySpreadUnit","text":"<pre><code>void rayx::DesignSource::setEnergySpreadUnit (\n    EnergySpreadUnit value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setheightdist","title":"function setHeightDist","text":"<pre><code>void rayx::DesignSource::setHeightDist (\n    SourceDist value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-sethordist","title":"function setHorDist","text":"<pre><code>void rayx::DesignSource::setHorDist (\n    SourceDist value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-sethordivergence","title":"function setHorDivergence","text":"<pre><code>void rayx::DesignSource::setHorDivergence (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setmaxopeningangle","title":"function setMaxOpeningAngle","text":"<pre><code>void rayx::DesignSource::setMaxOpeningAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setminopeningangle","title":"function setMinOpeningAngle","text":"<pre><code>void rayx::DesignSource::setMinOpeningAngle (\n    Rad value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setname","title":"function setName","text":"<pre><code>virtual void rayx::DesignSource::setName (\n    std::string s\n) override\n</code></pre> <p>Implements rayx::BeamlineNode::setName</p>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setnumofcircles","title":"function setNumOfCircles","text":"<pre><code>void rayx::DesignSource::setNumOfCircles (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setnumberofrays","title":"function setNumberOfRays","text":"<pre><code>void rayx::DesignSource::setNumberOfRays (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setnumberofseparateenergies","title":"function setNumberOfSeparateEnergies","text":"<pre><code>void rayx::DesignSource::setNumberOfSeparateEnergies (\n    int value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setorientation","title":"function setOrientation","text":"<pre><code>void rayx::DesignSource::setOrientation (\n    glm::dmat4x4 o\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setphotonflux","title":"function setPhotonFlux","text":"<pre><code>void rayx::DesignSource::setPhotonFlux (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setposition","title":"function setPosition","text":"<pre><code>void rayx::DesignSource::setPosition (\n    glm::dvec4 p\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setraylist-12","title":"function setRayList [1/2]","text":"<pre><code>void rayx::DesignSource::setRayList (\n    Rays rays\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setraylist-22","title":"function setRayList [2/2]","text":"<pre><code>void rayx::DesignSource::setRayList (\n    std::shared_ptr&lt; Rays &gt; &amp; rays\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setsigmatype","title":"function setSigmaType","text":"<pre><code>void rayx::DesignSource::setSigmaType (\n    SigmaType value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setsourcedepth","title":"function setSourceDepth","text":"<pre><code>void rayx::DesignSource::setSourceDepth (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setsourceheight","title":"function setSourceHeight","text":"<pre><code>void rayx::DesignSource::setSourceHeight (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setsourcewidth","title":"function setSourceWidth","text":"<pre><code>void rayx::DesignSource::setSourceWidth (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setstokescirc","title":"function setStokescirc","text":"<pre><code>void rayx::DesignSource::setStokescirc (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setstokeslin0","title":"function setStokeslin0","text":"<pre><code>void rayx::DesignSource::setStokeslin0 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setstokeslin45","title":"function setStokeslin45","text":"<pre><code>void rayx::DesignSource::setStokeslin45 (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-settype","title":"function setType","text":"<pre><code>void rayx::DesignSource::setType (\n    ElementType s\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setundulatorlength","title":"function setUndulatorLength","text":"<pre><code>void rayx::DesignSource::setUndulatorLength (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setverdist","title":"function setVerDist","text":"<pre><code>void rayx::DesignSource::setVerDist (\n    SourceDist value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setverdivergence","title":"function setVerDivergence","text":"<pre><code>void rayx::DesignSource::setVerDivergence (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setverebeamdivergence","title":"function setVerEBeamDivergence","text":"<pre><code>void rayx::DesignSource::setVerEBeamDivergence (\n    double value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-setwidthdist","title":"function setWidthDist","text":"<pre><code>void rayx::DesignSource::setWidthDist (\n    SourceDist value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DesignSource/#function-designsource","title":"function ~DesignSource","text":"<pre><code>rayx::DesignSource::~DesignSource () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/DesignSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/","title":"Struct rayx::DeviceConfig","text":"<p>ClassList &gt; rayx &gt; DeviceConfig</p>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#classes","title":"Classes","text":"Type Name struct Device"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; Device &gt; devices"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-functions","title":"Public Functions","text":"Type Name DeviceConfig (DeviceType fetchedDeviceType=DeviceType::All)  DeviceConfig (const DeviceConfig &amp;) = default DeviceConfig (DeviceConfig &amp;&amp;) = default DeviceConfig &amp; disableAllDevices (DeviceType deviceType=DeviceType::All)  DeviceConfig &amp; disableDeviceByIndex (const Device::Index deviceIndex)  void dumpDevices () const DeviceConfig &amp; enableAllDevices (DeviceType deviceType=DeviceType::All)  DeviceConfig &amp; enableBestDevice (DeviceType deviceType=DeviceType::All)  DeviceConfig &amp; enableDeviceByIndex (const Device::Index deviceIndex)  size_t enabledDevicesCount () const DeviceConfig &amp; operator= (const DeviceConfig &amp;) = default DeviceConfig &amp; operator= (DeviceConfig &amp;&amp;) = default"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-static-functions","title":"Public Static Functions","text":"Type Name DeviceType availableDeviceTypes ()"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1DeviceConfig/#variable-devices","title":"variable devices","text":"<pre><code>std::vector&lt;Device&gt; rayx::DeviceConfig::devices;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-deviceconfig-13","title":"function DeviceConfig [1/3]","text":"<pre><code>rayx::DeviceConfig::DeviceConfig (\n    DeviceType fetchedDeviceType=DeviceType::All\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-deviceconfig-23","title":"function DeviceConfig [2/3]","text":"<pre><code>rayx::DeviceConfig::DeviceConfig (\n    const DeviceConfig &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-deviceconfig-33","title":"function DeviceConfig [3/3]","text":"<pre><code>rayx::DeviceConfig::DeviceConfig (\n    DeviceConfig &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-disablealldevices","title":"function disableAllDevices","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::disableAllDevices (\n    DeviceType deviceType=DeviceType::All\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-disabledevicebyindex","title":"function disableDeviceByIndex","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::disableDeviceByIndex (\n    const Device::Index deviceIndex\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-dumpdevices","title":"function dumpDevices","text":"<pre><code>void rayx::DeviceConfig::dumpDevices () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-enablealldevices","title":"function enableAllDevices","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::enableAllDevices (\n    DeviceType deviceType=DeviceType::All\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-enablebestdevice","title":"function enableBestDevice","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::enableBestDevice (\n    DeviceType deviceType=DeviceType::All\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-enabledevicebyindex","title":"function enableDeviceByIndex","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::enableDeviceByIndex (\n    const Device::Index deviceIndex\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-enableddevicescount","title":"function enabledDevicesCount","text":"<pre><code>size_t rayx::DeviceConfig::enabledDevicesCount () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-operator","title":"function operator=","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::operator= (\n    const DeviceConfig &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-operator_1","title":"function operator=","text":"<pre><code>DeviceConfig &amp; rayx::DeviceConfig::operator= (\n    DeviceConfig &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1DeviceConfig/#function-availabledevicetypes","title":"function availableDeviceTypes","text":"<pre><code>static DeviceType rayx::DeviceConfig::availableDeviceTypes () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/DeviceConfig.h</code></p>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/","title":"Struct rayx::DeviceConfig::Device","text":"<p>ClassList &gt; rayx &gt; DeviceConfig &gt; Device</p>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#public-types","title":"Public Types","text":"Type Name typedef size_t Index typedef size_t Score"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#public-attributes","title":"Public Attributes","text":"Type Name bool enable Index index std::string name Score score DeviceType type"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#typedef-index","title":"typedef Index","text":"<pre><code>using rayx::DeviceConfig::Device::Index =  size_t;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#typedef-score","title":"typedef Score","text":"<pre><code>using rayx::DeviceConfig::Device::Score =  size_t;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#variable-enable","title":"variable enable","text":"<pre><code>bool rayx::DeviceConfig::Device::enable;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#variable-index","title":"variable index","text":"<pre><code>Index rayx::DeviceConfig::Device::index;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#variable-name","title":"variable name","text":"<pre><code>std::string rayx::DeviceConfig::Device::name;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#variable-score","title":"variable score","text":"<pre><code>Score rayx::DeviceConfig::Device::score;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1DeviceConfig_1_1Device/#variable-type","title":"variable type","text":"<pre><code>DeviceType rayx::DeviceConfig::Device::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/DeviceConfig.h</code></p>"},{"location":"rayxCore/classrayx_1_1DeviceTracer/","title":"Class rayx::DeviceTracer","text":"<p>ClassList &gt; rayx &gt; DeviceTracer</p> <p>DeviceTracer is an interface to a tracer implementation we need this interface to remove the actual implementation from the rayx api.</p> <ul> <li><code>#include &lt;DeviceTracer.h&gt;</code></li> </ul> <p>Inherited by the following classes: rayx::MegaKernelTracer</p>"},{"location":"rayxCore/classrayx_1_1DeviceTracer/#public-functions","title":"Public Functions","text":"Type Name virtual Rays trace (const Group &amp; beamline, Sequential sequential, const ObjectIndexMask &amp; objectRecordMask, const RayAttrMask attrRecordMask, const int maxEvents, const int maxBatchSize) = 0 virtual ~DeviceTracer () = default"},{"location":"rayxCore/classrayx_1_1DeviceTracer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DeviceTracer/#function-trace","title":"function trace","text":"<pre><code>virtual Rays rayx::DeviceTracer::trace (\n    const Group &amp; beamline,\n    Sequential sequential,\n    const ObjectIndexMask &amp; objectRecordMask,\n    const RayAttrMask attrRecordMask,\n    const int maxEvents,\n    const int maxBatchSize\n) = 0\n</code></pre>"},{"location":"rayxCore/classrayx_1_1DeviceTracer/#function-devicetracer","title":"function ~DeviceTracer","text":"<pre><code>virtual rayx::DeviceTracer::~DeviceTracer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/DeviceTracer.h</code></p>"},{"location":"rayxCore/classrayx_1_1DipoleSource/","title":"Class rayx::DipoleSource","text":"<p>ClassList &gt; rayx &gt; DipoleSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1DipoleSource/#public-functions","title":"Public Functions","text":"Type Name DipoleSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1DipoleSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1DipoleSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1DipoleSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1DipoleSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1DipoleSource/#function-dipolesource","title":"function DipoleSource","text":"<pre><code>rayx::DipoleSource::DipoleSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1DipoleSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::DipoleSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/DipoleSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/","title":"Struct rayx::EnergyDistributionDataBase","text":"<p>ClassList &gt; rayx &gt; EnergyDistributionDataBase</p>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#public-types","title":"Public Types","text":"Type Name typedef rayx::EnergyDistributionList EnergyDistributionList typedef rayx::HardEdge HardEdge typedef rayx::SeparateEnergies SeparateEnergies typedef rayx::SoftEdge SoftEdge"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#typedef-energydistributionlist","title":"typedef EnergyDistributionList","text":"<pre><code>using rayx::EnergyDistributionDataBase::EnergyDistributionList =  rayx::EnergyDistributionList;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#typedef-hardedge","title":"typedef HardEdge","text":"<pre><code>using rayx::EnergyDistributionDataBase::HardEdge =  rayx::HardEdge;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#typedef-separateenergies","title":"typedef SeparateEnergies","text":"<pre><code>using rayx::EnergyDistributionDataBase::SeparateEnergies =  rayx::SeparateEnergies;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionDataBase/#typedef-softedge","title":"typedef SoftEdge","text":"<pre><code>using rayx::EnergyDistributionDataBase::SoftEdge =  rayx::SoftEdge;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/EnergyDistributions/EnergyDistribution.h</code></p>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/","title":"Struct rayx::EnergyDistributionList","text":"<p>ClassList &gt; rayx &gt; EnergyDistributionList</p>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#public-attributes","title":"Public Attributes","text":"Type Name bool continous double *__restrict energies double *__restrict prefixWeights int size double weightSum"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#variable-continous","title":"variable continous","text":"<pre><code>bool rayx::EnergyDistributionList::continous;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#variable-energies","title":"variable energies","text":"<pre><code>double* __restrict rayx::EnergyDistributionList::energies;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#variable-prefixweights","title":"variable prefixWeights","text":"<pre><code>double* __restrict rayx::EnergyDistributionList::prefixWeights;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#variable-size","title":"variable size","text":"<pre><code>int rayx::EnergyDistributionList::size;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1EnergyDistributionList/#variable-weightsum","title":"variable weightSum","text":"<pre><code>double rayx::EnergyDistributionList::weightSum;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/EnergyDistributions/EnergyDistribution.h</code></p>"},{"location":"rayxCore/structrayx_1_1Exit/","title":"Struct rayx::Exit","text":"<p>ClassList &gt; rayx &gt; Exit</p>"},{"location":"rayxCore/structrayx_1_1Exit/#public-attributes","title":"Public Attributes","text":"Type Name std::string filename int line"},{"location":"rayxCore/structrayx_1_1Exit/#public-functions","title":"Public Functions","text":"Type Name Exit (const std::string &amp; filename, int line)  Exit &amp; operator&lt;&lt; (T t)  ~Exit ()"},{"location":"rayxCore/structrayx_1_1Exit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Exit/#variable-filename","title":"variable filename","text":"<pre><code>std::string rayx::Exit::filename;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Exit/#variable-line","title":"variable line","text":"<pre><code>int rayx::Exit::line;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Exit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Exit/#function-exit","title":"function Exit","text":"<pre><code>rayx::Exit::Exit (\n    const std::string &amp; filename,\n    int line\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Exit/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline Exit &amp; rayx::Exit::operator&lt;&lt; (\n    T t\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Exit/#function-exit_1","title":"function ~Exit","text":"<pre><code>rayx::Exit::~Exit () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/structrayx_1_1FresnelCoeffs/","title":"Struct rayx::FresnelCoeffs","text":"<p>ClassList &gt; rayx &gt; FresnelCoeffs</p>"},{"location":"rayxCore/structrayx_1_1FresnelCoeffs/#public-attributes","title":"Public Attributes","text":"Type Name double p double s"},{"location":"rayxCore/structrayx_1_1FresnelCoeffs/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1FresnelCoeffs/#variable-p","title":"variable p","text":"<pre><code>double rayx::FresnelCoeffs::p;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1FresnelCoeffs/#variable-s","title":"variable s","text":"<pre><code>double rayx::FresnelCoeffs::s;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Efficiency.h</code></p>"},{"location":"rayxCore/structrayx_1_1GenRays/","title":"Struct rayx::GenRays","text":"<p>template &lt;typename Acc&gt;</p> <p>ClassList &gt; rayx &gt; GenRays</p>"},{"location":"rayxCore/structrayx_1_1GenRays/#classes","title":"Classes","text":"Type Name struct BatchConfig holds configuration state of one batch struct SourceConfig holds configuration state of sources"},{"location":"rayxCore/structrayx_1_1GenRays/#public-functions","title":"Public Functions","text":"Type Name BatchConfig genRaysBatch (DevAcc devAcc, Queue q, const int batchIndex)  SourceConfig update (Queue q, const Group &amp; beamline, const int maxBatchSize)"},{"location":"rayxCore/structrayx_1_1GenRays/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1GenRays/#function-genraysbatch","title":"function genRaysBatch","text":"<pre><code>template&lt;typename DevAcc, typename Queue&gt;\ninline BatchConfig rayx::GenRays::genRaysBatch (\n    DevAcc devAcc,\n    Queue q,\n    const int batchIndex\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays/#function-update","title":"function update","text":"<pre><code>template&lt;typename Queue&gt;\ninline SourceConfig rayx::GenRays::update (\n    Queue q,\n    const Group &amp; beamline,\n    const int maxBatchSize\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1BatchConfig/","title":"Struct rayx::GenRays::BatchConfig","text":"<p>ClassList &gt; rayx &gt; GenRays &gt; BatchConfig</p> <p>holds configuration state of one batch </p> <ul> <li><code>#include &lt;GenRays.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1BatchConfig/#public-attributes","title":"Public Attributes","text":"Type Name RaysBuf&lt; Acc &gt; d_rays int numRaysBatch"},{"location":"rayxCore/structrayx_1_1GenRays_1_1BatchConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1GenRays_1_1BatchConfig/#variable-d_rays","title":"variable d_rays","text":"<pre><code>RaysBuf&lt;Acc&gt; rayx::GenRays&lt; Acc &gt;::BatchConfig::d_rays;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1BatchConfig/#variable-numraysbatch","title":"variable numRaysBatch","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::BatchConfig::numRaysBatch;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/","title":"Struct rayx::GenRays::SourceConfig","text":"<p>ClassList &gt; rayx &gt; GenRays &gt; SourceConfig</p> <p>holds configuration state of sources </p> <ul> <li><code>#include &lt;GenRays.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/#public-attributes","title":"Public Attributes","text":"Type Name int numBatches int numRaysBatchAtMost int numRaysTotal"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/#variable-numbatches","title":"variable numBatches","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::SourceConfig::numBatches;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/#variable-numraysbatchatmost","title":"variable numRaysBatchAtMost","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::SourceConfig::numRaysBatchAtMost;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceConfig/#variable-numraystotal","title":"variable numRaysTotal","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::SourceConfig::numRaysTotal;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/classrayx_1_1Group/","title":"Class rayx::Group","text":"<p>ClassList &gt; rayx &gt; Group</p> <p>More...</p> <ul> <li><code>#include &lt;Beamline.h&gt;</code></li> </ul> <p>Inherits the following classes: rayx::BeamlineNode</p>"},{"location":"rayxCore/classrayx_1_1Group/#public-functions","title":"Public Functions","text":"Type Name Group ()  Group (std::string name)  Group (const Group &amp;) = delete Group (Group &amp;&amp; other) noexcept void addChild (std::unique_ptr&lt; BeamlineNode &gt; child) Adds a child to this Group . auto begin ()  auto begin () const MaterialTables calcMinimalMaterialTables () constCalculates the minimal set of material tables required by elements in this Group . auto cbegin () const auto cend () const virtual std::unique_ptr&lt; BeamlineNode &gt; clone () override constCreates a deep copy of this group and its children. std::vector&lt; OpticalElementAndTransform &gt; compileElements () constRecursively converts all DesignElement nodes into OpticalElements with full transforms. void ctraverse (const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; callback) constRecursively traverse the model/scene graph down from this node. auto end ()  auto end () const const DesignElement * findElement (const std::function&lt; bool(const DesignElement &amp;)&gt; &amp; pred) const DesignElement * findElement (const std::function&lt; bool(const DesignElement &amp;)&gt; &amp; pred)  const DesignElement * findElementByName (const std::string &amp; name) const DesignElement * findElementByName (const std::string &amp; name)  const Group * findGroup (const std::function&lt; bool(const Group &amp;)&gt; &amp; pred) const Group * findGroup (const std::function&lt; bool(const Group &amp;)&gt; &amp; pred)  const Group * findGroupByName (const std::string &amp; name) const Group * findGroupByName (const std::string &amp; name)  const BeamlineNode * findNode (const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; pred) const BeamlineNode * findNode (const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; pred)  const BeamlineNode * findNodeByName (const std::string &amp; name) const BeamlineNode * findNodeByName (const std::string &amp; name)  const BeamlineNode * findNodeByObjectId (const size_t objectId) const BeamlineNode * findNodeByObjectId (const size_t objectId)  size_t findObjectIdByNode (const BeamlineNode * node) const const DesignSource * findSource (const std::function&lt; bool(const DesignSource &amp;)&gt; &amp; pred) const DesignSource * findSource (const std::function&lt; bool(const DesignSource &amp;)&gt; &amp; pred)  const DesignSource * findSourceByName (const std::string &amp; name) const DesignSource * findSourceByName (const std::string &amp; name)  const std::vector&lt; std::unique_ptr&lt; BeamlineNode &gt; &gt; &amp; getChildren () const std::vector&lt; std::string &gt; getElementNames () const std::vector&lt; const DesignElement * &gt; getElements () const virtual std::string getName () override const std::vector&lt; std::string &gt; getObjectNames () const virtual glm::dmat4 getOrientation () override constGets the local orientation (rotation/transform) of this node. virtual glm::dvec4 getPosition () override constGets the local position of this node. std::vector&lt; std::string &gt; getSourceNames () const std::vector&lt; const DesignSource * &gt; getSources () const virtual bool isGroup () override const size_t numElements () const size_t numObjects () const size_t numRayPaths () const size_t numSources () const Group &amp; operator= (const Group &amp;) = delete Group &amp; operator= (Group &amp;&amp; other) noexcept virtual const BeamlineNode * operator[] (size_t index) override const virtual BeamlineNode * operator[] (size_t index) override virtual const BeamlineNode * operator[] (const std::string &amp; name) override const virtual BeamlineNode * operator[] (const std::string &amp; name) override std::unique_ptr&lt; BeamlineNode &gt; releaseNodeFromChildren (const BeamlineNode * node)  std::unique_ptr&lt; BeamlineNode &gt; releaseNodeFromTree (const BeamlineNode * node)  virtual void setName (std::string name) override void setOrientation (const glm::dmat4 &amp; orientation)  void setPosition (const glm::dvec4 &amp; pos)  void traverse (const std::function&lt; bool(BeamlineNode &amp;)&gt; &amp; callback) Recursively traverses this Group and its children (non-const). ~Group () = default"},{"location":"rayxCore/classrayx_1_1Group/#public-functions-inherited-from-rayxbeamlinenode","title":"Public Functions inherited from rayx::BeamlineNode","text":"<p>See rayx::BeamlineNode</p> Type Name const DesignElement * asElement () const DesignElement * asElement ()  const Group * asGroup () const Group * asGroup ()  const DesignSource * asSource () const DesignSource * asSource ()  virtual std::unique_ptr&lt; BeamlineNode &gt; clone () const = 0Creates a deep copy (clone) of this BeamlineNode . virtual std::string getName () const = 0 int getObjectId () const virtual glm::dmat4 getOrientation () const = 0Gets the local orientation (rotation/transform) of this node. const BeamlineNode * getParent () const BeamlineNode * getParent ()  virtual glm::dvec4 getPosition () const = 0Gets the local position of this node. const BeamlineNode * getRoot () const BeamlineNode * getRoot ()  glm::dmat4 getWorldOrientation () constComputes the absolute/world orientation of this node. glm::dvec4 getWorldPosition () constComputes the absolute/world position of this node. bool hasParent () const virtual bool isElement () const virtual bool isGroup () const virtual bool isSource () const virtual const BeamlineNode * operator[] (size_t index) const virtual BeamlineNode * operator[] (size_t index)  virtual const BeamlineNode * operator[] (const std::string &amp; name) const virtual BeamlineNode * operator[] (const std::string &amp; name)  virtual void setName (std::string name) = 0 virtual ~BeamlineNode () = default"},{"location":"rayxCore/classrayx_1_1Group/#public-static-functions","title":"Public Static Functions","text":"Type Name void accumulateLightSourcesWorldPositions (const Group &amp; group, const glm::dvec4 &amp; parentPos, const glm::dmat4 &amp; parentOri, std::vector&lt; glm::dvec4 &gt; &amp; positions) Gathers the world positions of all light sources within a Group hierarchy."},{"location":"rayxCore/classrayx_1_1Group/#detailed-description","title":"Detailed Description","text":"<p>A beamline group that can contain child nodes (elements, sources, or other groups). A Group is a building block for the model/scene graph. </p>"},{"location":"rayxCore/classrayx_1_1Group/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1Group/#function-group-14","title":"function Group [1/4]","text":"<pre><code>rayx::Group::Group () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-group-24","title":"function Group [2/4]","text":"<pre><code>rayx::Group::Group (\n    std::string name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-group-34","title":"function Group [3/4]","text":"<pre><code>rayx::Group::Group (\n    const Group &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-group-44","title":"function Group [4/4]","text":"<pre><code>rayx::Group::Group (\n    Group &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-addchild","title":"function addChild","text":"<p>Adds a child to this Group . <pre><code>void rayx::Group::addChild (\n    std::unique_ptr&lt; BeamlineNode &gt; child\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>child</code> A unique_ptr to a BeamlineNode to be moved into this Group. </li> </ul>"},{"location":"rayxCore/classrayx_1_1Group/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>inline auto rayx::Group::begin () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>inline auto rayx::Group::begin () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-calcminimalmaterialtables","title":"function calcMinimalMaterialTables","text":"<p>Calculates the minimal set of material tables required by elements in this Group . <pre><code>MaterialTables rayx::Group::calcMinimalMaterialTables () const\n</code></pre></p> <p>Gathers the material IDs used by all child DesignElements and merges them into a single MaterialTables object.</p> <p>Returns:</p> <p>A MaterialTables object with data for all relevant materials. </p>"},{"location":"rayxCore/classrayx_1_1Group/#function-cbegin","title":"function cbegin","text":"<pre><code>inline auto rayx::Group::cbegin () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-cend","title":"function cend","text":"<pre><code>inline auto rayx::Group::cend () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-clone","title":"function clone","text":"<p>Creates a deep copy of this group and its children. <pre><code>virtual std::unique_ptr&lt; BeamlineNode &gt; rayx::Group::clone () override const\n</code></pre></p> <p>Returns:</p> <p>unique_ptr to the base class (can be statically casted) </p> <p>Implements rayx::BeamlineNode::clone</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-compileelements","title":"function compileElements","text":"<p>Recursively converts all DesignElement nodes into OpticalElements with full transforms. <pre><code>std::vector&lt; OpticalElementAndTransform &gt; rayx::Group::compileElements () const\n</code></pre></p> <p>Returns:</p> <p>A vector of OpticalElementAndTransform objects compiled from the Group hierarchy. </p>"},{"location":"rayxCore/classrayx_1_1Group/#function-ctraverse","title":"function ctraverse","text":"<p>Recursively traverse the model/scene graph down from this node. <pre><code>void rayx::Group::ctraverse (\n    const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; callback\n) const\n</code></pre></p> <p>Calls the <code>callback</code> function on each node.</p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function which takes a BeamlineNode reference and returns a bool. Returning true stops the traversal and returning false continues it. </li> </ul>"},{"location":"rayxCore/classrayx_1_1Group/#function-end-12","title":"function end [1/2]","text":"<pre><code>inline auto rayx::Group::end () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-end-22","title":"function end [2/2]","text":"<pre><code>inline auto rayx::Group::end () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findelement-12","title":"function findElement [1/2]","text":"<pre><code>const DesignElement * rayx::Group::findElement (\n    const std::function&lt; bool(const DesignElement &amp;)&gt; &amp; pred\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findelement-22","title":"function findElement [2/2]","text":"<pre><code>DesignElement * rayx::Group::findElement (\n    const std::function&lt; bool(const DesignElement &amp;)&gt; &amp; pred\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findelementbyname-12","title":"function findElementByName [1/2]","text":"<pre><code>const DesignElement * rayx::Group::findElementByName (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findelementbyname-22","title":"function findElementByName [2/2]","text":"<pre><code>DesignElement * rayx::Group::findElementByName (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findgroup-12","title":"function findGroup [1/2]","text":"<pre><code>const Group * rayx::Group::findGroup (\n    const std::function&lt; bool(const Group &amp;)&gt; &amp; pred\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findgroup-22","title":"function findGroup [2/2]","text":"<pre><code>Group * rayx::Group::findGroup (\n    const std::function&lt; bool(const Group &amp;)&gt; &amp; pred\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findgroupbyname-12","title":"function findGroupByName [1/2]","text":"<pre><code>const Group * rayx::Group::findGroupByName (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findgroupbyname-22","title":"function findGroupByName [2/2]","text":"<pre><code>Group * rayx::Group::findGroupByName (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnode-12","title":"function findNode [1/2]","text":"<pre><code>const BeamlineNode * rayx::Group::findNode (\n    const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; pred\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnode-22","title":"function findNode [2/2]","text":"<pre><code>BeamlineNode * rayx::Group::findNode (\n    const std::function&lt; bool(const BeamlineNode &amp;)&gt; &amp; pred\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnodebyname-12","title":"function findNodeByName [1/2]","text":"<pre><code>const BeamlineNode * rayx::Group::findNodeByName (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnodebyname-22","title":"function findNodeByName [2/2]","text":"<pre><code>BeamlineNode * rayx::Group::findNodeByName (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnodebyobjectid-12","title":"function findNodeByObjectId [1/2]","text":"<pre><code>const BeamlineNode * rayx::Group::findNodeByObjectId (\n    const size_t objectId\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findnodebyobjectid-22","title":"function findNodeByObjectId [2/2]","text":"<pre><code>BeamlineNode * rayx::Group::findNodeByObjectId (\n    const size_t objectId\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findobjectidbynode","title":"function findObjectIdByNode","text":"<pre><code>size_t rayx::Group::findObjectIdByNode (\n    const BeamlineNode * node\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findsource-12","title":"function findSource [1/2]","text":"<pre><code>const DesignSource * rayx::Group::findSource (\n    const std::function&lt; bool(const DesignSource &amp;)&gt; &amp; pred\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findsource-22","title":"function findSource [2/2]","text":"<pre><code>DesignSource * rayx::Group::findSource (\n    const std::function&lt; bool(const DesignSource &amp;)&gt; &amp; pred\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findsourcebyname-12","title":"function findSourceByName [1/2]","text":"<pre><code>const DesignSource * rayx::Group::findSourceByName (\n    const std::string &amp; name\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-findsourcebyname-22","title":"function findSourceByName [2/2]","text":"<pre><code>DesignSource * rayx::Group::findSourceByName (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getchildren","title":"function getChildren","text":"<pre><code>inline const std::vector&lt; std::unique_ptr&lt; BeamlineNode &gt; &gt; &amp; rayx::Group::getChildren () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getelementnames","title":"function getElementNames","text":"<pre><code>std::vector&lt; std::string &gt; rayx::Group::getElementNames () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getelements","title":"function getElements","text":"<pre><code>std::vector&lt; const DesignElement * &gt; rayx::Group::getElements () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getname","title":"function getName","text":"<pre><code>virtual std::string rayx::Group::getName () override const\n</code></pre> <p>Implements rayx::BeamlineNode::getName</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-getobjectnames","title":"function getObjectNames","text":"<pre><code>std::vector&lt; std::string &gt; rayx::Group::getObjectNames () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getorientation","title":"function getOrientation","text":"<p>Gets the local orientation (rotation/transform) of this node. <pre><code>inline virtual glm::dmat4 rayx::Group::getOrientation () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4x4 matrix (dmat4) representing the local orientation. </p> <p>Implements rayx::BeamlineNode::getOrientation</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-getposition","title":"function getPosition","text":"<p>Gets the local position of this node. <pre><code>inline virtual glm::dvec4 rayx::Group::getPosition () override const\n</code></pre></p> <p>Each node may have its own transform relative to its parent. </p> <p>Returns:</p> <p>A 4D vector (dvec4) representing the local position. </p> <p>Implements rayx::BeamlineNode::getPosition</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-getsourcenames","title":"function getSourceNames","text":"<pre><code>std::vector&lt; std::string &gt; rayx::Group::getSourceNames () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-getsources","title":"function getSources","text":"<pre><code>std::vector&lt; const DesignSource * &gt; rayx::Group::getSources () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-isgroup","title":"function isGroup","text":"<pre><code>inline virtual bool rayx::Group::isGroup () override const\n</code></pre> <p>Implements rayx::BeamlineNode::isGroup</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-numelements","title":"function numElements","text":"<pre><code>size_t rayx::Group::numElements () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-numobjects","title":"function numObjects","text":"<pre><code>size_t rayx::Group::numObjects () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-numraypaths","title":"function numRayPaths","text":"<pre><code>size_t rayx::Group::numRayPaths () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-numsources","title":"function numSources","text":"<pre><code>size_t rayx::Group::numSources () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator","title":"function operator=","text":"<pre><code>Group &amp; rayx::Group::operator= (\n    const Group &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator_1","title":"function operator=","text":"<pre><code>Group &amp; rayx::Group::operator= (\n    Group &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator_2","title":"function operator[]","text":"<pre><code>virtual const BeamlineNode * rayx::Group::operator[] (\n    size_t index\n) override const\n</code></pre> <p>Implements rayx::BeamlineNode::operator[]</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator_3","title":"function operator[]","text":"<pre><code>virtual BeamlineNode * rayx::Group::operator[] (\n    size_t index\n) override\n</code></pre> <p>Implements rayx::BeamlineNode::operator[]</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator_4","title":"function operator[]","text":"<pre><code>virtual const BeamlineNode * rayx::Group::operator[] (\n    const std::string &amp; name\n) override const\n</code></pre> <p>Implements rayx::BeamlineNode::operator[]</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-operator_5","title":"function operator[]","text":"<pre><code>virtual BeamlineNode * rayx::Group::operator[] (\n    const std::string &amp; name\n) override\n</code></pre> <p>Implements rayx::BeamlineNode::operator[]</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-releasenodefromchildren","title":"function releaseNodeFromChildren","text":"<pre><code>std::unique_ptr&lt; BeamlineNode &gt; rayx::Group::releaseNodeFromChildren (\n    const BeamlineNode * node\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-releasenodefromtree","title":"function releaseNodeFromTree","text":"<pre><code>std::unique_ptr&lt; BeamlineNode &gt; rayx::Group::releaseNodeFromTree (\n    const BeamlineNode * node\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-setname","title":"function setName","text":"<pre><code>virtual void rayx::Group::setName (\n    std::string name\n) override\n</code></pre> <p>Implements rayx::BeamlineNode::setName</p>"},{"location":"rayxCore/classrayx_1_1Group/#function-setorientation","title":"function setOrientation","text":"<pre><code>inline void rayx::Group::setOrientation (\n    const glm::dmat4 &amp; orientation\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-setposition","title":"function setPosition","text":"<pre><code>inline void rayx::Group::setPosition (\n    const glm::dvec4 &amp; pos\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#function-traverse","title":"function traverse","text":"<p>Recursively traverses this Group and its children (non-const). <pre><code>void rayx::Group::traverse (\n    const std::function&lt; bool( BeamlineNode &amp;)&gt; &amp; callback\n) \n</code></pre></p> <p>Calls <code>callback</code> on each node (including nested Groups). If the callback returns true at any point, the traversal stops early.</p> <p>Parameters:</p> <ul> <li><code>callback</code> A function that takes a BeamlineNode&amp; and returns a bool (true = stop traversal, false = continue). </li> </ul>"},{"location":"rayxCore/classrayx_1_1Group/#function-group","title":"function ~Group","text":"<pre><code>rayx::Group::~Group () = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Group/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1Group/#function-accumulatelightsourcesworldpositions","title":"function accumulateLightSourcesWorldPositions","text":"<p>Gathers the world positions of all light sources within a Group hierarchy. <pre><code>static void rayx::Group::accumulateLightSourcesWorldPositions (\n    const Group &amp; group,\n    const glm::dvec4 &amp; parentPos,\n    const glm::dmat4 &amp; parentOri,\n    std::vector&lt; glm::dvec4 &gt; &amp; positions\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>group</code> A reference to the current Group to process. </li> <li><code>parentPos</code> The position of the parent Group (in world coords). </li> <li><code>parentOri</code> The orientation of the parent Group (in world coords). </li> <li><code>positions</code> A reference to a vector of world positions. New positions are appended. </li> </ul> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/Beamline.h</code></p>"},{"location":"rayxCore/structrayx_1_1HardEdge/","title":"Struct rayx::HardEdge","text":"<p>ClassList &gt; rayx &gt; HardEdge</p> <p>More...</p> <ul> <li><code>#include &lt;EnergyDistribution.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1HardEdge/#public-attributes","title":"Public Attributes","text":"Type Name double m_centerEnergy double m_energySpread"},{"location":"rayxCore/structrayx_1_1HardEdge/#public-functions","title":"Public Functions","text":"Type Name HardEdge (double centerEnergy, double energySpread)"},{"location":"rayxCore/structrayx_1_1HardEdge/#detailed-description","title":"Detailed Description","text":"<p>Describes a uniform distribution over the interval <code>[m_CenterEnergy - m_EnergySpread/2, m_CenterEnergy + m_EnergySpread/2]</code>. https://en.wikipedia.org/wiki/Discrete_uniform_distribution </p>"},{"location":"rayxCore/structrayx_1_1HardEdge/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1HardEdge/#variable-m_centerenergy","title":"variable m_centerEnergy","text":"<pre><code>double rayx::HardEdge::m_centerEnergy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1HardEdge/#variable-m_energyspread","title":"variable m_energySpread","text":"<pre><code>double rayx::HardEdge::m_energySpread;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1HardEdge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1HardEdge/#function-hardedge","title":"function HardEdge","text":"<pre><code>inline rayx::HardEdge::HardEdge (\n    double centerEnergy,\n    double energySpread\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/EnergyDistribution.h</code></p>"},{"location":"rayxCore/structrayx_1_1IgnoreLog/","title":"Struct rayx::IgnoreLog","text":"<p>ClassList &gt; rayx &gt; IgnoreLog</p>"},{"location":"rayxCore/structrayx_1_1IgnoreLog/#public-functions","title":"Public Functions","text":"Type Name IgnoreLog &amp; operator&lt;&lt; (T)"},{"location":"rayxCore/structrayx_1_1IgnoreLog/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1IgnoreLog/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline IgnoreLog &amp; rayx::IgnoreLog::operator&lt;&lt; (\n    T\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/","title":"Class rayx::InstrumentationTimer","text":"<p>ClassList &gt; rayx &gt; InstrumentationTimer</p>"},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/#public-functions","title":"Public Functions","text":"Type Name InstrumentationTimer (const char * name, bool canPrint)  void Stop ()  ~InstrumentationTimer ()"},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/#function-instrumentationtimer","title":"function InstrumentationTimer","text":"<pre><code>inline rayx::InstrumentationTimer::InstrumentationTimer (\n    const char * name,\n    bool canPrint\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/#function-stop","title":"function Stop","text":"<pre><code>inline void rayx::InstrumentationTimer::Stop () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1InstrumentationTimer/#function-instrumentationtimer_1","title":"function ~InstrumentationTimer","text":"<pre><code>inline rayx::InstrumentationTimer::~InstrumentationTimer () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Instrumentor.h</code></p>"},{"location":"rayxCore/classrayx_1_1LightSourceBase/","title":"Class rayx::LightSourceBase","text":"<p>ClassList &gt; rayx &gt; LightSourceBase</p> <p>Inherited by the following classes: rayx::CircleSource,  rayx::DipoleSource,  rayx::MatrixSource,  rayx::PixelSource,  rayx::PointSource,  rayx::SimpleUndulatorSource</p>"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-attributes","title":"Protected Attributes","text":"Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-functions","title":"Protected Functions","text":"Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-static-functions","title":"Protected Static Functions","text":"Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"rayxCore/classrayx_1_1LightSourceBase/#variable-m_numberofrays","title":"variable m_numberOfRays","text":"<pre><code>int32_t rayx::LightSourceBase::m_numberOfRays;\n</code></pre>"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1LightSourceBase/#function-lightsourcebase","title":"function LightSourceBase","text":"<pre><code>rayx::LightSourceBase::LightSourceBase (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1LightSourceBase/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1LightSourceBase/#function-getdirectionfromangles","title":"function getDirectionFromAngles","text":"<pre><code>static RAYX_FN_ACC glm::dvec3 rayx::LightSourceBase::getDirectionFromAngles (\n    double phi,\n    double psi\n) \n</code></pre> <p>yields the average energy of the energy distribution m_EnergyDistribution </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/LightSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1Log/","title":"Struct rayx::Log","text":"<p>ClassList &gt; rayx &gt; Log</p> <p>More...</p> <ul> <li><code>#include &lt;Debug.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1Log/#public-functions","title":"Public Functions","text":"Type Name Log (std::string filename, int line)  Log &amp; operator&lt;&lt; (T t)  ~Log ()"},{"location":"rayxCore/structrayx_1_1Log/#detailed-description","title":"Detailed Description","text":"<p>In the following we define RAYX_LOG: prints to std::cout RAYX_EXIT: prints to std::cerr ... and their debug-only variants RAYX_D_LOG, RAYX_D_ERR.</p> <p>example usage: RAYX_LOG &lt;&lt; \"I am \" &lt;&lt; age &lt;&lt; \" years old\"; </p>"},{"location":"rayxCore/structrayx_1_1Log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Log/#function-log","title":"function Log","text":"<pre><code>rayx::Log::Log (\n    std::string filename,\n    int line\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Log/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline Log &amp; rayx::Log::operator&lt;&lt; (\n    T t\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Log/#function-log_1","title":"function ~Log","text":"<pre><code>rayx::Log::~Log () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/structrayx_1_1MaterialTables/","title":"Struct rayx::MaterialTables","text":"<p>ClassList &gt; rayx &gt; MaterialTables</p>"},{"location":"rayxCore/structrayx_1_1MaterialTables/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; int &gt; indices std::vector&lt; double &gt; materials"},{"location":"rayxCore/structrayx_1_1MaterialTables/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1MaterialTables/#variable-indices","title":"variable indices","text":"<pre><code>std::vector&lt;int&gt; rayx::MaterialTables::indices;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1MaterialTables/#variable-materials","title":"variable materials","text":"<pre><code>std::vector&lt;double&gt; rayx::MaterialTables::materials;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/Material.h</code></p>"},{"location":"rayxCore/classrayx_1_1MatrixSource/","title":"Class rayx::MatrixSource","text":"<p>ClassList &gt; rayx &gt; MatrixSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1MatrixSource/#public-functions","title":"Public Functions","text":"Type Name MatrixSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1MatrixSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1MatrixSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1MatrixSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1MatrixSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1MatrixSource/#function-matrixsource","title":"function MatrixSource","text":"<pre><code>rayx::MatrixSource::MatrixSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1MatrixSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::MatrixSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/MatrixSource.h</code></p>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/","title":"Class rayx::MegaKernelTracer","text":"<p>template &lt;typename AccTag&gt;</p> <p>ClassList &gt; rayx &gt; MegaKernelTracer</p> <p>More...</p> <ul> <li><code>#include &lt;MegaKernelTracer.h&gt;</code></li> </ul> <p>Inherits the following classes: rayx::DeviceTracer</p>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#public-functions","title":"Public Functions","text":"Type Name MegaKernelTracer (int deviceIndex)  MegaKernelTracer (const MegaKernelTracer &amp;) = delete MegaKernelTracer (MegaKernelTracer &amp;&amp;) = default MegaKernelTracer &amp; operator= (const MegaKernelTracer &amp;) = delete MegaKernelTracer &amp; operator= (MegaKernelTracer &amp;&amp;) = default virtual Rays trace (const Group &amp; beamline, Sequential sequential, const ObjectIndexMask &amp; objectRecordMask, const RayAttrMask attrRecordMask, const int maxEventsElements, const int maxBatchSize) override"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#public-functions-inherited-from-rayxdevicetracer","title":"Public Functions inherited from rayx::DeviceTracer","text":"<p>See rayx::DeviceTracer</p> Type Name virtual Rays trace (const Group &amp; beamline, Sequential sequential, const ObjectIndexMask &amp; objectRecordMask, const RayAttrMask attrRecordMask, const int maxEvents, const int maxBatchSize) = 0 virtual ~DeviceTracer () = default"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#detailed-description","title":"Detailed Description","text":"<p>The MegaKernelTracer class implements a ray tracer using a mega-kernel strategy.</p> <p>This tracer processes rays in batches as they propagate through a beamline. It generates rays from source definitions, traces them through optical elements, and records interactions according to configurable event masks.</p> <p>Key features: * Supports both sequential and non-sequential ray tracing modes. * Uses Alpaka to enable parallel execution across multiple backends (CPU, GPU, etc.). * Manages critical resources such as ray buffers, event buffers, and material data, ensuring optimized memory usage and efficient host\u2013device data transfers.</p> <p>Workflow: * Generate rays from sources. * Execute the mega-kernel tracing function. * Compact recorded events to optimize memory transfers. * Transfer compacted recorded events back to the host. * Aggregate results from all batches into a final Rays object for output. </p>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-megakerneltracer-13","title":"function MegaKernelTracer [1/3]","text":"<pre><code>inline explicit rayx::MegaKernelTracer::MegaKernelTracer (\n    int deviceIndex\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-megakerneltracer-23","title":"function MegaKernelTracer [2/3]","text":"<pre><code>rayx::MegaKernelTracer::MegaKernelTracer (\n    const MegaKernelTracer &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-megakerneltracer-33","title":"function MegaKernelTracer [3/3]","text":"<pre><code>rayx::MegaKernelTracer::MegaKernelTracer (\n    MegaKernelTracer &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-operator","title":"function operator=","text":"<pre><code>MegaKernelTracer &amp; rayx::MegaKernelTracer::operator= (\n    const MegaKernelTracer &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-operator_1","title":"function operator=","text":"<pre><code>MegaKernelTracer &amp; rayx::MegaKernelTracer::operator= (\n    MegaKernelTracer &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1MegaKernelTracer/#function-trace","title":"function trace","text":"<pre><code>inline virtual Rays rayx::MegaKernelTracer::trace (\n    const Group &amp; beamline,\n    Sequential sequential,\n    const ObjectIndexMask &amp; objectRecordMask,\n    const RayAttrMask attrRecordMask,\n    const int maxEventsElements,\n    const int maxBatchSize\n) override\n</code></pre> <p>Implements rayx::DeviceTracer::trace</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/MegaKernelTracer.h</code></p>"},{"location":"rayxCore/structrayx_1_1MutableState/","title":"Struct rayx::MutableState","text":"<p>ClassList &gt; rayx &gt; MutableState</p> <p>stores all mutable buffers </p> <ul> <li><code>#include &lt;InvocationState.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1MutableState/#public-attributes","title":"Public Attributes","text":"Type Name RaysPtr events bool *__restrict storedFlags"},{"location":"rayxCore/structrayx_1_1MutableState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1MutableState/#variable-events","title":"variable events","text":"<pre><code>RaysPtr rayx::MutableState::events;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1MutableState/#variable-storedflags","title":"variable storedFlags","text":"<pre><code>bool* __restrict rayx::MutableState::storedFlags;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/InvocationState.h</code></p>"},{"location":"rayxCore/structrayx_1_1NffEntry/","title":"Struct rayx::NffEntry","text":"<p>ClassList &gt; rayx &gt; NffEntry</p> <p>This struct represents one line of a .nff file. </p> <ul> <li><code>#include &lt;RefractiveIndex.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1NffEntry/#public-attributes","title":"Public Attributes","text":"Type Name double m_energy double m_f1 double m_f2"},{"location":"rayxCore/structrayx_1_1NffEntry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1NffEntry/#variable-m_energy","title":"variable m_energy","text":"<pre><code>double rayx::NffEntry::m_energy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1NffEntry/#variable-m_f1","title":"variable m_f1","text":"<pre><code>double rayx::NffEntry::m_f1;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1NffEntry/#variable-m_f2","title":"variable m_f2","text":"<pre><code>double rayx::NffEntry::m_f2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RefractiveIndex.h</code></p>"},{"location":"rayxCore/structrayx_1_1NffTable/","title":"Struct rayx::NffTable","text":"<p>ClassList &gt; rayx &gt; NffTable</p> <p>More...</p> <ul> <li><code>#include &lt;NffTable.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1NffTable/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; NffEntry &gt; m_Lines std::string m_element"},{"location":"rayxCore/structrayx_1_1NffTable/#public-static-functions","title":"Public Static Functions","text":"Type Name bool load (const char * element, NffTable * out)"},{"location":"rayxCore/structrayx_1_1NffTable/#detailed-description","title":"Detailed Description","text":"<p>This struct represents the contents of a .NKP file.</p> <p>Example usage:</p> <p>NffTable cu; bool success = NffTable::load(\"CU\", &amp;cu); // the refractive index table for copper! </p>"},{"location":"rayxCore/structrayx_1_1NffTable/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1NffTable/#variable-m_lines","title":"variable m_Lines","text":"<pre><code>std::vector&lt;NffEntry&gt; rayx::NffTable::m_Lines;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1NffTable/#variable-m_element","title":"variable m_element","text":"<pre><code>std::string rayx::NffTable::m_element;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1NffTable/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1NffTable/#function-load","title":"function load","text":"<pre><code>static bool rayx::NffTable::load (\n    const char * element,\n    NffTable * out\n) \n</code></pre> <p>loads the .NKP file of the element <code>element</code> and writes it's contents to <code>out</code> </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/NffTable.h</code></p>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/","title":"Class rayx::ObjectIndexMask","text":"<p>ClassList &gt; rayx &gt; ObjectIndexMask</p>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#public-functions","title":"Public Functions","text":"Type Name ObjectIndexMask () = default ObjectIndexMask (const ObjectIndexMask &amp;) = default ObjectIndexMask (ObjectIndexMask &amp;&amp;) = default int numElements () const int numElementsToRecord () const int numObjects () const int numObjectsToRecord () const int numSources () const int numSourcesToRecord () const ObjectIndexMask &amp; operator= (const ObjectIndexMask &amp;) = default ObjectIndexMask &amp; operator= (ObjectIndexMask &amp;&amp;) = default void setShouldRecordElement (int element_id, bool value)  void setShouldRecordObject (int object_id, bool value)  void setShouldRecordSource (int source_id, bool value)  bool shouldRecordElement (int element_id) const bool shouldRecordObject (int object_id) const bool shouldRecordSource (int source_id) const"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#public-static-functions","title":"Public Static Functions","text":"Type Name ObjectIndexMask all (const int numSources, const int numElements)  ObjectIndexMask allElements (const int numSources, const int numElements)  ObjectIndexMask allSources (const int numSources, const int numElements)  ObjectIndexMask byIndices (const int numSources, const int numElements, const std::vector&lt; int &gt; &amp; objectIndices)  ObjectIndexMask none (const int numSources, const int numElements)"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-objectindexmask-35","title":"function ObjectIndexMask [3/5]","text":"<pre><code>rayx::ObjectIndexMask::ObjectIndexMask () = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-objectindexmask-45","title":"function ObjectIndexMask [4/5]","text":"<pre><code>rayx::ObjectIndexMask::ObjectIndexMask (\n    const ObjectIndexMask &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-objectindexmask-55","title":"function ObjectIndexMask [5/5]","text":"<pre><code>rayx::ObjectIndexMask::ObjectIndexMask (\n    ObjectIndexMask &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numelements","title":"function numElements","text":"<pre><code>inline int rayx::ObjectIndexMask::numElements () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numelementstorecord","title":"function numElementsToRecord","text":"<pre><code>inline int rayx::ObjectIndexMask::numElementsToRecord () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numobjects","title":"function numObjects","text":"<pre><code>inline int rayx::ObjectIndexMask::numObjects () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numobjectstorecord","title":"function numObjectsToRecord","text":"<pre><code>inline int rayx::ObjectIndexMask::numObjectsToRecord () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numsources","title":"function numSources","text":"<pre><code>inline int rayx::ObjectIndexMask::numSources () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-numsourcestorecord","title":"function numSourcesToRecord","text":"<pre><code>inline int rayx::ObjectIndexMask::numSourcesToRecord () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-operator","title":"function operator=","text":"<pre><code>ObjectIndexMask &amp; rayx::ObjectIndexMask::operator= (\n    const ObjectIndexMask &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-operator_1","title":"function operator=","text":"<pre><code>ObjectIndexMask &amp; rayx::ObjectIndexMask::operator= (\n    ObjectIndexMask &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-setshouldrecordelement","title":"function setShouldRecordElement","text":"<pre><code>inline void rayx::ObjectIndexMask::setShouldRecordElement (\n    int element_id,\n    bool value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-setshouldrecordobject","title":"function setShouldRecordObject","text":"<pre><code>inline void rayx::ObjectIndexMask::setShouldRecordObject (\n    int object_id,\n    bool value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-setshouldrecordsource","title":"function setShouldRecordSource","text":"<pre><code>inline void rayx::ObjectIndexMask::setShouldRecordSource (\n    int source_id,\n    bool value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-shouldrecordelement","title":"function shouldRecordElement","text":"<pre><code>inline bool rayx::ObjectIndexMask::shouldRecordElement (\n    int element_id\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-shouldrecordobject","title":"function shouldRecordObject","text":"<pre><code>inline bool rayx::ObjectIndexMask::shouldRecordObject (\n    int object_id\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-shouldrecordsource","title":"function shouldRecordSource","text":"<pre><code>inline bool rayx::ObjectIndexMask::shouldRecordSource (\n    int source_id\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-all","title":"function all","text":"<pre><code>static inline ObjectIndexMask rayx::ObjectIndexMask::all (\n    const int numSources,\n    const int numElements\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-allelements","title":"function allElements","text":"<pre><code>static inline ObjectIndexMask rayx::ObjectIndexMask::allElements (\n    const int numSources,\n    const int numElements\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-allsources","title":"function allSources","text":"<pre><code>static inline ObjectIndexMask rayx::ObjectIndexMask::allSources (\n    const int numSources,\n    const int numElements\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-byindices","title":"function byIndices","text":"<pre><code>static inline ObjectIndexMask rayx::ObjectIndexMask::byIndices (\n    const int numSources,\n    const int numElements,\n    const std::vector&lt; int &gt; &amp; objectIndices\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectIndexMask/#function-none","title":"function none","text":"<pre><code>static inline ObjectIndexMask rayx::ObjectIndexMask::none (\n    const int numSources,\n    const int numElements\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/classrayx_1_1ObjectMask/","title":"Class rayx::ObjectMask","text":"<p>ClassList &gt; rayx &gt; ObjectMask</p>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#public-functions","title":"Public Functions","text":"Type Name ObjectMask ()  ObjectMask (const ObjectMask &amp;) = default ObjectMask (ObjectMask &amp;&amp;) = default ObjectMask (ObjectIndexMask objectIndexMask)  ObjectMask &amp; operator= (const ObjectMask &amp;) = default ObjectMask &amp; operator= (ObjectMask &amp;&amp;) = default ObjectIndexMask toObjectIndexMask (int numSources, int numElements) const"},{"location":"rayxCore/classrayx_1_1ObjectMask/#public-static-functions","title":"Public Static Functions","text":"Type Name ObjectMask all ()  ObjectMask allElements ()  ObjectMask allSources ()  ObjectMask byIndices (std::vector&lt; int &gt; indices)  ObjectMask none ()"},{"location":"rayxCore/classrayx_1_1ObjectMask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-objectmask-25","title":"function ObjectMask [2/5]","text":"<pre><code>inline rayx::ObjectMask::ObjectMask () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-objectmask-35","title":"function ObjectMask [3/5]","text":"<pre><code>rayx::ObjectMask::ObjectMask (\n    const ObjectMask &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-objectmask-45","title":"function ObjectMask [4/5]","text":"<pre><code>rayx::ObjectMask::ObjectMask (\n    ObjectMask &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-objectmask-55","title":"function ObjectMask [5/5]","text":"<pre><code>inline rayx::ObjectMask::ObjectMask (\n    ObjectIndexMask objectIndexMask\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-operator","title":"function operator=","text":"<pre><code>ObjectMask &amp; rayx::ObjectMask::operator= (\n    const ObjectMask &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-operator_1","title":"function operator=","text":"<pre><code>ObjectMask &amp; rayx::ObjectMask::operator= (\n    ObjectMask &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-toobjectindexmask","title":"function toObjectIndexMask","text":"<pre><code>inline ObjectIndexMask rayx::ObjectMask::toObjectIndexMask (\n    int numSources,\n    int numElements\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-all","title":"function all","text":"<pre><code>static inline ObjectMask rayx::ObjectMask::all () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-allelements","title":"function allElements","text":"<pre><code>static inline ObjectMask rayx::ObjectMask::allElements () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-allsources","title":"function allSources","text":"<pre><code>static inline ObjectMask rayx::ObjectMask::allSources () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-byindices","title":"function byIndices","text":"<pre><code>static inline ObjectMask rayx::ObjectMask::byIndices (\n    std::vector&lt; int &gt; indices\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ObjectMask/#function-none","title":"function none","text":"<pre><code>static inline ObjectMask rayx::ObjectMask::none () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectTransform/","title":"Struct rayx::ObjectTransform","text":"<p>ClassList &gt; rayx &gt; ObjectTransform</p>"},{"location":"rayxCore/structrayx_1_1ObjectTransform/#public-attributes","title":"Public Attributes","text":"Type Name glm::dmat4 m_inTrans In-transformation matrix: Converts a point from world coordinates to local object coordinates. glm::dmat4 m_outTrans Out-transformation matrix: Converts a point from local object coordinates to world coordinates."},{"location":"rayxCore/structrayx_1_1ObjectTransform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1ObjectTransform/#variable-m_intrans","title":"variable m_inTrans","text":"<p>In-transformation matrix: Converts a point from world coordinates to local object coordinates. <pre><code>glm::dmat4 rayx::ObjectTransform::m_inTrans;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1ObjectTransform/#variable-m_outtrans","title":"variable m_outTrans","text":"<p>Out-transformation matrix: Converts a point from local object coordinates to world coordinates. <pre><code>glm::dmat4 rayx::ObjectTransform::m_outTrans;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Element.h</code></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/","title":"Struct rayx::OpticalElement","text":"<p>ClassList &gt; rayx &gt; OpticalElement</p> <p>Structure to represent an element in the ray tracing simulation. </p> <ul> <li><code>#include &lt;Element.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#public-attributes","title":"Public Attributes","text":"Type Name double m_azimuthalAngle Azimuthal angle at which this element is rotated around the \"main-beam\". Behaviour m_behaviour Describes what happens to a ray once it collides with this OpticalElement . Coating m_coating Describes the coating of the surface, if any. Cutout m_cutout Limits the Surface to the dimensions of the actual OpticalElement . int m_material The material that this object is made of (see <code>enum class Material</code> from_Material.h )._ SlopeError m_slopeError Describes a random noise in the normal vector of a particular surface point. Surface m_surface Describes how the OpticalElement 's surface is curved."},{"location":"rayxCore/structrayx_1_1OpticalElement/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_azimuthalangle","title":"variable m_azimuthalAngle","text":"<p>Azimuthal angle at which this element is rotated around the \"main-beam\". <pre><code>double rayx::OpticalElement::m_azimuthalAngle;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_behaviour","title":"variable m_behaviour","text":"<p>Describes what happens to a ray once it collides with this OpticalElement . <pre><code>Behaviour rayx::OpticalElement::m_behaviour;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_coating","title":"variable m_coating","text":"<p>Describes the coating of the surface, if any. <pre><code>Coating rayx::OpticalElement::m_coating;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_cutout","title":"variable m_cutout","text":"<p>Limits the Surface to the dimensions of the actual OpticalElement . <pre><code>Cutout rayx::OpticalElement::m_cutout;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_material","title":"variable m_material","text":"<p>The material that this object is made of (see <code>enum class Material</code> from_Material.h )._ <pre><code>int rayx::OpticalElement::m_material;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_slopeerror","title":"variable m_slopeError","text":"<p>Describes a random noise in the normal vector of a particular surface point. <pre><code>SlopeError rayx::OpticalElement::m_slopeError;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1OpticalElement/#variable-m_surface","title":"variable m_surface","text":"<p>Describes how the OpticalElement 's surface is curved. <pre><code>Surface rayx::OpticalElement::m_surface;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Element.h</code></p>"},{"location":"rayxCore/structrayx_1_1OpticalElementAndTransform/","title":"Struct rayx::OpticalElementAndTransform","text":"<p>ClassList &gt; rayx &gt; OpticalElementAndTransform</p>"},{"location":"rayxCore/structrayx_1_1OpticalElementAndTransform/#public-attributes","title":"Public Attributes","text":"Type Name OpticalElement element ObjectTransform transform"},{"location":"rayxCore/structrayx_1_1OpticalElementAndTransform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1OpticalElementAndTransform/#variable-element","title":"variable element","text":"<pre><code>OpticalElement rayx::OpticalElementAndTransform::element;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1OpticalElementAndTransform/#variable-transform","title":"variable transform","text":"<pre><code>ObjectTransform rayx::OpticalElementAndTransform::transform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Element.h</code></p>"},{"location":"rayxCore/structrayx_1_1PalikEntry/","title":"Struct rayx::PalikEntry","text":"<p>ClassList &gt; rayx &gt; PalikEntry</p> <p>This struct represents one line of a .NKP file. More...</p> <ul> <li><code>#include &lt;RefractiveIndex.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1PalikEntry/#public-attributes","title":"Public Attributes","text":"Type Name double m_energy double m_k double m_n"},{"location":"rayxCore/structrayx_1_1PalikEntry/#detailed-description","title":"Detailed Description","text":"<p>Both of these structs are used to effectively calculate the Refractive Index of some material when hit by a photon with a particular m_energy. The PalikEntry represents the the complex-valued refractive index directly as n + ik. The NffEntry instead holds atomic scattering factors which can be used to derive the refractive index. </p>"},{"location":"rayxCore/structrayx_1_1PalikEntry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1PalikEntry/#variable-m_energy","title":"variable m_energy","text":"<pre><code>double rayx::PalikEntry::m_energy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1PalikEntry/#variable-m_k","title":"variable m_k","text":"<pre><code>double rayx::PalikEntry::m_k;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1PalikEntry/#variable-m_n","title":"variable m_n","text":"<pre><code>double rayx::PalikEntry::m_n;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RefractiveIndex.h</code></p>"},{"location":"rayxCore/structrayx_1_1PalikTable/","title":"Struct rayx::PalikTable","text":"<p>ClassList &gt; rayx &gt; PalikTable</p> <p>More...</p> <ul> <li><code>#include &lt;PalikTable.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1PalikTable/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; PalikEntry &gt; m_Lines std::string m_element"},{"location":"rayxCore/structrayx_1_1PalikTable/#public-static-functions","title":"Public Static Functions","text":"Type Name bool load (const char * element, PalikTable * out)"},{"location":"rayxCore/structrayx_1_1PalikTable/#detailed-description","title":"Detailed Description","text":"<p>This struct represents the contents of a .NKP file.</p> <p>Example usage:</p> <p>PalikTable cu; bool success = PalikTable::load(\"CU\", &amp;cu); // the palik table for copper! </p>"},{"location":"rayxCore/structrayx_1_1PalikTable/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1PalikTable/#variable-m_lines","title":"variable m_Lines","text":"<pre><code>std::vector&lt;PalikEntry&gt; rayx::PalikTable::m_Lines;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1PalikTable/#variable-m_element","title":"variable m_element","text":"<pre><code>std::string rayx::PalikTable::m_element;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1PalikTable/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1PalikTable/#function-load","title":"function load","text":"<pre><code>static bool rayx::PalikTable::load (\n    const char * element,\n    PalikTable * out\n) \n</code></pre> <p>loads the .NKP file of the element <code>element</code> and writes it's contents to <code>out</code> </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/PalikTable.h</code></p>"},{"location":"rayxCore/classrayx_1_1PixelSource/","title":"Class rayx::PixelSource","text":"<p>ClassList &gt; rayx &gt; PixelSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1PixelSource/#public-functions","title":"Public Functions","text":"Type Name PixelSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1PixelSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1PixelSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1PixelSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1PixelSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1PixelSource/#function-pixelsource","title":"function PixelSource","text":"<pre><code>rayx::PixelSource::PixelSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1PixelSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::PixelSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/PixelSource.h</code></p>"},{"location":"rayxCore/classrayx_1_1PointSource/","title":"Class rayx::PointSource","text":"<p>ClassList &gt; rayx &gt; PointSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1PointSource/#public-functions","title":"Public Functions","text":"Type Name PointSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1PointSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1PointSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1PointSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1PointSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1PointSource/#function-pointsource","title":"function PointSource","text":"<pre><code>rayx::PointSource::PointSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1PointSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::PointSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/PointSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1PsiAndStokes/","title":"Struct rayx::PsiAndStokes","text":"<p>ClassList &gt; rayx &gt; PsiAndStokes</p>"},{"location":"rayxCore/structrayx_1_1PsiAndStokes/#public-attributes","title":"Public Attributes","text":"Type Name double psi glm::dvec4 stokes"},{"location":"rayxCore/structrayx_1_1PsiAndStokes/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1PsiAndStokes/#variable-psi","title":"variable psi","text":"<pre><code>double rayx::PsiAndStokes::psi;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1PsiAndStokes/#variable-stokes","title":"variable stokes","text":"<pre><code>glm::dvec4 rayx::PsiAndStokes::stokes;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/DipoleSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1Rad/","title":"Struct rayx::Rad","text":"<p>ClassList &gt; rayx &gt; Rad</p>"},{"location":"rayxCore/structrayx_1_1Rad/#public-attributes","title":"Public Attributes","text":"Type Name double rad"},{"location":"rayxCore/structrayx_1_1Rad/#public-functions","title":"Public Functions","text":"Type Name Rad () = default Rad (double r)  double cos () const double sin () const double tan () const Deg toDeg () const"},{"location":"rayxCore/structrayx_1_1Rad/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rad/#variable-rad","title":"variable rad","text":"<pre><code>double rayx::Rad::rad;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rad/#function-rad-12","title":"function Rad [1/2]","text":"<pre><code>rayx::Rad::Rad () = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#function-rad-22","title":"function Rad [2/2]","text":"<pre><code>inline rayx::Rad::Rad (\n    double r\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#function-cos","title":"function cos","text":"<pre><code>double rayx::Rad::cos () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#function-sin","title":"function sin","text":"<pre><code>double rayx::Rad::sin () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#function-tan","title":"function tan","text":"<pre><code>double rayx::Rad::tan () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rad/#function-todeg","title":"function toDeg","text":"<pre><code>Deg rayx::Rad::toDeg () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Angle.h</code></p>"},{"location":"rayxCore/structrayx_1_1Rand/","title":"Struct rayx::Rand","text":"<p>ClassList &gt; rayx &gt; Rand</p>"},{"location":"rayxCore/structrayx_1_1Rand/#public-attributes","title":"Public Attributes","text":"Type Name RandCounter counter"},{"location":"rayxCore/structrayx_1_1Rand/#public-functions","title":"Public Functions","text":"Type Name Rand () noexcept Rand (const Rand &amp;) = delete Rand (Rand &amp;&amp;) = default RAYX_FN_ACC Rand (const RandCounter ctr) noexcept RAYX_FN_ACC Rand (const int rayPathIndex, const int numRaysTotal, const double randomSeed) noexcept Rand &amp; operator= (const Rand &amp;) = delete Rand &amp; operator= (Rand &amp;&amp;) = default RAYX_FN_ACC double randomDouble ()  RAYX_FN_ACC double randomDoubleInRange (const double min, const double max)  RAYX_FN_ACC double randomDoubleNormalDistributed (double mu, double sigma)  RAYX_FN_ACC uint64_t randomInt ()  RAYX_FN_ACC int randomIntInRange (const int min_inclusive, const int max_exclusive)"},{"location":"rayxCore/structrayx_1_1Rand/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rand/#variable-counter","title":"variable counter","text":"<pre><code>RandCounter rayx::Rand::counter;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rand/#function-rand-15","title":"function Rand [1/5]","text":"<pre><code>inline rayx::Rand::Rand () noexcept\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-rand-25","title":"function Rand [2/5]","text":"<pre><code>rayx::Rand::Rand (\n    const Rand &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-rand-35","title":"function Rand [3/5]","text":"<pre><code>rayx::Rand::Rand (\n    Rand &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-rand-45","title":"function Rand [4/5]","text":"<pre><code>inline explicit RAYX_FN_ACC rayx::Rand::Rand (\n    const RandCounter ctr\n) noexcept\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-rand-55","title":"function Rand [5/5]","text":"<pre><code>inline explicit RAYX_FN_ACC rayx::Rand::Rand (\n    const int rayPathIndex,\n    const int numRaysTotal,\n    const double randomSeed\n) noexcept\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-operator","title":"function operator=","text":"<pre><code>Rand &amp; rayx::Rand::operator= (\n    const Rand &amp;\n) = delete\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-operator_1","title":"function operator=","text":"<pre><code>Rand &amp; rayx::Rand::operator= (\n    Rand &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-randomdouble","title":"function randomDouble","text":"<pre><code>inline RAYX_FN_ACC double rayx::Rand::randomDouble () \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-randomdoubleinrange","title":"function randomDoubleInRange","text":"<pre><code>inline RAYX_FN_ACC double rayx::Rand::randomDoubleInRange (\n    const double min,\n    const double max\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-randomdoublenormaldistributed","title":"function randomDoubleNormalDistributed","text":"<pre><code>inline RAYX_FN_ACC double rayx::Rand::randomDoubleNormalDistributed (\n    double mu,\n    double sigma\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-randomint","title":"function randomInt","text":"<pre><code>inline RAYX_FN_ACC uint64_t rayx::Rand::randomInt () \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rand/#function-randomintinrange","title":"function randomIntInRange","text":"<pre><code>inline RAYX_FN_ACC int rayx::Rand::randomIntInRange (\n    const int min_inclusive,\n    const int max_exclusive\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Rand.h</code></p>"},{"location":"rayxCore/structrayx_1_1RayListSource/","title":"Struct rayx::RayListSource","text":"<p>ClassList &gt; rayx &gt; RayListSource</p>"},{"location":"rayxCore/structrayx_1_1RayListSource/#public-attributes","title":"Public Attributes","text":"Type Name RaysPtr rays"},{"location":"rayxCore/structrayx_1_1RayListSource/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1RayListSource/#variable-rays","title":"variable rays","text":"<pre><code>RaysPtr rayx::RayListSource::rays;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/RayListSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1Rays/","title":"Struct rayx::Rays","text":"<p>ClassList &gt; rayx &gt; Rays</p> <p>A structure representing a collection of rays and their attributes. Each attribute is stored as a vector, allowing for efficient storage and manipulation of multiple rays. The Rays structure supports move semantics for efficient transfers, but disables copy semantics to prevent accidental costly copies. Use the<code>copy()</code> method to create an explicit copy when needed.More...</p> <ul> <li><code>#include &lt;Rays.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1Rays/#public-functions","title":"Public Functions","text":"Type Name Rays () = default Rays (Rays &amp;&amp;) = default Rays &amp; append (const Rays &amp; other) Append another Rays instance to this one. RayAttrMask attrMask () constGet a mask indicating which ray attributes are recorded in this Rays instance. bool contains (const RayAttrMask attr) constCheck if a specific attribute is recorded in this Rays instance. Rays copy () constCreate a copy of the Rays instance. This function is an explicit copy of theRays instance to avoid accidental costly copies. If you want to return aRays instance from a function, you should make use of RVO/NRVO optimizations, instead of using this function. int count (Pred pred) const glm::dvec3 direction (const int i) const void direction (const int i, const glm::dvec3 direction)  ElectricField electric_field (const int i) const void electric_field (const int i, const ElectricField electric_field)  bool empty () constCheck if the ray list is empty. Rays filter (Pred pred) const Rays &amp; filterByAttrMask (const RayAttrMask mask) Filter the rays to only include those with attributes specified in the given mask. This operation modifies the current Rays instance in place. Rays filterByLastEventInPath () constFilter the rays to only include the final event of each unique path. The final event is determined by the maximum path_event_id for each path_id. Rays filterByObjectId (const int object_id) constFilter the rays to only include those that interacted with a specific object. bool isValid () constCheck if the sizes of all recorded attribute vectors are valid (i.e., all the same length). int numPaths () constGet the number of unique paths in the ray list. Rays &amp; operator= (Rays &amp;&amp;) = default RAYX_X_MACRO_RAY_ATTR glm::dvec3 position (const int i) const void position (const int i, const glm::dvec3 position)  int size () constGet the number of events in the ray list. Rays sort (Compare comp) const Rays sortByObjectId () constSort rays by object_id, so that rays interacting with the same object are grouped together. Rays sortByPathIdAndPathEventId () constSort rays by path_id and then by path_event_id, so that rays belonging to the same path are grouped together, and within each path, rays are ordered by their event sequence."},{"location":"rayxCore/structrayx_1_1Rays/#public-static-functions","title":"Public Static Functions","text":"Type Name Rays concat (const std::vector&lt; Rays &gt; &amp; rays_list) Concatenate multiple Rays instances into a singleRays instance. This is more efficient than using repeatedappend() calls."},{"location":"rayxCore/structrayx_1_1Rays/#protected-functions","title":"Protected Functions","text":"Type Name Rays (const Rays &amp;) = defaultPrivate copy constructor to prevent accidental copies. Rays &amp; operator= (const Rays &amp;) = defaultPrivate assignment operator to prevent accidental copies."},{"location":"rayxCore/structrayx_1_1Rays/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>Ensure that all attribute vectors are of the same length to maintain data integrity. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rays/#function-rays-23","title":"function Rays [2/3]","text":"<pre><code>rayx::Rays::Rays () = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-rays-33","title":"function Rays [3/3]","text":"<pre><code>rayx::Rays::Rays (\n    Rays &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-append","title":"function append","text":"<p>Append another Rays instance to this one. <pre><code>Rays &amp; rayx::Rays::append (\n    const Rays &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> The Rays instance to append. </li> </ul> <p>Returns:</p> <p>A reference to this Rays instance after appending. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-attrmask","title":"function attrMask","text":"<p>Get a mask indicating which ray attributes are recorded in this Rays instance. <pre><code>RayAttrMask rayx::Rays::attrMask () const\n</code></pre></p> <p>Returns:</p> <p>A RayAttrMask indicating the recorded attributes. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-contains","title":"function contains","text":"<p>Check if a specific attribute is recorded in this Rays instance. <pre><code>bool rayx::Rays::contains (\n    const RayAttrMask attr\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>attr</code> The RayAttrMask attribute to check. </li> </ul> <p>Returns:</p> <p>True if the attribute is recorded, false otherwise. </p> <p>Note:</p> <p>When repeatedly checking on the same Rays instance, the free function contains(haystack, needle) should be preferred over this method. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-copy","title":"function copy","text":"<p>Create a copy of the Rays instance. This function is an explicit copy of theRays instance to avoid accidental costly copies. If you want to return aRays instance from a function, you should make use of RVO/NRVO optimizations, instead of using this function. <pre><code>Rays rayx::Rays::copy () const\n</code></pre></p> <p>Returns:</p> <p>A new Rays instance that is a copy of the current instance. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-count","title":"function count","text":"<pre><code>template&lt;typename Pred&gt;\nint rayx::Rays::count (\n    Pred pred\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-direction-12","title":"function direction [1/2]","text":"<pre><code>inline glm::dvec3 rayx::Rays::direction (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-direction-22","title":"function direction [2/2]","text":"<pre><code>inline void rayx::Rays::direction (\n    const int i,\n    const glm::dvec3 direction\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-electric_field-12","title":"function electric_field [1/2]","text":"<pre><code>inline ElectricField rayx::Rays::electric_field (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-electric_field-22","title":"function electric_field [2/2]","text":"<pre><code>inline void rayx::Rays::electric_field (\n    const int i,\n    const ElectricField electric_field\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-empty","title":"function empty","text":"<p>Check if the ray list is empty. <pre><code>bool rayx::Rays::empty () const\n</code></pre></p> <p>Returns:</p> <p>True if the ray list is empty, false otherwise. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-filter","title":"function filter","text":"<pre><code>template&lt;typename Pred&gt;\nRays rayx::Rays::filter (\n    Pred pred\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-filterbyattrmask","title":"function filterByAttrMask","text":"<p>Filter the rays to only include those with attributes specified in the given mask. This operation modifies the current Rays instance in place. <pre><code>Rays &amp; rayx::Rays::filterByAttrMask (\n    const RayAttrMask mask\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> A RayAttrMask specifying which attributes to retain. </li> </ul>"},{"location":"rayxCore/structrayx_1_1Rays/#function-filterbylasteventinpath","title":"function filterByLastEventInPath","text":"<p>Filter the rays to only include the final event of each unique path. The final event is determined by the maximum path_event_id for each path_id. <pre><code>Rays rayx::Rays::filterByLastEventInPath () const\n</code></pre></p> <p>Returns:</p> <p>A new Rays instance containing only the final event of each path. </p> <p>Note:</p> <p>Requires that path_id and path_event_id are recorded. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-filterbyobjectid","title":"function filterByObjectId","text":"<p>Filter the rays to only include those that interacted with a specific object. <pre><code>Rays rayx::Rays::filterByObjectId (\n    const int object_id\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>object_id</code> The ID of the object to filter by. </li> </ul> <p>Returns:</p> <p>A new Rays instance containing only rays that interacted with the specified object. </p> <p>Note:</p> <p>Requires that object_id is recorded. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-isvalid","title":"function isValid","text":"<p>Check if the sizes of all recorded attribute vectors are valid (i.e., all the same length). <pre><code>bool rayx::Rays::isValid () const\n</code></pre></p> <p>Returns:</p> <p>True if all recorded attribute vectors have the same length, false otherwise. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-numpaths","title":"function numPaths","text":"<p>Get the number of unique paths in the ray list. <pre><code>int rayx::Rays::numPaths () const\n</code></pre></p> <p>Returns:</p> <p>The number of unique path IDs in the ray list. </p> <p>Note:</p> <p>Requires that path_id is recorded. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-operator","title":"function operator=","text":"<pre><code>Rays &amp; rayx::Rays::operator= (\n    Rays &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-position-12","title":"function position [1/2]","text":"<pre><code>inline RAYX_X_MACRO_RAY_ATTR glm::dvec3 rayx::Rays::position (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-position-22","title":"function position [2/2]","text":"<pre><code>inline void rayx::Rays::position (\n    const int i,\n    const glm::dvec3 position\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-size","title":"function size","text":"<p>Get the number of events in the ray list. <pre><code>int rayx::Rays::size () const\n</code></pre></p> <p>Returns:</p> <p>The number of events in the ray list. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-sort","title":"function sort","text":"<pre><code>template&lt;typename Compare&gt;\nRays rayx::Rays::sort (\n    Compare comp\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Rays/#function-sortbyobjectid","title":"function sortByObjectId","text":"<p>Sort rays by object_id, so that rays interacting with the same object are grouped together. <pre><code>Rays rayx::Rays::sortByObjectId () const\n</code></pre></p> <p>Returns:</p> <p>A new Rays instance with rays sorted by object_id. </p> <p>Note:</p> <p>Requires that object_id is recorded. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-sortbypathidandpatheventid","title":"function sortByPathIdAndPathEventId","text":"<p>Sort rays by path_id and then by path_event_id, so that rays belonging to the same path are grouped together, and within each path, rays are ordered by their event sequence. <pre><code>Rays rayx::Rays::sortByPathIdAndPathEventId () const\n</code></pre></p> <p>Returns:</p> <p>A new Rays instance with rays sorted by path_id and path_event_id. </p> <p>Note:</p> <p>Requires that path_id and path_event_id are recorded. </p> <p>Note:</p> <p>Every event is uniquely identified by the combination of path_id and path_event_id. Thus, sorting by these two attributes ensures that rays are in a well-defined order. This enables equality comparisons between different Rays instances. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rays/#function-concat","title":"function concat","text":"<p>Concatenate multiple Rays instances into a singleRays instance. This is more efficient than using repeatedappend() calls. <pre><code>static Rays rayx::Rays::concat (\n    const std::vector&lt; Rays &gt; &amp; rays_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rays_list</code> A vector of Rays instances to concatenate. </li> </ul> <p>Returns:</p> <p>A new Rays instance containing all rays from the input instances. </p> <p>Note:</p> <p>Requires that all Rays instances in rays_list have the same attributes recorded. </p>"},{"location":"rayxCore/structrayx_1_1Rays/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Rays/#function-rays-13","title":"function Rays [1/3]","text":"<p>Private copy constructor to prevent accidental copies. <pre><code>rayx::Rays::Rays (\n    const Rays &amp;\n) = default\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Rays/#function-operator_1","title":"function operator=","text":"<p>Private assignment operator to prevent accidental copies. <pre><code>Rays &amp; rayx::Rays::operator= (\n    const Rays &amp;\n) = default\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rays.h</code></p>"},{"location":"rayxCore/structrayx_1_1RaysBuf/","title":"Struct rayx::RaysBuf","text":"<p>template &lt;typename Acc&gt;</p> <p>ClassList &gt; rayx &gt; RaysBuf</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/structrayx_1_1RaysPtr/","title":"Struct rayx::RaysPtr","text":"<p>ClassList &gt; rayx &gt; RaysPtr</p>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#public-functions","title":"Public Functions","text":"Type Name RAYX_FN_ACC glm::dvec3 direction (const int i) const RAYX_FN_ACC void direction (const int i, const glm::dvec3 direction)  RAYX_FN_ACC ElectricField electric_field (const int i) const RAYX_FN_ACC void electric_field (const int i, const ElectricField electric_field)  RAYX_X_MACRO_RAY_ATTR RAYX_FN_ACC glm::dvec3 position (const int i) const RAYX_FN_ACC void position (const int i, const glm::dvec3 position)"},{"location":"rayxCore/structrayx_1_1RaysPtr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-direction-12","title":"function direction [1/2]","text":"<pre><code>inline RAYX_FN_ACC glm::dvec3 rayx::RaysPtr::direction (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-direction-22","title":"function direction [2/2]","text":"<pre><code>inline RAYX_FN_ACC void rayx::RaysPtr::direction (\n    const int i,\n    const glm::dvec3 direction\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-electric_field-12","title":"function electric_field [1/2]","text":"<pre><code>inline RAYX_FN_ACC ElectricField rayx::RaysPtr::electric_field (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-electric_field-22","title":"function electric_field [2/2]","text":"<pre><code>inline RAYX_FN_ACC void rayx::RaysPtr::electric_field (\n    const int i,\n    const ElectricField electric_field\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-position-12","title":"function position [1/2]","text":"<pre><code>inline RAYX_X_MACRO_RAY_ATTR RAYX_FN_ACC glm::dvec3 rayx::RaysPtr::position (\n    const int i\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1RaysPtr/#function-position-22","title":"function position [2/2]","text":"<pre><code>inline RAYX_FN_ACC void rayx::RaysPtr::position (\n    const int i,\n    const glm::dvec3 position\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RaysPtr.h</code></p>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/","title":"Class rayx::ResourceHandler","text":"<p>ClassList &gt; rayx &gt; ResourceHandler</p>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#public-functions","title":"Public Functions","text":"Type Name void addLookUpPath (const std::filesystem::path &amp; path)  std::filesystem::path getExecutablePath ()  std::filesystem::path getFontPath (const std::filesystem::path &amp; relativePath)  std::filesystem::path getResourcePath (const std::filesystem::path &amp; relativePath)"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#public-static-functions","title":"Public Static Functions","text":"Type Name ResourceHandler &amp; getInstance ()"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ResourceHandler/#function-addlookuppath","title":"function addLookUpPath","text":"<pre><code>void rayx::ResourceHandler::addLookUpPath (\n    const std::filesystem::path &amp; path\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#function-getexecutablepath","title":"function getExecutablePath","text":"<pre><code>std::filesystem::path rayx::ResourceHandler::getExecutablePath () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#function-getfontpath","title":"function getFontPath","text":"<pre><code>std::filesystem::path rayx::ResourceHandler::getFontPath (\n    const std::filesystem::path &amp; relativePath\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#function-getresourcepath","title":"function getResourcePath","text":"<pre><code>std::filesystem::path rayx::ResourceHandler::getResourcePath (\n    const std::filesystem::path &amp; relativePath\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1ResourceHandler/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1ResourceHandler/#function-getinstance","title":"function getInstance","text":"<pre><code>static inline ResourceHandler &amp; rayx::ResourceHandler::getInstance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/Locate.h</code></p>"},{"location":"rayxCore/structrayx_1_1Resources/","title":"Struct rayx::Resources","text":"<p>template &lt;typename Acc&gt;</p> <p>ClassList &gt; rayx &gt; Resources</p> <p>More...</p> <ul> <li><code>#include &lt;MegaKernelTracer.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1Resources/#classes","title":"Classes","text":"Type Name struct BeamlineConfig holds configuration state of allocated resources. required to trace correctly"},{"location":"rayxCore/structrayx_1_1Resources/#public-types","title":"Public Types","text":"Type Name typedef alpaka::DimInt&lt; 1 &gt; Dim typedef int Idx"},{"location":"rayxCore/structrayx_1_1Resources/#public-attributes","title":"Public Attributes","text":"Type Name RaysBuf&lt; Acc &gt; d_compactEventsBatch output events, compacted for faster transfer OptBuf&lt; Acc, OpticalElement &gt; d_elements beamline elements OptBuf&lt; Acc, bool &gt; d_eventStoreFlags flag for each possible ouput event, wether it was stored or not. used for compaction OptBuf&lt; Acc, int &gt; d_eventStoreFlagsPrefixSum RaysBuf&lt; Acc &gt; d_eventsBatch output events from tracer kernel OptBuf&lt; Acc, int &gt; d_materialIndices material data OptBuf&lt; Acc, double &gt; d_materialTable OptBuf&lt; Acc, bool &gt; d_objectRecordMask mask for which elements to record events OptBuf&lt; Acc, ObjectTransform &gt; d_objectTransforms beamline object transforms"},{"location":"rayxCore/structrayx_1_1Resources/#public-functions","title":"Public Functions","text":"Type Name BeamlineConfig update (Queue q, const Group &amp; group, int maxEvents, int numRaysBatchAtMost, const ObjectIndexMask &amp; objectRecordMask, const RayAttrMask attrRecordMask) update resources"},{"location":"rayxCore/structrayx_1_1Resources/#detailed-description","title":"Detailed Description","text":"<p>keeps track of all resources used by the tracer. manages allocation and update of buffers note: members starting with h_ reside on host side, while d_ reside on device side </p>"},{"location":"rayxCore/structrayx_1_1Resources/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/structrayx_1_1Resources/#typedef-dim","title":"typedef Dim","text":"<pre><code>using rayx::Resources&lt; Acc &gt;::Dim =  alpaka::DimInt&lt;1&gt;;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Resources/#typedef-idx","title":"typedef Idx","text":"<pre><code>using rayx::Resources&lt; Acc &gt;::Idx =  int;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Resources/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_compacteventsbatch","title":"variable d_compactEventsBatch","text":"<p>output events, compacted for faster transfer <pre><code>RaysBuf&lt;Acc&gt; rayx::Resources&lt; Acc &gt;::d_compactEventsBatch;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_elements","title":"variable d_elements","text":"<p>beamline elements <pre><code>OptBuf&lt;Acc, OpticalElement&gt; rayx::Resources&lt; Acc &gt;::d_elements;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_eventstoreflags","title":"variable d_eventStoreFlags","text":"<p>flag for each possible ouput event, wether it was stored or not. used for compaction <pre><code>OptBuf&lt;Acc, bool&gt; rayx::Resources&lt; Acc &gt;::d_eventStoreFlags;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_eventstoreflagsprefixsum","title":"variable d_eventStoreFlagsPrefixSum","text":"<pre><code>OptBuf&lt;Acc, int&gt; rayx::Resources&lt; Acc &gt;::d_eventStoreFlagsPrefixSum;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_eventsbatch","title":"variable d_eventsBatch","text":"<p>output events from tracer kernel <pre><code>RaysBuf&lt;Acc&gt; rayx::Resources&lt; Acc &gt;::d_eventsBatch;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_materialindices","title":"variable d_materialIndices","text":"<p>material data <pre><code>OptBuf&lt;Acc, int&gt; rayx::Resources&lt; Acc &gt;::d_materialIndices;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_materialtable","title":"variable d_materialTable","text":"<pre><code>OptBuf&lt;Acc, double&gt; rayx::Resources&lt; Acc &gt;::d_materialTable;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_objectrecordmask","title":"variable d_objectRecordMask","text":"<p>mask for which elements to record events <pre><code>OptBuf&lt;Acc, bool&gt; rayx::Resources&lt; Acc &gt;::d_objectRecordMask;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#variable-d_objecttransforms","title":"variable d_objectTransforms","text":"<p>beamline object transforms <pre><code>OptBuf&lt;Acc, ObjectTransform&gt; rayx::Resources&lt; Acc &gt;::d_objectTransforms;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1Resources/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Resources/#function-update","title":"function update","text":"<p>update resources <pre><code>template&lt;typename Queue&gt;\ninline BeamlineConfig rayx::Resources::update (\n    Queue q,\n    const Group &amp; group,\n    int maxEvents,\n    int numRaysBatchAtMost,\n    const ObjectIndexMask &amp; objectRecordMask,\n    const RayAttrMask attrRecordMask\n) \n</code></pre></p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/MegaKernelTracer.h</code></p>"},{"location":"rayxCore/structrayx_1_1Resources_1_1BeamlineConfig/","title":"Struct rayx::Resources::BeamlineConfig","text":"<p>ClassList &gt; rayx &gt; Resources &gt; BeamlineConfig</p> <p>holds configuration state of allocated resources. required to trace correctly </p> <ul> <li><code>#include &lt;MegaKernelTracer.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1Resources_1_1BeamlineConfig/#public-attributes","title":"Public Attributes","text":"Type Name int numElements int numSources"},{"location":"rayxCore/structrayx_1_1Resources_1_1BeamlineConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1Resources_1_1BeamlineConfig/#variable-numelements","title":"variable numElements","text":"<pre><code>int rayx::Resources&lt; Acc &gt;::BeamlineConfig::numElements;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1Resources_1_1BeamlineConfig/#variable-numsources","title":"variable numSources","text":"<pre><code>int rayx::Resources&lt; Acc &gt;::BeamlineConfig::numSources;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/MegaKernelTracer.h</code></p>"},{"location":"rayxCore/structrayx_1_1RotationBase/","title":"Struct rayx::RotationBase","text":"<p>ClassList &gt; rayx &gt; RotationBase</p>"},{"location":"rayxCore/structrayx_1_1RotationBase/#public-attributes","title":"Public Attributes","text":"Type Name glm::dvec3 forward glm::dvec3 right glm::dvec3 up"},{"location":"rayxCore/structrayx_1_1RotationBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1RotationBase/#variable-forward","title":"variable forward","text":"<pre><code>glm::dvec3 rayx::RotationBase::forward;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1RotationBase/#variable-right","title":"variable right","text":"<pre><code>glm::dvec3 rayx::RotationBase::right;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1RotationBase/#variable-up","title":"variable up","text":"<pre><code>glm::dvec3 rayx::RotationBase::up;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/ElectricField.h</code></p>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/","title":"Struct rayx::SeparateEnergies","text":"<p>ClassList &gt; rayx &gt; SeparateEnergies</p> <p>If there is only one spike (i.e. m_numberOfEnergies = 1), then this spike is at <code>m_centerEnergy</code> .More...</p> <ul> <li><code>#include &lt;EnergyDistribution.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#public-attributes","title":"Public Attributes","text":"Type Name double m_centerEnergy double m_energySpread int m_numberOfEnergies"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#public-functions","title":"Public Functions","text":"Type Name SeparateEnergies (double centerEnergy, double energySpread, int numberOfEnergies)"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#detailed-description","title":"Detailed Description","text":"<p>Describes a uniform distribution of <code>m_numberOfEnergies</code> many discrete energies. These discrete energies lie equidistant within the interval [m_centerEnergy - m_energySpread/2, m_centerEnergy + m_energySpread/2]. So you can visualize this distribution, by <code>m_numberOfEnergies</code> many spikes in an otherwise-empty diagram. All spikes have the same height (i.e. they have the same probability). A pair of consecutive spikes always has the same distance. The left-most spike is at energy m_centerEnergy - m_energySpread/2, while the right-most spike is at m_centerEnergy + m_energySpread/2. </p>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#variable-m_centerenergy","title":"variable m_centerEnergy","text":"<pre><code>double rayx::SeparateEnergies::m_centerEnergy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#variable-m_energyspread","title":"variable m_energySpread","text":"<pre><code>double rayx::SeparateEnergies::m_energySpread;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#variable-m_numberofenergies","title":"variable m_numberOfEnergies","text":"<pre><code>int rayx::SeparateEnergies::m_numberOfEnergies;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1SeparateEnergies/#function-separateenergies","title":"function SeparateEnergies","text":"<pre><code>inline rayx::SeparateEnergies::SeparateEnergies (\n    double centerEnergy,\n    double energySpread,\n    int numberOfEnergies\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/EnergyDistribution.h</code></p>"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/","title":"Class rayx::SimpleUndulatorSource","text":"<p>ClassList &gt; rayx &gt; SimpleUndulatorSource</p> <p>Inherits the following classes: rayx::LightSourceBase</p>"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#public-functions","title":"Public Functions","text":"Type Name SimpleUndulatorSource (const DesignSource &amp;)  RAYX_FN_ACC detail::Ray genRay (const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant &amp;__restrict energyDistribution, Rand &amp;__restrict rand) const RAYX_FN_ACC double getCoord (const double extent, Rand &amp;__restrict rand) const"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#protected-attributes-inherited-from-rayxlightsourcebase","title":"Protected Attributes inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name int32_t m_numberOfRays"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#protected-functions-inherited-from-rayxlightsourcebase","title":"Protected Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name LightSourceBase (const DesignSource &amp;)"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#protected-static-functions-inherited-from-rayxlightsourcebase","title":"Protected Static Functions inherited from rayx::LightSourceBase","text":"<p>See rayx::LightSourceBase</p> Type Name RAYX_FN_ACC glm::dvec3 getDirectionFromAngles (double phi, double psi)"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#function-simpleundulatorsource","title":"function SimpleUndulatorSource","text":"<pre><code>rayx::SimpleUndulatorSource::SimpleUndulatorSource (\n    const DesignSource &amp;\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#function-genray","title":"function genRay","text":"<pre><code>RAYX_FN_ACC detail::Ray rayx::SimpleUndulatorSource::genRay (\n    const int rayPathIndex,\n    const int sourceId,\n    const EnergyDistributionDataVariant &amp;__restrict energyDistribution,\n    Rand &amp;__restrict rand\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1SimpleUndulatorSource/#function-getcoord","title":"function getCoord","text":"<pre><code>RAYX_FN_ACC double rayx::SimpleUndulatorSource::getCoord (\n    const double extent,\n    Rand &amp;__restrict rand\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/SimpleUndulatorSource.h</code></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/","title":"Struct rayx::SlopeError","text":"<p>ClassList &gt; rayx &gt; SlopeError</p> <p>Structure to represent slope error parameters. </p> <ul> <li><code>#include &lt;SlopeError.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1SlopeError/#public-attributes","title":"Public Attributes","text":"Type Name double m_cylindricalBowingAmp Amplitude of cylindrical bowing (unused). double m_cylindricalBowingRadius Radius of cylindrical bowing (unused). double m_mer Slope error in the meridional direction, aka <code>slopeErrorZ</code> . double m_sag Slope error in the sagittal direction, aka <code>slopeErrorX</code> . double m_thermalDistortionAmp Amplitude of thermal distortion (unused). double m_thermalDistortionSigmaX Sigma of thermal distortion in X direction (unused). double m_thermalDistortionSigmaZ Sigma of thermal distortion in Z direction (unused)."},{"location":"rayxCore/structrayx_1_1SlopeError/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_cylindricalbowingamp","title":"variable m_cylindricalBowingAmp","text":"<p>Amplitude of cylindrical bowing (unused). <pre><code>double rayx::SlopeError::m_cylindricalBowingAmp;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_cylindricalbowingradius","title":"variable m_cylindricalBowingRadius","text":"<p>Radius of cylindrical bowing (unused). <pre><code>double rayx::SlopeError::m_cylindricalBowingRadius;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_mer","title":"variable m_mer","text":"<p>Slope error in the meridional direction, aka <code>slopeErrorZ</code> . <pre><code>double rayx::SlopeError::m_mer;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_sag","title":"variable m_sag","text":"<p>Slope error in the sagittal direction, aka <code>slopeErrorX</code> . <pre><code>double rayx::SlopeError::m_sag;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_thermaldistortionamp","title":"variable m_thermalDistortionAmp","text":"<p>Amplitude of thermal distortion (unused). <pre><code>double rayx::SlopeError::m_thermalDistortionAmp;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_thermaldistortionsigmax","title":"variable m_thermalDistortionSigmaX","text":"<p>Sigma of thermal distortion in X direction (unused). <pre><code>double rayx::SlopeError::m_thermalDistortionSigmaX;\n</code></pre></p>"},{"location":"rayxCore/structrayx_1_1SlopeError/#variable-m_thermaldistortionsigmaz","title":"variable m_thermalDistortionSigmaZ","text":"<p>Sigma of thermal distortion in Z direction (unused). <pre><code>double rayx::SlopeError::m_thermalDistortionSigmaZ;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/SlopeError.h</code></p>"},{"location":"rayxCore/structrayx_1_1SoftEdge/","title":"Struct rayx::SoftEdge","text":"<p>ClassList &gt; rayx &gt; SoftEdge</p> <p>More...</p> <ul> <li><code>#include &lt;EnergyDistribution.h&gt;</code></li> </ul>"},{"location":"rayxCore/structrayx_1_1SoftEdge/#public-attributes","title":"Public Attributes","text":"Type Name double m_centerEnergy double m_sigma"},{"location":"rayxCore/structrayx_1_1SoftEdge/#public-functions","title":"Public Functions","text":"Type Name SoftEdge (double centerEnergy, double sigma)"},{"location":"rayxCore/structrayx_1_1SoftEdge/#detailed-description","title":"Detailed Description","text":"<p>Describes a normal distribution with mean <code>m_centerEnergy</code> and standard deviation <code>m_sigma</code>. https://en.wikipedia.org/wiki/Normal_distribution </p>"},{"location":"rayxCore/structrayx_1_1SoftEdge/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1SoftEdge/#variable-m_centerenergy","title":"variable m_centerEnergy","text":"<pre><code>double rayx::SoftEdge::m_centerEnergy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1SoftEdge/#variable-m_sigma","title":"variable m_sigma","text":"<pre><code>double rayx::SoftEdge::m_sigma;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1SoftEdge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1SoftEdge/#function-softedge","title":"function SoftEdge","text":"<pre><code>inline rayx::SoftEdge::SoftEdge (\n    double centerEnergy,\n    double sigma\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/EnergyDistribution.h</code></p>"},{"location":"rayxCore/classrayx_1_1Tracer/","title":"Class rayx::Tracer","text":"<p>ClassList &gt; rayx &gt; Tracer</p>"},{"location":"rayxCore/classrayx_1_1Tracer/#public-functions","title":"Public Functions","text":"Type Name Tracer (const DeviceConfig &amp; deviceConfig=DeviceConfig().enableBestDevice()) Construct a new Tracer object. Rays trace (const Group &amp; group, const Sequential sequential=Sequential::No, const ObjectMask &amp; objectRecordMask=ObjectMask::all(), const RayAttrMask attrRecordMask=RayAttrMask::All, std::optional&lt; int &gt; maxEvents=std::nullopt, std::optional&lt; int &gt; maxBatchSize=std::nullopt) Trace rays through the given group."},{"location":"rayxCore/classrayx_1_1Tracer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1Tracer/#function-tracer","title":"function Tracer","text":"<p>Construct a new Tracer object. <pre><code>rayx::Tracer::Tracer (\n    const DeviceConfig &amp; deviceConfig=DeviceConfig ().enableBestDevice()\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>deviceConfig</code> Configuration for the device to be used for tracing </li> </ul>"},{"location":"rayxCore/classrayx_1_1Tracer/#function-trace","title":"function trace","text":"<p>Trace rays through the given group. <pre><code>Rays rayx::Tracer::trace (\n    const Group &amp; group,\n    const Sequential sequential=Sequential::No,\n    const ObjectMask &amp; objectRecordMask=ObjectMask::all(),\n    const RayAttrMask attrRecordMask=RayAttrMask::All,\n    std::optional&lt; int &gt; maxEvents=std::nullopt,\n    std::optional&lt; int &gt; maxBatchSize=std::nullopt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>group</code> The group to trace rays through </li> <li><code>sequential</code> Whether to trace rays sequentially or non-sequentially </li> <li><code>objectRecordMask</code> Object record mask specifying which sources and elements to record </li> <li><code>attrRecordMask</code> Attributes to record for each ray </li> <li><code>maxEvents</code> Optional maximum number of events to trace per ray (only used in non-sequential tracing) </li> <li><code>maxBatchSize</code> Optional maximum batch size for tracing </li> </ul> <p>Returns:</p> <p>A <code>Rays</code> struct containing the traced ray attributes, specified by <code>attrRecordMask</code> and filtered by <code>objectRecordMask</code> </p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Tracer.h</code></p>"},{"location":"rayxCore/classrayx_1_1Undefined/","title":"Class rayx::Undefined","text":"<p>ClassList &gt; rayx &gt; Undefined</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/Value.h</code></p>"},{"location":"rayxCore/classrayx_1_1Variant/","title":"Class rayx::Variant","text":"<p>template &lt;typename Base, typename... Ts&gt;</p> <p>ClassList &gt; rayx &gt; Variant</p> <p>Inherits the following classes: Base</p>"},{"location":"rayxCore/classrayx_1_1Variant/#public-functions","title":"Public Functions","text":"Type Name Variant () = default Variant (const Variant &amp;) = default Variant (Variant &amp;&amp;) = default Variant (const T &amp; value)  Variant (T &amp;&amp; value)  RAYX_FN_ACC T &amp; get ()  RAYX_FN_ACC const T &amp; get () const RAYX_FN_ACC bool is () const Variant &amp; operator= (const Variant &amp;) = default Variant &amp; operator= (Variant &amp;&amp;) = default Variant &amp; operator= (const T &amp; other)  Variant &amp; operator= (T &amp;&amp; value)  RAYX_FN_ACC decltype(auto) visit (const Visitor &amp; visitor) const RAYX_FN_ACC decltype(auto) visit (Visitor &amp;&amp; visitor) const"},{"location":"rayxCore/classrayx_1_1Variant/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/classrayx_1_1Variant/#function-variant-15","title":"function Variant [1/5]","text":"<pre><code>rayx::Variant::Variant () = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-variant-25","title":"function Variant [2/5]","text":"<pre><code>rayx::Variant::Variant (\n    const Variant &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-variant-35","title":"function Variant [3/5]","text":"<pre><code>rayx::Variant::Variant (\n    Variant &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-variant-45","title":"function Variant [4/5]","text":"<pre><code>template&lt;typename T&gt;\ninline rayx::Variant::Variant (\n    const T &amp; value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-variant-55","title":"function Variant [5/5]","text":"<pre><code>template&lt;typename T&gt;\ninline rayx::Variant::Variant (\n    T &amp;&amp; value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-get-12","title":"function get [1/2]","text":"<pre><code>template&lt;typename T&gt;\ninline RAYX_FN_ACC T &amp; rayx::Variant::get () \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-get-22","title":"function get [2/2]","text":"<pre><code>template&lt;typename T&gt;\ninline RAYX_FN_ACC const T &amp; rayx::Variant::get () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-is","title":"function is","text":"<pre><code>template&lt;typename T&gt;\ninline RAYX_FN_ACC bool rayx::Variant::is () const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-operator","title":"function operator=","text":"<pre><code>Variant &amp; rayx::Variant::operator= (\n    const Variant &amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-operator_1","title":"function operator=","text":"<pre><code>Variant &amp; rayx::Variant::operator= (\n    Variant &amp;&amp;\n) = default\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-operator_2","title":"function operator=","text":"<pre><code>template&lt;typename T&gt;\ninline Variant &amp; rayx::Variant::operator= (\n    const T &amp; other\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-operator_3","title":"function operator=","text":"<pre><code>template&lt;typename T&gt;\ninline Variant &amp; rayx::Variant::operator= (\n    T &amp;&amp; value\n) \n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-visit-12","title":"function visit [1/2]","text":"<pre><code>template&lt;typename Visitor&gt;\ninline RAYX_FN_ACC decltype(auto) rayx::Variant::visit (\n    const Visitor &amp; visitor\n) const\n</code></pre>"},{"location":"rayxCore/classrayx_1_1Variant/#function-visit-22","title":"function visit [2/2]","text":"<pre><code>template&lt;typename Visitor&gt;\ninline RAYX_FN_ACC decltype(auto) rayx::Variant::visit (\n    Visitor &amp;&amp; visitor\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Variant.h</code></p>"},{"location":"rayxCore/structrayx_1_1Verb/","title":"Struct rayx::Verb","text":"<p>ClassList &gt; rayx &gt; Verb</p>"},{"location":"rayxCore/structrayx_1_1Verb/#public-functions","title":"Public Functions","text":"Type Name Verb (std::string filename, int line)  Verb &amp; operator&lt;&lt; (T t)  ~Verb ()"},{"location":"rayxCore/structrayx_1_1Verb/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Verb/#function-verb","title":"function Verb","text":"<pre><code>rayx::Verb::Verb (\n    std::string filename,\n    int line\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Verb/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline Verb &amp; rayx::Verb::operator&lt;&lt; (\n    T t\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Verb/#function-verb_1","title":"function ~Verb","text":"<pre><code>rayx::Verb::~Verb () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/structrayx_1_1Warn/","title":"Struct rayx::Warn","text":"<p>ClassList &gt; rayx &gt; Warn</p>"},{"location":"rayxCore/structrayx_1_1Warn/#public-functions","title":"Public Functions","text":"Type Name Warn (std::string filename, int line)  Warn &amp; operator&lt;&lt; (T t)  ~Warn ()"},{"location":"rayxCore/structrayx_1_1Warn/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1Warn/#function-warn","title":"function Warn","text":"<pre><code>rayx::Warn::Warn (\n    std::string filename,\n    int line\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Warn/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline Warn &amp; rayx::Warn::operator&lt;&lt; (\n    T t\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1Warn/#function-warn_1","title":"function ~Warn","text":"<pre><code>rayx::Warn::~Warn () \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1complex/","title":"Namespace rayx::complex","text":"<p>Namespace List &gt; rayx &gt; complex</p>"},{"location":"rayxCore/namespacerayx_1_1complex/#public-types","title":"Public Types","text":"Type Name typedef tcomplex&lt; double &gt; Complex typedef std::complex&lt; T &gt; tcomplex"},{"location":"rayxCore/namespacerayx_1_1complex/#public-functions","title":"Public Functions","text":"Type Name RAYX_FN_ACC glm::dvec2 abs (cvec2 v)  RAYX_FN_ACC glm::dvec3 abs (cvec3 v)  RAYX_FN_ACC glm::dvec2 arg (cvec2 v)  RAYX_FN_ACC glm::dvec3 arg (cvec3 v)  RAYX_FN_ACC cvec2 polar (glm::dvec2 mag, glm::dvec2 theta)  RAYX_FN_ACC cvec3 polar (glm::dvec3 mag, glm::dvec3 theta)"},{"location":"rayxCore/namespacerayx_1_1complex/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"rayxCore/namespacerayx_1_1complex/#typedef-complex","title":"typedef Complex","text":"<pre><code>using rayx::complex::Complex = typedef tcomplex&lt;double&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#typedef-tcomplex","title":"typedef tcomplex","text":"<pre><code>using rayx::complex::tcomplex = typedef std::complex&lt;T&gt;;\n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/namespacerayx_1_1complex/#function-abs","title":"function abs","text":"<pre><code>inline RAYX_FN_ACC glm::dvec2 rayx::complex::abs (\n    cvec2 v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#function-abs_1","title":"function abs","text":"<pre><code>inline RAYX_FN_ACC glm::dvec3 rayx::complex::abs (\n    cvec3 v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#function-arg","title":"function arg","text":"<pre><code>inline RAYX_FN_ACC glm::dvec2 rayx::complex::arg (\n    cvec2 v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#function-arg_1","title":"function arg","text":"<pre><code>inline RAYX_FN_ACC glm::dvec3 rayx::complex::arg (\n    cvec3 v\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#function-polar","title":"function polar","text":"<pre><code>inline RAYX_FN_ACC cvec2 rayx::complex::polar (\n    glm::dvec2 mag,\n    glm::dvec2 theta\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1complex/#function-polar_1","title":"function polar","text":"<pre><code>inline RAYX_FN_ACC cvec3 rayx::complex::polar (\n    glm::dvec3 mag,\n    glm::dvec3 theta\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Complex.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1detail/","title":"Namespace rayx::detail","text":"<p>Namespace List &gt; rayx &gt; detail</p>"},{"location":"rayxCore/namespacerayx_1_1detail/#classes","title":"Classes","text":"Type Name struct BehaviourTypes struct CoatingTypes struct CutoutTypes struct Ray struct SurfaceTypes <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes/","title":"Struct rayx::detail::BehaviourTypes","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes</p> <p>Inherited by the following classes: rayx::Variant</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes/#classes","title":"Classes","text":"Type Name struct Crystal struct Foil struct Grating struct ImagePlane struct Mirror struct RZP struct Slit <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/","title":"Struct rayx::detail::BehaviourTypes::Crystal","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; Crystal</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#public-attributes","title":"Public Attributes","text":"Type Name double m_dSpacing2 double m_offsetAngle double m_structureFactorImF0 double m_structureFactorImFH double m_structureFactorImFHC double m_structureFactorReF0 double m_structureFactorReFH double m_structureFactorReFHC double m_unitCellVolume"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_dspacing2","title":"variable m_dSpacing2","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_dSpacing2;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_offsetangle","title":"variable m_offsetAngle","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_offsetAngle;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorimf0","title":"variable m_structureFactorImF0","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorImF0;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorimfh","title":"variable m_structureFactorImFH","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorImFH;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorimfhc","title":"variable m_structureFactorImFHC","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorImFHC;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorref0","title":"variable m_structureFactorReF0","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorReF0;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorrefh","title":"variable m_structureFactorReFH","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorReFH;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_structurefactorrefhc","title":"variable m_structureFactorReFHC","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_structureFactorReFHC;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Crystal/#variable-m_unitcellvolume","title":"variable m_unitCellVolume","text":"<pre><code>double rayx::detail::BehaviourTypes::Crystal::m_unitCellVolume;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Foil/","title":"Struct rayx::detail::BehaviourTypes::Foil","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; Foil</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Foil/#public-attributes","title":"Public Attributes","text":"Type Name double m_roughnessSubstrate double m_thicknessSubstrate"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Foil/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Foil/#variable-m_roughnesssubstrate","title":"variable m_roughnessSubstrate","text":"<pre><code>double rayx::detail::BehaviourTypes::Foil::m_roughnessSubstrate;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Foil/#variable-m_thicknesssubstrate","title":"variable m_thicknessSubstrate","text":"<pre><code>double rayx::detail::BehaviourTypes::Foil::m_thicknessSubstrate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/","title":"Struct rayx::detail::BehaviourTypes::Grating","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; Grating</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/#public-attributes","title":"Public Attributes","text":"Type Name double m_lineDensity int m_orderOfDiffraction double m_vls"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/#variable-m_linedensity","title":"variable m_lineDensity","text":"<pre><code>double rayx::detail::BehaviourTypes::Grating::m_lineDensity;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/#variable-m_orderofdiffraction","title":"variable m_orderOfDiffraction","text":"<pre><code>int rayx::detail::BehaviourTypes::Grating::m_orderOfDiffraction;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Grating/#variable-m_vls","title":"variable m_vls","text":"<pre><code>double rayx::detail::BehaviourTypes::Grating::m_vls[6];\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1ImagePlane/","title":"Struct rayx::detail::BehaviourTypes::ImagePlane","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; ImagePlane</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Mirror/","title":"Struct rayx::detail::BehaviourTypes::Mirror","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; Mirror</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/","title":"Struct rayx::detail::BehaviourTypes::RZP","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; RZP</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#public-attributes","title":"Public Attributes","text":"Type Name int m_additionalOrder int m_derivationMethod double m_designAlphaAngle double m_designBetaAngle double m_designMeridionalEntranceArmLength double m_designMeridionalExitArmLength int m_designOrderOfDiffraction double m_designSagittalEntranceArmLength double m_designSagittalExitArmLength double m_designWavelength double m_fresnelZOffset int m_imageType int m_orderOfDiffraction int m_rzpType"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_additionalorder","title":"variable m_additionalOrder","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_additionalOrder;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_derivationmethod","title":"variable m_derivationMethod","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_derivationMethod;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designalphaangle","title":"variable m_designAlphaAngle","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designAlphaAngle;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designbetaangle","title":"variable m_designBetaAngle","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designBetaAngle;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designmeridionalentrancearmlength","title":"variable m_designMeridionalEntranceArmLength","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designMeridionalEntranceArmLength;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designmeridionalexitarmlength","title":"variable m_designMeridionalExitArmLength","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designMeridionalExitArmLength;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designorderofdiffraction","title":"variable m_designOrderOfDiffraction","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_designOrderOfDiffraction;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designsagittalentrancearmlength","title":"variable m_designSagittalEntranceArmLength","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designSagittalEntranceArmLength;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designsagittalexitarmlength","title":"variable m_designSagittalExitArmLength","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designSagittalExitArmLength;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_designwavelength","title":"variable m_designWavelength","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_designWavelength;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_fresnelzoffset","title":"variable m_fresnelZOffset","text":"<pre><code>double rayx::detail::BehaviourTypes::RZP::m_fresnelZOffset;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_imagetype","title":"variable m_imageType","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_imageType;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_orderofdiffraction","title":"variable m_orderOfDiffraction","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_orderOfDiffraction;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1RZP/#variable-m_rzptype","title":"variable m_rzpType","text":"<pre><code>int rayx::detail::BehaviourTypes::RZP::m_rzpType;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Slit/","title":"Struct rayx::detail::BehaviourTypes::Slit","text":"<p>ClassList &gt; rayx &gt; detail &gt; BehaviourTypes &gt; Slit</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Slit/#public-attributes","title":"Public Attributes","text":"Type Name Cutout m_beamstopCutout Cutout m_openingCutout"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Slit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Slit/#variable-m_beamstopcutout","title":"variable m_beamstopCutout","text":"<pre><code>Cutout rayx::detail::BehaviourTypes::Slit::m_beamstopCutout;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1BehaviourTypes_1_1Slit/#variable-m_openingcutout","title":"variable m_openingCutout","text":"<pre><code>Cutout rayx::detail::BehaviourTypes::Slit::m_openingCutout;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes/","title":"Struct rayx::detail::CoatingTypes","text":"<p>ClassList &gt; rayx &gt; detail &gt; CoatingTypes</p> <p>Inherited by the following classes: rayx::Variant</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes/#classes","title":"Classes","text":"Type Name struct MultilayerCoating struct OneCoating struct SubstrateOnly <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Coating.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/","title":"Struct rayx::detail::CoatingTypes::MultilayerCoating","text":"<p>ClassList &gt; rayx &gt; detail &gt; CoatingTypes &gt; MultilayerCoating</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#public-attributes","title":"Public Attributes","text":"Type Name int material int numLayers double roughness double thickness"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#variable-material","title":"variable material","text":"<pre><code>int rayx::detail::CoatingTypes::MultilayerCoating::material[1000];\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#variable-numlayers","title":"variable numLayers","text":"<pre><code>int rayx::detail::CoatingTypes::MultilayerCoating::numLayers;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#variable-roughness","title":"variable roughness","text":"<pre><code>double rayx::detail::CoatingTypes::MultilayerCoating::roughness[1000];\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1MultilayerCoating/#variable-thickness","title":"variable thickness","text":"<pre><code>double rayx::detail::CoatingTypes::MultilayerCoating::thickness[1000];\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Coating.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/","title":"Struct rayx::detail::CoatingTypes::OneCoating","text":"<p>ClassList &gt; rayx &gt; detail &gt; CoatingTypes &gt; OneCoating</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/#public-attributes","title":"Public Attributes","text":"Type Name int material double roughness double thickness"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/#variable-material","title":"variable material","text":"<pre><code>int rayx::detail::CoatingTypes::OneCoating::material;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/#variable-roughness","title":"variable roughness","text":"<pre><code>double rayx::detail::CoatingTypes::OneCoating::roughness;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1OneCoating/#variable-thickness","title":"variable thickness","text":"<pre><code>double rayx::detail::CoatingTypes::OneCoating::thickness;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Coating.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CoatingTypes_1_1SubstrateOnly/","title":"Struct rayx::detail::CoatingTypes::SubstrateOnly","text":"<p>ClassList &gt; rayx &gt; detail &gt; CoatingTypes &gt; SubstrateOnly</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Coating.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes/","title":"Struct rayx::detail::CutoutTypes","text":"<p>ClassList &gt; rayx &gt; detail &gt; CutoutTypes</p> <p>Inherited by the following classes: rayx::Variant</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes/#classes","title":"Classes","text":"Type Name struct Elliptical struct Rect struct Trapezoid struct Unlimited <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Elliptical/","title":"Struct rayx::detail::CutoutTypes::Elliptical","text":"<p>ClassList &gt; rayx &gt; detail &gt; CutoutTypes &gt; Elliptical</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Elliptical/#public-attributes","title":"Public Attributes","text":"Type Name double m_diameter_x double m_diameter_z"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Elliptical/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Elliptical/#variable-m_diameter_x","title":"variable m_diameter_x","text":"<pre><code>double rayx::detail::CutoutTypes::Elliptical::m_diameter_x;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Elliptical/#variable-m_diameter_z","title":"variable m_diameter_z","text":"<pre><code>double rayx::detail::CutoutTypes::Elliptical::m_diameter_z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Rect/","title":"Struct rayx::detail::CutoutTypes::Rect","text":"<p>ClassList &gt; rayx &gt; detail &gt; CutoutTypes &gt; Rect</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Rect/#public-attributes","title":"Public Attributes","text":"Type Name double m_length double m_width"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Rect/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Rect/#variable-m_length","title":"variable m_length","text":"<pre><code>double rayx::detail::CutoutTypes::Rect::m_length;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Rect/#variable-m_width","title":"variable m_width","text":"<pre><code>double rayx::detail::CutoutTypes::Rect::m_width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/","title":"Struct rayx::detail::CutoutTypes::Trapezoid","text":"<p>ClassList &gt; rayx &gt; detail &gt; CutoutTypes &gt; Trapezoid</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/#public-attributes","title":"Public Attributes","text":"Type Name double m_length double m_widthA double m_widthB"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/#variable-m_length","title":"variable m_length","text":"<pre><code>double rayx::detail::CutoutTypes::Trapezoid::m_length;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/#variable-m_widtha","title":"variable m_widthA","text":"<pre><code>double rayx::detail::CutoutTypes::Trapezoid::m_widthA;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Trapezoid/#variable-m_widthb","title":"variable m_widthB","text":"<pre><code>double rayx::detail::CutoutTypes::Trapezoid::m_widthB;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1CutoutTypes_1_1Unlimited/","title":"Struct rayx::detail::CutoutTypes::Unlimited","text":"<p>ClassList &gt; rayx &gt; detail &gt; CutoutTypes &gt; Unlimited</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/","title":"Struct rayx::detail::Ray","text":"<p>ClassList &gt; rayx &gt; detail &gt; Ray</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#public-attributes","title":"Public Attributes","text":"Type Name glm::dvec3 direction ElectricField electric_field double energy EventType event_type int object_id double optical_path_length int order int path_event_id int path_id glm::dvec3 position Rand rand int source_id"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-direction","title":"variable direction","text":"<pre><code>glm::dvec3 rayx::detail::Ray::direction;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-electric_field","title":"variable electric_field","text":"<pre><code>ElectricField rayx::detail::Ray::electric_field;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-energy","title":"variable energy","text":"<pre><code>double rayx::detail::Ray::energy;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-event_type","title":"variable event_type","text":"<pre><code>EventType rayx::detail::Ray::event_type;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-object_id","title":"variable object_id","text":"<pre><code>int rayx::detail::Ray::object_id;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-optical_path_length","title":"variable optical_path_length","text":"<pre><code>double rayx::detail::Ray::optical_path_length;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-order","title":"variable order","text":"<pre><code>int rayx::detail::Ray::order;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-path_event_id","title":"variable path_event_id","text":"<pre><code>int rayx::detail::Ray::path_event_id;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-path_id","title":"variable path_id","text":"<pre><code>int rayx::detail::Ray::path_id;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-position","title":"variable position","text":"<pre><code>glm::dvec3 rayx::detail::Ray::position;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-rand","title":"variable rand","text":"<pre><code>Rand rayx::detail::Ray::rand;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1Ray/#variable-source_id","title":"variable source_id","text":"<pre><code>int rayx::detail::Ray::source_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Ray.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes/","title":"Struct rayx::detail::SurfaceTypes","text":"<p>ClassList &gt; rayx &gt; detail &gt; SurfaceTypes</p> <p>Inherited by the following classes: rayx::Variant</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes/#classes","title":"Classes","text":"Type Name struct Cubic struct Plane struct Quadric struct Toroid <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/","title":"Struct rayx::detail::SurfaceTypes::Cubic","text":"<p>ClassList &gt; rayx &gt; detail &gt; SurfaceTypes &gt; Cubic</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#public-attributes","title":"Public Attributes","text":"Type Name double m_a11 double m_a12 double m_a13 double m_a14 double m_a22 double m_a23 double m_a24 double m_a33 double m_a34 double m_a44 double m_b12 double m_b13 double m_b21 double m_b23 double m_b31 double m_b32 double m_psi"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a11","title":"variable m_a11","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a11;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a12","title":"variable m_a12","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a12;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a13","title":"variable m_a13","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a13;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a14","title":"variable m_a14","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a14;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a22","title":"variable m_a22","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a22;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a23","title":"variable m_a23","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a23;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a24","title":"variable m_a24","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a24;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a33","title":"variable m_a33","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a33;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a34","title":"variable m_a34","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a34;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_a44","title":"variable m_a44","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_a44;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b12","title":"variable m_b12","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b12;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b13","title":"variable m_b13","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b13;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b21","title":"variable m_b21","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b21;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b23","title":"variable m_b23","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b23;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b31","title":"variable m_b31","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b31;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_b32","title":"variable m_b32","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_b32;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Cubic/#variable-m_psi","title":"variable m_psi","text":"<pre><code>double rayx::detail::SurfaceTypes::Cubic::m_psi;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Plane/","title":"Struct rayx::detail::SurfaceTypes::Plane","text":"<p>ClassList &gt; rayx &gt; detail &gt; SurfaceTypes &gt; Plane</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/","title":"Struct rayx::detail::SurfaceTypes::Quadric","text":"<p>ClassList &gt; rayx &gt; detail &gt; SurfaceTypes &gt; Quadric</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#public-attributes","title":"Public Attributes","text":"Type Name double m_a11 double m_a12 double m_a13 double m_a14 double m_a22 double m_a23 double m_a24 double m_a33 double m_a34 double m_a44 int m_icurv"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a11","title":"variable m_a11","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a11;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a12","title":"variable m_a12","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a12;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a13","title":"variable m_a13","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a13;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a14","title":"variable m_a14","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a14;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a22","title":"variable m_a22","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a22;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a23","title":"variable m_a23","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a23;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a24","title":"variable m_a24","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a24;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a33","title":"variable m_a33","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a33;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a34","title":"variable m_a34","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a34;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_a44","title":"variable m_a44","text":"<pre><code>double rayx::detail::SurfaceTypes::Quadric::m_a44;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Quadric/#variable-m_icurv","title":"variable m_icurv","text":"<pre><code>int rayx::detail::SurfaceTypes::Quadric::m_icurv;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/","title":"Struct rayx::detail::SurfaceTypes::Toroid","text":"<p>ClassList &gt; rayx &gt; detail &gt; SurfaceTypes &gt; Toroid</p>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/#public-attributes","title":"Public Attributes","text":"Type Name double m_longRadius double m_shortRadius ToroidType m_toroidType"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/#variable-m_longradius","title":"variable m_longRadius","text":"<pre><code>double rayx::detail::SurfaceTypes::Toroid::m_longRadius;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/#variable-m_shortradius","title":"variable m_shortRadius","text":"<pre><code>double rayx::detail::SurfaceTypes::Toroid::m_shortRadius;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1detail_1_1SurfaceTypes_1_1Toroid/#variable-m_toroidtype","title":"variable m_toroidType","text":"<pre><code>ToroidType rayx::detail::SurfaceTypes::Toroid::m_toroidType;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1xml/","title":"Namespace rayx::xml","text":"<p>Namespace List &gt; rayx &gt; xml</p>"},{"location":"rayxCore/namespacerayx_1_1xml/#classes","title":"Classes","text":"Type Name struct Parser"},{"location":"rayxCore/namespacerayx_1_1xml/#public-functions","title":"Public Functions","text":"Type Name bool param (const rapidxml::xml_node&lt;&gt; * node, const char * paramname, rapidxml::xml_node&lt;&gt; ** out)  bool paramDouble (const rapidxml::xml_node&lt;&gt; * node, const char * paramname, double * out)  bool paramDvec3 (const rapidxml::xml_node&lt;&gt; * node, const char * paramname, glm::dvec3 * out)  bool paramElectronEnergyOrientation (const rapidxml::xml_node&lt;&gt; * node, ElectronEnergyOrientation * out)  bool paramEnergyDistribution (const rapidxml::xml_node&lt;&gt; * node, const std::filesystem::path &amp; rmlFile, EnergyDistribution * out)  bool paramInt (const rapidxml::xml_node&lt;&gt; * node, const char * paramname, int * out)  bool paramMaterial (const rapidxml::xml_node&lt;&gt; * node, Material * out)  bool paramMultilayer (const rapidxml::xml_node&lt;&gt; * node, Coating * out)  std::optional&lt; glm::dmat4x4 &gt; paramOrientation (const rapidxml::xml_node&lt;&gt; * node)  std::optional&lt; glm::dvec4 &gt; paramPosition (const rapidxml::xml_node&lt;&gt; * node)  bool paramSlopeError (const rapidxml::xml_node&lt;&gt; * node, SlopeError * out)  bool paramSourcePulseType (const rapidxml::xml_node&lt;&gt; * node, SourcePulseType * out)  bool paramStr (const rapidxml::xml_node&lt;&gt; * node, const char * paramname, const char ** out)  bool paramVls (const rapidxml::xml_node&lt;&gt; * node, std::array&lt; double, 6 &gt; * out)  std::optional&lt; Group &gt; parseGroup (rapidxml::xml_node&lt;&gt; * node)"},{"location":"rayxCore/namespacerayx_1_1xml/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/namespacerayx_1_1xml/#function-param","title":"function param","text":"<pre><code>bool rayx::xml::param (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const char * paramname,\n    rapidxml::xml_node&lt;&gt; ** out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramdouble","title":"function paramDouble","text":"<pre><code>bool rayx::xml::paramDouble (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const char * paramname,\n    double * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramdvec3","title":"function paramDvec3","text":"<pre><code>bool rayx::xml::paramDvec3 (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const char * paramname,\n    glm::dvec3 * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramelectronenergyorientation","title":"function paramElectronEnergyOrientation","text":"<pre><code>bool rayx::xml::paramElectronEnergyOrientation (\n    const rapidxml::xml_node&lt;&gt; * node,\n    ElectronEnergyOrientation * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramenergydistribution","title":"function paramEnergyDistribution","text":"<pre><code>bool rayx::xml::paramEnergyDistribution (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const std::filesystem::path &amp; rmlFile,\n    EnergyDistribution * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramint","title":"function paramInt","text":"<pre><code>bool rayx::xml::paramInt (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const char * paramname,\n    int * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-parammaterial","title":"function paramMaterial","text":"<pre><code>bool rayx::xml::paramMaterial (\n    const rapidxml::xml_node&lt;&gt; * node,\n    Material * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-parammultilayer","title":"function paramMultilayer","text":"<pre><code>bool rayx::xml::paramMultilayer (\n    const rapidxml::xml_node&lt;&gt; * node,\n    Coating * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramorientation","title":"function paramOrientation","text":"<pre><code>std::optional&lt; glm::dmat4x4 &gt; rayx::xml::paramOrientation (\n    const rapidxml::xml_node&lt;&gt; * node\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramposition","title":"function paramPosition","text":"<pre><code>std::optional&lt; glm::dvec4 &gt; rayx::xml::paramPosition (\n    const rapidxml::xml_node&lt;&gt; * node\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramslopeerror","title":"function paramSlopeError","text":"<pre><code>bool rayx::xml::paramSlopeError (\n    const rapidxml::xml_node&lt;&gt; * node,\n    SlopeError * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramsourcepulsetype","title":"function paramSourcePulseType","text":"<pre><code>bool rayx::xml::paramSourcePulseType (\n    const rapidxml::xml_node&lt;&gt; * node,\n    SourcePulseType * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramstr","title":"function paramStr","text":"<pre><code>bool rayx::xml::paramStr (\n    const rapidxml::xml_node&lt;&gt; * node,\n    const char * paramname,\n    const char ** out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-paramvls","title":"function paramVls","text":"<pre><code>bool rayx::xml::paramVls (\n    const rapidxml::xml_node&lt;&gt; * node,\n    std::array&lt; double, 6 &gt; * out\n) \n</code></pre>"},{"location":"rayxCore/namespacerayx_1_1xml/#function-parsegroup","title":"function parseGroup","text":"<pre><code>std::optional&lt; Group &gt; rayx::xml::parseGroup (\n    rapidxml::xml_node&lt;&gt; * node\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/xml.h</code></p>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/","title":"Struct rayx::xml::Parser","text":"<p>ClassList &gt; rayx &gt; xml &gt; Parser</p>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#public-attributes","title":"Public Attributes","text":"Type Name rapidxml::xml_node * node std::filesystem::path rmlFile"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#public-functions","title":"Public Functions","text":"Type Name Parser (rapidxml::xml_node&lt;&gt; * node, std::filesystem::path rmlFile)  const char * name () const double parseAdditionalOrder () const int parseAlignmentError () const double parseArmLength () const Rad parseAzimuthalAngle () const CylinderDirection parseBendingRadius () const double parseBendingRadiusDouble () const CentralBeamstop parseCentralBeamstop () const int parseCircularPol () const Coating::MultilayerCoating parseCoating () const std::string parseCrystalMaterial () const CrystalType parseCrystalType () const Surface::Cubic parseCubicParameters () const CurvatureType parseCurvatureType () const Cutout parseCutout (DesignPlane, std::string) const double parseDSpacing2 () const Rad parseDeltaOpeningAngle () const double parseDensitySubstrate () const Rad parseDesignAlphaAngle () const Rad parseDesignBetaAngle () const double parseDesignEnergy () const double parseDesignEnergyMounting () const Rad parseDesignGrazingIncAngle () const double parseDesignOrderDiffraction () const Rad parseDeviationAngle () const double parseDistancePreceding () const double parseDouble (const char * paramname) const glm::dvec3 parseDvec3 (const char * paramname) const double parseElectronEnergy () const ElectronEnergyOrientation parseElectronEnergyOrientation () const double parseElectronSigmaX () const double parseElectronSigmaXs () const double parseElectronSigmaY () const double parseElectronSigmaYs () const std::filesystem::path parseEnergyDistributionFile () const EnergyDistributionType parseEnergyDistributionType () const double parseEnergySpread () const SpreadType parseEnergySpreadType () const EnergySpreadUnit parseEnergySpreadUnit () const double parseEntranceArmLength () const double parseEntranceArmLengthMer () const double parseEntranceArmLengthSag () const double parseExitArmLength () const double parseExitArmLengthMer () const double parseExitArmLengthSag () const FigureRotation parseFigureRotation () const double parseFresnelZOffset () const GratingMount parseGratingMount () const Rad parseGrazingIncAngle () const double parseHorDiv () const SourceDist parseHorDivDistribution () const double parseImageType () const int parseInt (const char * paramname) const double parseLineDensity () const int parseLinearPol0 () const int parseLinearPol45 () const double parseLongHalfAxisA () const double parseLongRadius () const Material parseMaterial () const Material parseMaterialCoating () const Rad parseMaxOpeningAngle () const Rad parseMinOpeningAngle () const int parseNumOfEquidistantCircles () const int parseNumberOfSeparateEnergies () const int parseNumberRays () const Rad parseOffsetAngle () const OffsetAngleType parseOffsetAngleType () const double parseOpeningHeight () const double parseOpeningShape () const double parseOpeningWidth () const double parseOrderDiffraction () const glm::dmat4x4 parseOrientation () const double parseParameterA11 () const double parseParameterP () const double parseParameterPType () const double parsePhotonEnergy () const double parsePhotonFlux () const glm::dvec4 parsePosition () const int parseProfileKind () const Surface::Quadric parseQuadricParameters () const double parseRadius () const double parseRoughnessCoating () const double parseRoughnessSubstrate () const double parseShortHalfAxisB () const double parseShortRadius () const SigmaType parseSigmaType () const SlopeError parseSlopeError () const double parseSourceDepth () const double parseSourceHeight () const SourceDist parseSourceHeightDistribution () const SourcePulseType parseSourcePulseType () const double parseSourceWidth () const SourceDist parseSourceWidthDistribution () const const char * parseStr (const char * paramname) const double parseStructureFactorImF0 () const double parseStructureFactorImFH () const double parseStructureFactorImFHC () const double parseStructureFactorReF0 () const double parseStructureFactorReFH () const double parseStructureFactorReFHC () const SurfaceCoatingType parseSurfaceCoatingType () const double parseThicknessCoating () const double parseThicknessSubstrate () const double parseTotalHeight () const double parseTotalHeightStop () const double parseTotalLength () const double parseTotalWidth () const double parseTotalWidthStop () const double parseUndulatorLength () const double parseUnitCellVolume () const double parseVerDiv () const SourceDist parseVerDivDistribution () const double parseVerEbeamDivergence () const std::array&lt; double, 6 &gt; parseVls () const ElementType type () const"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#variable-node","title":"variable node","text":"<pre><code>rapidxml::xml_node* rayx::xml::Parser::node;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#variable-rmlfile","title":"variable rmlFile","text":"<pre><code>std::filesystem::path rayx::xml::Parser::rmlFile;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parser","title":"function Parser","text":"<pre><code>rayx::xml::Parser::Parser (\n    rapidxml::xml_node&lt;&gt; * node,\n    std::filesystem::path rmlFile\n) \n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-name","title":"function name","text":"<pre><code>const char * rayx::xml::Parser::name () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseadditionalorder","title":"function parseAdditionalOrder","text":"<pre><code>double rayx::xml::Parser::parseAdditionalOrder () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsealignmenterror","title":"function parseAlignmentError","text":"<pre><code>inline int rayx::xml::Parser::parseAlignmentError () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsearmlength","title":"function parseArmLength","text":"<pre><code>inline double rayx::xml::Parser::parseArmLength () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseazimuthalangle","title":"function parseAzimuthalAngle","text":"<pre><code>Rad rayx::xml::Parser::parseAzimuthalAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsebendingradius","title":"function parseBendingRadius","text":"<pre><code>inline CylinderDirection rayx::xml::Parser::parseBendingRadius () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsebendingradiusdouble","title":"function parseBendingRadiusDouble","text":"<pre><code>inline double rayx::xml::Parser::parseBendingRadiusDouble () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecentralbeamstop","title":"function parseCentralBeamstop","text":"<pre><code>inline CentralBeamstop rayx::xml::Parser::parseCentralBeamstop () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecircularpol","title":"function parseCircularPol","text":"<pre><code>inline int rayx::xml::Parser::parseCircularPol () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecoating","title":"function parseCoating","text":"<pre><code>Coating::MultilayerCoating rayx::xml::Parser::parseCoating () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecrystalmaterial","title":"function parseCrystalMaterial","text":"<pre><code>inline std::string rayx::xml::Parser::parseCrystalMaterial () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecrystaltype","title":"function parseCrystalType","text":"<pre><code>inline CrystalType rayx::xml::Parser::parseCrystalType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecubicparameters","title":"function parseCubicParameters","text":"<pre><code>Surface::Cubic rayx::xml::Parser::parseCubicParameters () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecurvaturetype","title":"function parseCurvatureType","text":"<pre><code>inline CurvatureType rayx::xml::Parser::parseCurvatureType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsecutout","title":"function parseCutout","text":"<pre><code>Cutout rayx::xml::Parser::parseCutout (\n    DesignPlane,\n    std::string\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedspacing2","title":"function parseDSpacing2","text":"<pre><code>inline double rayx::xml::Parser::parseDSpacing2 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedeltaopeningangle","title":"function parseDeltaOpeningAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseDeltaOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedensitysubstrate","title":"function parseDensitySubstrate","text":"<pre><code>inline double rayx::xml::Parser::parseDensitySubstrate () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesignalphaangle","title":"function parseDesignAlphaAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseDesignAlphaAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesignbetaangle","title":"function parseDesignBetaAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseDesignBetaAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesignenergy","title":"function parseDesignEnergy","text":"<pre><code>inline double rayx::xml::Parser::parseDesignEnergy () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesignenergymounting","title":"function parseDesignEnergyMounting","text":"<pre><code>inline double rayx::xml::Parser::parseDesignEnergyMounting () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesigngrazingincangle","title":"function parseDesignGrazingIncAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseDesignGrazingIncAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedesignorderdiffraction","title":"function parseDesignOrderDiffraction","text":"<pre><code>inline double rayx::xml::Parser::parseDesignOrderDiffraction () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedeviationangle","title":"function parseDeviationAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseDeviationAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedistancepreceding","title":"function parseDistancePreceding","text":"<pre><code>inline double rayx::xml::Parser::parseDistancePreceding () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedouble","title":"function parseDouble","text":"<pre><code>double rayx::xml::Parser::parseDouble (\n    const char * paramname\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsedvec3","title":"function parseDvec3","text":"<pre><code>glm::dvec3 rayx::xml::Parser::parseDvec3 (\n    const char * paramname\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronenergy","title":"function parseElectronEnergy","text":"<pre><code>inline double rayx::xml::Parser::parseElectronEnergy () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronenergyorientation","title":"function parseElectronEnergyOrientation","text":"<pre><code>ElectronEnergyOrientation rayx::xml::Parser::parseElectronEnergyOrientation () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronsigmax","title":"function parseElectronSigmaX","text":"<pre><code>inline double rayx::xml::Parser::parseElectronSigmaX () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronsigmaxs","title":"function parseElectronSigmaXs","text":"<pre><code>inline double rayx::xml::Parser::parseElectronSigmaXs () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronsigmay","title":"function parseElectronSigmaY","text":"<pre><code>inline double rayx::xml::Parser::parseElectronSigmaY () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseelectronsigmays","title":"function parseElectronSigmaYs","text":"<pre><code>inline double rayx::xml::Parser::parseElectronSigmaYs () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseenergydistributionfile","title":"function parseEnergyDistributionFile","text":"<pre><code>std::filesystem::path rayx::xml::Parser::parseEnergyDistributionFile () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseenergydistributiontype","title":"function parseEnergyDistributionType","text":"<pre><code>inline EnergyDistributionType rayx::xml::Parser::parseEnergyDistributionType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseenergyspread","title":"function parseEnergySpread","text":"<pre><code>inline double rayx::xml::Parser::parseEnergySpread () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseenergyspreadtype","title":"function parseEnergySpreadType","text":"<pre><code>inline SpreadType rayx::xml::Parser::parseEnergySpreadType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseenergyspreadunit","title":"function parseEnergySpreadUnit","text":"<pre><code>inline EnergySpreadUnit rayx::xml::Parser::parseEnergySpreadUnit () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseentrancearmlength","title":"function parseEntranceArmLength","text":"<pre><code>inline double rayx::xml::Parser::parseEntranceArmLength () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseentrancearmlengthmer","title":"function parseEntranceArmLengthMer","text":"<pre><code>inline double rayx::xml::Parser::parseEntranceArmLengthMer () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseentrancearmlengthsag","title":"function parseEntranceArmLengthSag","text":"<pre><code>inline double rayx::xml::Parser::parseEntranceArmLengthSag () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseexitarmlength","title":"function parseExitArmLength","text":"<pre><code>inline double rayx::xml::Parser::parseExitArmLength () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseexitarmlengthmer","title":"function parseExitArmLengthMer","text":"<pre><code>inline double rayx::xml::Parser::parseExitArmLengthMer () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseexitarmlengthsag","title":"function parseExitArmLengthSag","text":"<pre><code>inline double rayx::xml::Parser::parseExitArmLengthSag () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsefigurerotation","title":"function parseFigureRotation","text":"<pre><code>inline FigureRotation rayx::xml::Parser::parseFigureRotation () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsefresnelzoffset","title":"function parseFresnelZOffset","text":"<pre><code>inline double rayx::xml::Parser::parseFresnelZOffset () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsegratingmount","title":"function parseGratingMount","text":"<pre><code>inline GratingMount rayx::xml::Parser::parseGratingMount () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsegrazingincangle","title":"function parseGrazingIncAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseGrazingIncAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsehordiv","title":"function parseHorDiv","text":"<pre><code>inline double rayx::xml::Parser::parseHorDiv () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsehordivdistribution","title":"function parseHorDivDistribution","text":"<pre><code>inline SourceDist rayx::xml::Parser::parseHorDivDistribution () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseimagetype","title":"function parseImageType","text":"<pre><code>double rayx::xml::Parser::parseImageType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseint","title":"function parseInt","text":"<pre><code>int rayx::xml::Parser::parseInt (\n    const char * paramname\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parselinedensity","title":"function parseLineDensity","text":"<pre><code>inline double rayx::xml::Parser::parseLineDensity () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parselinearpol0","title":"function parseLinearPol0","text":"<pre><code>inline int rayx::xml::Parser::parseLinearPol0 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parselinearpol45","title":"function parseLinearPol45","text":"<pre><code>inline int rayx::xml::Parser::parseLinearPol45 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parselonghalfaxisa","title":"function parseLongHalfAxisA","text":"<pre><code>inline double rayx::xml::Parser::parseLongHalfAxisA () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parselongradius","title":"function parseLongRadius","text":"<pre><code>inline double rayx::xml::Parser::parseLongRadius () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsematerial","title":"function parseMaterial","text":"<pre><code>Material rayx::xml::Parser::parseMaterial () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsematerialcoating","title":"function parseMaterialCoating","text":"<pre><code>Material rayx::xml::Parser::parseMaterialCoating () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsemaxopeningangle","title":"function parseMaxOpeningAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseMaxOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseminopeningangle","title":"function parseMinOpeningAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseMinOpeningAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsenumofequidistantcircles","title":"function parseNumOfEquidistantCircles","text":"<pre><code>inline int rayx::xml::Parser::parseNumOfEquidistantCircles () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsenumberofseparateenergies","title":"function parseNumberOfSeparateEnergies","text":"<pre><code>inline int rayx::xml::Parser::parseNumberOfSeparateEnergies () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsenumberrays","title":"function parseNumberRays","text":"<pre><code>inline int rayx::xml::Parser::parseNumberRays () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseoffsetangle","title":"function parseOffsetAngle","text":"<pre><code>inline Rad rayx::xml::Parser::parseOffsetAngle () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseoffsetangletype","title":"function parseOffsetAngleType","text":"<pre><code>inline OffsetAngleType rayx::xml::Parser::parseOffsetAngleType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseopeningheight","title":"function parseOpeningHeight","text":"<pre><code>inline double rayx::xml::Parser::parseOpeningHeight () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseopeningshape","title":"function parseOpeningShape","text":"<pre><code>inline double rayx::xml::Parser::parseOpeningShape () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseopeningwidth","title":"function parseOpeningWidth","text":"<pre><code>inline double rayx::xml::Parser::parseOpeningWidth () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseorderdiffraction","title":"function parseOrderDiffraction","text":"<pre><code>inline double rayx::xml::Parser::parseOrderDiffraction () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseorientation","title":"function parseOrientation","text":"<pre><code>glm::dmat4x4 rayx::xml::Parser::parseOrientation () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseparametera11","title":"function parseParameterA11","text":"<pre><code>inline double rayx::xml::Parser::parseParameterA11 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseparameterp","title":"function parseParameterP","text":"<pre><code>inline double rayx::xml::Parser::parseParameterP () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseparameterptype","title":"function parseParameterPType","text":"<pre><code>inline double rayx::xml::Parser::parseParameterPType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsephotonenergy","title":"function parsePhotonEnergy","text":"<pre><code>inline double rayx::xml::Parser::parsePhotonEnergy () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsephotonflux","title":"function parsePhotonFlux","text":"<pre><code>inline double rayx::xml::Parser::parsePhotonFlux () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseposition","title":"function parsePosition","text":"<pre><code>glm::dvec4 rayx::xml::Parser::parsePosition () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseprofilekind","title":"function parseProfileKind","text":"<pre><code>inline int rayx::xml::Parser::parseProfileKind () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsequadricparameters","title":"function parseQuadricParameters","text":"<pre><code>Surface::Quadric rayx::xml::Parser::parseQuadricParameters () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseradius","title":"function parseRadius","text":"<pre><code>inline double rayx::xml::Parser::parseRadius () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseroughnesscoating","title":"function parseRoughnessCoating","text":"<pre><code>inline double rayx::xml::Parser::parseRoughnessCoating () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseroughnesssubstrate","title":"function parseRoughnessSubstrate","text":"<pre><code>inline double rayx::xml::Parser::parseRoughnessSubstrate () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseshorthalfaxisb","title":"function parseShortHalfAxisB","text":"<pre><code>inline double rayx::xml::Parser::parseShortHalfAxisB () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseshortradius","title":"function parseShortRadius","text":"<pre><code>inline double rayx::xml::Parser::parseShortRadius () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesigmatype","title":"function parseSigmaType","text":"<pre><code>inline SigmaType rayx::xml::Parser::parseSigmaType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseslopeerror","title":"function parseSlopeError","text":"<pre><code>SlopeError rayx::xml::Parser::parseSlopeError () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourcedepth","title":"function parseSourceDepth","text":"<pre><code>inline double rayx::xml::Parser::parseSourceDepth () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourceheight","title":"function parseSourceHeight","text":"<pre><code>inline double rayx::xml::Parser::parseSourceHeight () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourceheightdistribution","title":"function parseSourceHeightDistribution","text":"<pre><code>inline SourceDist rayx::xml::Parser::parseSourceHeightDistribution () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourcepulsetype","title":"function parseSourcePulseType","text":"<pre><code>SourcePulseType rayx::xml::Parser::parseSourcePulseType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourcewidth","title":"function parseSourceWidth","text":"<pre><code>inline double rayx::xml::Parser::parseSourceWidth () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesourcewidthdistribution","title":"function parseSourceWidthDistribution","text":"<pre><code>inline SourceDist rayx::xml::Parser::parseSourceWidthDistribution () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestr","title":"function parseStr","text":"<pre><code>const char * rayx::xml::Parser::parseStr (\n    const char * paramname\n) const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorimf0","title":"function parseStructureFactorImF0","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorImF0 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorimfh","title":"function parseStructureFactorImFH","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorImFH () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorimfhc","title":"function parseStructureFactorImFHC","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorImFHC () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorref0","title":"function parseStructureFactorReF0","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorReF0 () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorrefh","title":"function parseStructureFactorReFH","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorReFH () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsestructurefactorrefhc","title":"function parseStructureFactorReFHC","text":"<pre><code>inline double rayx::xml::Parser::parseStructureFactorReFHC () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsesurfacecoatingtype","title":"function parseSurfaceCoatingType","text":"<pre><code>inline SurfaceCoatingType rayx::xml::Parser::parseSurfaceCoatingType () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsethicknesscoating","title":"function parseThicknessCoating","text":"<pre><code>inline double rayx::xml::Parser::parseThicknessCoating () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsethicknesssubstrate","title":"function parseThicknessSubstrate","text":"<pre><code>inline double rayx::xml::Parser::parseThicknessSubstrate () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsetotalheight","title":"function parseTotalHeight","text":"<pre><code>inline double rayx::xml::Parser::parseTotalHeight () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsetotalheightstop","title":"function parseTotalHeightStop","text":"<pre><code>inline double rayx::xml::Parser::parseTotalHeightStop () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsetotallength","title":"function parseTotalLength","text":"<pre><code>inline double rayx::xml::Parser::parseTotalLength () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsetotalwidth","title":"function parseTotalWidth","text":"<pre><code>inline double rayx::xml::Parser::parseTotalWidth () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsetotalwidthstop","title":"function parseTotalWidthStop","text":"<pre><code>inline double rayx::xml::Parser::parseTotalWidthStop () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseundulatorlength","title":"function parseUndulatorLength","text":"<pre><code>inline double rayx::xml::Parser::parseUndulatorLength () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseunitcellvolume","title":"function parseUnitCellVolume","text":"<pre><code>inline double rayx::xml::Parser::parseUnitCellVolume () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseverdiv","title":"function parseVerDiv","text":"<pre><code>inline double rayx::xml::Parser::parseVerDiv () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseverdivdistribution","title":"function parseVerDivDistribution","text":"<pre><code>inline SourceDist rayx::xml::Parser::parseVerDivDistribution () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parseverebeamdivergence","title":"function parseVerEbeamDivergence","text":"<pre><code>inline double rayx::xml::Parser::parseVerEbeamDivergence () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-parsevls","title":"function parseVls","text":"<pre><code>std::array&lt; double, 6 &gt; rayx::xml::Parser::parseVls () const\n</code></pre>"},{"location":"rayxCore/structrayx_1_1xml_1_1Parser/#function-type","title":"function type","text":"<pre><code>ElementType rayx::xml::Parser::type () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/xml.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1_0d72/","title":"Namespace rayx","text":"<p>Namespace List &gt; rayx</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/namespacerayx_1_1_0d73/","title":"Namespace rayx","text":"<p>Namespace List &gt; rayx</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/MegaKernelTracer.h</code></p>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/","title":"Struct rayx::GenRays::SourceState","text":"<p>ClassList &gt; SourceState</p>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#public-attributes","title":"Public Attributes","text":"Type Name const std::optional&lt; EnergyDistributionDataVariant &gt; energyDistribution std::string name int numRaysSource int numRaysSourceRemaining const SourceVariant source const int sourceId"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-energydistribution","title":"variable energyDistribution","text":"<pre><code>const std::optional&lt;EnergyDistributionDataVariant&gt; rayx::GenRays&lt; Acc &gt;::SourceState::energyDistribution;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-name","title":"variable name","text":"<pre><code>std::string rayx::GenRays&lt; Acc &gt;::SourceState::name;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-numrayssource","title":"variable numRaysSource","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::SourceState::numRaysSource;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-numrayssourceremaining","title":"variable numRaysSourceRemaining","text":"<pre><code>int rayx::GenRays&lt; Acc &gt;::SourceState::numRaysSourceRemaining;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-source","title":"variable source","text":"<pre><code>const SourceVariant rayx::GenRays&lt; Acc &gt;::SourceState::source;\n</code></pre>"},{"location":"rayxCore/structrayx_1_1GenRays_1_1SourceState/#variable-sourceid","title":"variable sourceId","text":"<pre><code>const int rayx::GenRays&lt; Acc &gt;::SourceState::sourceId;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1All/","title":"Struct rayx::ObjectMask::All","text":"<p>ClassList &gt; All</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1AllElements/","title":"Struct rayx::ObjectMask::AllElements","text":"<p>ClassList &gt; AllElements</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1AllSources/","title":"Struct rayx::ObjectMask::AllSources","text":"<p>ClassList &gt; AllSources</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1ByIndices/","title":"Struct rayx::ObjectMask::ByIndices","text":"<p>ClassList &gt; ByIndices</p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1ByIndices/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; int &gt; indices"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1ByIndices/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1ByIndices/#variable-indices","title":"variable indices","text":"<pre><code>std::vector&lt;int&gt; rayx::ObjectMask::ByIndices::indices;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/structrayx_1_1ObjectMask_1_1None/","title":"Struct rayx::ObjectMask::None","text":"<p>ClassList &gt; None</p> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/dir_8e65f0892f9f577e6bce143ffec865cf/","title":"Dir Intern","text":"<p>FileList &gt; Intern</p>"},{"location":"rayxCore/dir_8e65f0892f9f577e6bce143ffec865cf/#directories","title":"Directories","text":"Type Name dir rayx-core <p>The documentation for this class was generated from the following file <code>Intern/</code></p>"},{"location":"rayxCore/dir_9c5641573f5bc288e3f5d23894df6f8c/","title":"Dir Intern/rayx-core","text":"<p>FileList &gt; Intern &gt; rayx-core</p>"},{"location":"rayxCore/dir_9c5641573f5bc288e3f5d23894df6f8c/#directories","title":"Directories","text":"Type Name dir src <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/</code></p>"},{"location":"rayxCore/dir_d67825566018768a2928984140c8671c/","title":"Dir Intern/rayx-core/src","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src</p>"},{"location":"rayxCore/dir_d67825566018768a2928984140c8671c/#files","title":"Files","text":"Type Name file Angle.h file CanonicalizePath.h file Core.h file FileIO.h file ObjectMask.h file Random.h file RayAttrMask.h file Rays.h file Variant.h"},{"location":"rayxCore/dir_d67825566018768a2928984140c8671c/#directories","title":"Directories","text":"Type Name dir Beamline dir Debug dir Design dir Element dir Material dir Rml dir Shader dir Tracer dir Writer <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/</code></p>"},{"location":"rayxCore/Angle_8h/","title":"File Angle.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Angle.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Angle_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Angle_8h/#classes","title":"Classes","text":"Type Name struct Deg struct Rad <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Angle.h</code></p>"},{"location":"rayxCore/Angle_8h_source/","title":"File Angle.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Angle.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;glm.hpp&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nstruct Rad;\n\n// an angle in degrees.\nstruct RAYX_API Deg {\n    Deg() = default;\n    Deg(double d) : deg(d) {}\n\n    Rad toRad() const;\n\n    double deg;\n};\n\n// an angle in radians\nstruct RAYX_API Rad {\n    Rad() = default;\n    Rad(double r) : rad(r) {}\n\n    Deg toDeg() const;\n    double sin() const;\n    double cos() const;\n    double tan() const;\n\n    double rad;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/CanonicalizePath_8h/","title":"File CanonicalizePath.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; CanonicalizePath.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"FileIO.h\"</code></li> </ul>"},{"location":"rayxCore/CanonicalizePath_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/CanonicalizePath.h</code></p>"},{"location":"rayxCore/CanonicalizePath_8h_source/","title":"File CanonicalizePath.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; CanonicalizePath.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"FileIO.h\"\n\nnamespace rayx {\n\nstd::filesystem::path RAYX_API canonicalizeRepositoryPath(const std::filesystem::path&amp; relPath);\n\nstd::filesystem::path RAYX_API canonicalizeUserPath(const std::filesystem::path&amp; relPath);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Core_8h/","title":"File Core.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Core.h</p> <p>Go to the source code of this file</p>"},{"location":"rayxCore/Core_8h/#macros","title":"Macros","text":"Type Name define RAYX_API define RAYX_CONSTEXPR_ACC <code>constexpr</code> define RAYX_FN_ACC"},{"location":"rayxCore/Core_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Core_8h/#define-rayx_api","title":"define RAYX_API","text":"<pre><code>#define RAYX_API \n</code></pre> <p>Defining the RAYX_API macro, which helps with building the library (context based import/export of code). </p>"},{"location":"rayxCore/Core_8h/#define-rayx_constexpr_acc","title":"define RAYX_CONSTEXPR_ACC","text":"<pre><code>#define RAYX_CONSTEXPR_ACC `constexpr`\n</code></pre>"},{"location":"rayxCore/Core_8h/#define-rayx_fn_acc","title":"define RAYX_FN_ACC","text":"<pre><code>#define RAYX_FN_ACC \n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Core.h</code></p>"},{"location":"rayxCore/Core_8h_source/","title":"File Core.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Core.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#if defined(RAYX_PLATFORM_MSVC)  //  Microsoft\n#ifdef RAYX_BUILD_DLL\n#define RAYX_API __declspec(dllexport)\n#else\n#define RAYX_API __declspec(dllimport)\n#endif\n#elif defined(RAYX_PLATFORM_GCC)  //  GCC\n#ifdef RAYX_BUILD_DLL\n#define RAYX_API __attribute__((visibility(\"default\")))\n#else\n#define RAYX_API\n#endif\n#elif defined(RAYX_PLATFORM_CLANG)  //  Clang\n#ifdef RAYX_BUILD_DLL\n#define RAYX_API __attribute__((visibility(\"default\")))\n#else\n#define RAYX_API\n#endif\n#else  //  do nothing and hope for the best?\n#ifdef RAYX_BUILD_DLL\n#define RAYX_API\n#else\n#define RAYX_API\n#endif\n#endif\n\n#ifdef RAYX_BUILD_DLL\n#include &lt;alpaka/core/Common.hpp&gt;\n#define RAYX_FN_ACC ALPAKA_FN_ACC\n#else\n#define RAYX_FN_ACC\n#endif\n\n#if defined(RAYX_BUILD_DLL) &amp;&amp; defined(RAYX_CUDA_ENABLED)\n#define RAYX_CONSTEXPR_ACC constexpr __device__\n#else\n#define RAYX_CONSTEXPR_ACC constexpr\n#endif\n\n// make string comparison available for msvc compiler\n// not #if defined(_WIN32) || defined(_WIN64) because we have strncasecmp in mingw\n#ifdef _MSC_VER\n#define strncasecmp _strnicmp\n#define strcasecmp  _stricmp\n#endif\n</code></pre>"},{"location":"rayxCore/FileIO_8h/","title":"File FileIO.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; FileIO.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/FileIO_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/FileIO.h</code></p>"},{"location":"rayxCore/FileIO_8h_source/","title":"File FileIO.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; FileIO.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;optional&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\n// The readFile functions return {} if an error occured while opening the file.\n// We prefered this over an exception, as you typically forget to handle them.\nstd::optional&lt;std::vector&lt;uint8_t&gt;&gt; RAYX_API readFile(const std::string&amp; filename, const uint32_t count = 0);\n\n// The alignment of 32-bits is necessary for SPIR-V shader code.\n// See https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderModuleCreateInfo.html\nstd::optional&lt;std::vector&lt;uint32_t&gt;&gt; readFileAlign32(const std::string&amp; filename, const uint32_t count = 0);\n\nvoid RAYX_API writeFile(const std::vector&lt;uint8_t&gt;&amp; data, const std::string&amp; filename, const uint32_t count = 0);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_ed6f3ce0d94a0c810099b50a779e73a9/","title":"Dir Intern/rayx-core/src/Beamline","text":"<p>FileList &gt; Beamline</p>"},{"location":"rayxCore/dir_ed6f3ce0d94a0c810099b50a779e73a9/#files","title":"Files","text":"Type Name file Beamline.h file DatFile.h file Definitions.h file EnergyDistribution.h file Node.h file StringConversion.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/</code></p>"},{"location":"rayxCore/Beamline_8h/","title":"File Beamline.h","text":"<p>FileList &gt; Beamline &gt; Beamline.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Design/DesignElement.h\"</code></li> <li><code>#include \"Design/DesignSource.h\"</code></li> <li><code>#include \"Node.h\"</code></li> </ul>"},{"location":"rayxCore/Beamline_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Beamline_8h/#classes","title":"Classes","text":"Type Name class Group <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/Beamline.h</code></p>"},{"location":"rayxCore/Beamline_8h_source/","title":"File Beamline.h","text":"<p>File List &gt; Beamline &gt; Beamline.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;glm.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Design/DesignElement.h\"\n#include \"Design/DesignSource.h\"\n#include \"Node.h\"\n\nnamespace rayx {\n\nclass RAYX_API Group : public BeamlineNode {\n  public:\n    Group();\n    Group(std::string name);\n    ~Group() = default;\n\n    Group(const Group&amp;)            = delete;\n    Group&amp; operator=(const Group&amp;) = delete;\n\n    Group(Group&amp;&amp; other) noexcept;\n    Group&amp; operator=(Group&amp;&amp; other) noexcept;\n\n    bool isGroup() const override { return true; }\n\n    // Iterators\n    auto begin() { return m_children.begin(); }\n    auto end() { return m_children.end(); }\n    auto begin() const { return m_children.cbegin(); }\n    auto end() const { return m_children.cend(); }\n    auto cbegin() const { return m_children.cbegin(); }\n    auto cend() const { return m_children.cend(); }\n\n    void addChild(std::unique_ptr&lt;BeamlineNode&gt; child);\n\n    [[nodiscard]] std::unique_ptr&lt;BeamlineNode&gt; releaseNodeFromChildren(const BeamlineNode* node);\n    [[nodiscard]] std::unique_ptr&lt;BeamlineNode&gt; releaseNodeFromTree(const BeamlineNode* node);\n\n    size_t numElements() const;\n    size_t numSources() const;\n    size_t numObjects() const;\n    size_t numRayPaths() const;\n\n    // recursive search\n\n    const BeamlineNode* findNodeByName(const std::string&amp; name) const;\n    BeamlineNode* findNodeByName(const std::string&amp; name);\n\n    const Group* findGroupByName(const std::string&amp; name) const;\n    Group* findGroupByName(const std::string&amp; name);\n\n    const DesignSource* findSourceByName(const std::string&amp; name) const;\n    DesignSource* findSourceByName(const std::string&amp; name);\n\n    const DesignElement* findElementByName(const std::string&amp; name) const;\n    DesignElement* findElementByName(const std::string&amp; name);\n\n    const BeamlineNode* findNode(const std::function&lt;bool(const BeamlineNode&amp;)&gt;&amp; pred) const;\n    BeamlineNode* findNode(const std::function&lt;bool(const BeamlineNode&amp;)&gt;&amp; pred);\n\n    const Group* findGroup(const std::function&lt;bool(const Group&amp;)&gt;&amp; pred) const;\n    Group* findGroup(const std::function&lt;bool(const Group&amp;)&gt;&amp; pred);\n\n    const DesignSource* findSource(const std::function&lt;bool(const DesignSource&amp;)&gt;&amp; pred) const;\n    DesignSource* findSource(const std::function&lt;bool(const DesignSource&amp;)&gt;&amp; pred);\n\n    const DesignElement* findElement(const std::function&lt;bool(const DesignElement&amp;)&gt;&amp; pred) const;\n    DesignElement* findElement(const std::function&lt;bool(const DesignElement&amp;)&gt;&amp; pred);\n\n    // declarative fashion api\n\n    const BeamlineNode* operator[](size_t index) const override;\n    BeamlineNode* operator[](size_t index) override;\n\n    const BeamlineNode* operator[](const std::string&amp; name) const override;\n    BeamlineNode* operator[](const std::string&amp; name) override;\n\n    std::unique_ptr&lt;BeamlineNode&gt; clone() const override;\n\n    std::string getName() const override;\n    void setName(std::string name) override;\n\n    void ctraverse(const std::function&lt;bool(const BeamlineNode&amp;)&gt;&amp; callback) const;\n\n    void traverse(const std::function&lt;bool(BeamlineNode&amp;)&gt;&amp; callback);\n\n    // TODO: this should not be part of the API\n    MaterialTables calcMinimalMaterialTables() const;\n\n    // TODO: this should not be part of the API\n    std::vector&lt;OpticalElementAndTransform&gt; compileElements() const;\n\n    // TODO: why would we need this? ray-ui uses this function\n    static void accumulateLightSourcesWorldPositions(const Group&amp; group, const glm::dvec4&amp; parentPos, const glm::dmat4&amp; parentOri,\n                                                     std::vector&lt;glm::dvec4&gt;&amp; positions);\n\n    std::vector&lt;std::string&gt; getElementNames() const;\n    std::vector&lt;std::string&gt; getSourceNames() const;\n    std::vector&lt;std::string&gt; getObjectNames() const;\n\n    std::vector&lt;const DesignElement*&gt; getElements() const;\n    std::vector&lt;const DesignSource*&gt; getSources() const;\n\n    glm::dvec4 getPosition() const override { return m_position; }\n    void setPosition(const glm::dvec4&amp; pos) { m_position = pos; }\n\n    glm::dmat4 getOrientation() const override { return m_orientation; }\n    void setOrientation(const glm::dmat4&amp; orientation) { m_orientation = orientation; }\n\n    const std::vector&lt;std::unique_ptr&lt;BeamlineNode&gt;&gt;&amp; getChildren() const { return m_children; }\n\n    size_t findObjectIdByNode(const BeamlineNode* node) const;\n    const BeamlineNode* findNodeByObjectId(const size_t objectId) const;\n    BeamlineNode* findNodeByObjectId(const size_t objectId);\n\n  private:\n    // Position and orientation could in theory be put into one transform matrix but this follows the rml style\n    glm::dvec4 m_position    = glm::dvec4(0, 0, 0, 1);\n    glm::dmat4 m_orientation = glm::dmat4(1);\n    // m_children vec is not checked for dangling or nullptrs anywhere, changes to the Group interface/implementation are to be made with care\n    std::vector&lt;std::unique_ptr&lt;BeamlineNode&gt;&gt; m_children;\n    std::string m_name;\n};\n\nusing Beamline = Group;  // Conceptually, a Beamline is a Group\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DatFile_8h/","title":"File DatFile.h","text":"<p>FileList &gt; Beamline &gt; DatFile.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/DatFile_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DatFile_8h/#classes","title":"Classes","text":"Type Name struct DatEntry struct DatFile <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/DatFile.h</code></p>"},{"location":"rayxCore/DatFile_8h_source/","title":"File DatFile.h","text":"<p>File List &gt; Beamline &gt; DatFile.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\nstruct DatEntry {\n    double m_energy;\n    double m_weight;\n};\n\nstruct DatFile {\n    std::string m_title;\n    uint32_t m_lineCount;\n    double m_start;\n    double m_end;\n    double m_step;\n\n    double m_weightSum;\n\n    std::vector&lt;DatEntry&gt; m_Lines;\n\n    bool m_continuous;\n\n    static bool load(const std::filesystem::path&amp; filename, DatFile* out);\n\n    [[maybe_unused]] std::string dump();\n};\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Definitions_8h/","title":"File Definitions.h","text":"<p>FileList &gt; Beamline &gt; Definitions.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Debug/Debug.h\"</code></li> </ul>"},{"location":"rayxCore/Definitions_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/Definitions.h</code></p>"},{"location":"rayxCore/Definitions_8h_source/","title":"File Definitions.h","text":"<p>File List &gt; Beamline &gt; Definitions.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Debug/Debug.h\"\n\nnamespace rayx {\nenum class GratingMount { Deviation, Incidence };\nenum class ParaboloidType { Focussing, Collimate };\nenum class CurvatureType {\n    Plane,\n    Toroidal,\n    Spherical,\n    Cubic,\n    Cone,\n    Cylinder,\n    Ellipsoid,\n    Paraboloid,\n    Quadric,\n    RzpSphere\n};  // order is crucial for xml prser\nenum class BehaviourType { Mirror, Grating, Slit, Rzp, ImagePlane, Crystal, Foil };\nenum class FigureRotation { Yes, Plane, A11 };\n\n// the direction of a plane, either XY or XZ. This is only used in the parsing.\n// Inside of the shader, every plane-shaped object lies in its XZ plane.\n// Per default every element has DesignPlane::XZ, but ImagePlane and Slit have DesignPlane::XY.\n// Thus they need a bit of extra handling to convert them to the shaders XZ plane.\nenum class DesignPlane { XY, XZ };\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Beamline_2EnergyDistribution_8h/","title":"File EnergyDistribution.h","text":"<p>FileList &gt; Beamline &gt; EnergyDistribution.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"DatFile.h\"</code></li> </ul>"},{"location":"rayxCore/Beamline_2EnergyDistribution_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Beamline_2EnergyDistribution_8h/#classes","title":"Classes","text":"Type Name struct HardEdge struct SeparateEnergies If there is only one spike (i.e. m_numberOfEnergies = 1), then this spike is at <code>m_centerEnergy</code> . struct SoftEdge <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/EnergyDistribution.h</code></p>"},{"location":"rayxCore/Beamline_2EnergyDistribution_8h_source/","title":"File EnergyDistribution.h","text":"<p>File List &gt; Beamline &gt; EnergyDistribution.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;variant&gt;\n\n#include \"Core.h\"\n#include \"DatFile.h\"\n\nnamespace rayx {\n\nenum class SpreadType { HardEdge, SoftEdge, SeparateEnergies };    // default WhiteBand\nenum class EnergyDistributionType { File, Values, Total, Param };  // default ET_VALUES\n\nstruct RAYX_API HardEdge {\n    double m_centerEnergy;\n    double m_energySpread;\n\n    HardEdge(double centerEnergy, double energySpread) : m_centerEnergy(centerEnergy), m_energySpread(energySpread) {}\n};\n\nstruct RAYX_API SoftEdge {\n    double m_centerEnergy;\n    double m_sigma;\n\n    SoftEdge(double centerEnergy, double sigma) : m_centerEnergy(centerEnergy), m_sigma(sigma) {}\n};\n\n\n\nstruct RAYX_API SeparateEnergies {\n    double m_centerEnergy;\n    double m_energySpread;\n    int m_numberOfEnergies;\n\n    SeparateEnergies(double centerEnergy, double energySpread, int numberOfEnergies)\n        : m_centerEnergy(centerEnergy), m_energySpread(energySpread), m_numberOfEnergies(numberOfEnergies) {}\n};\n\nusing EnergyDistributionVariant = std::variant&lt;DatFile, HardEdge, SoftEdge, SeparateEnergies&gt;;\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Node_8h/","title":"File Node.h","text":"<p>FileList &gt; Beamline &gt; Node.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Node_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Node_8h/#classes","title":"Classes","text":"Type Name class BeamlineNode Base class for all nodes in the beamline hierarchy (scene/model graph). <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/Node.h</code></p>"},{"location":"rayxCore/Node_8h_source/","title":"File Node.h","text":"<p>File List &gt; Beamline &gt; Node.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nclass Group;\nclass DesignSource;\nclass DesignElement;\n\nclass RAYX_API BeamlineNode {\n    friend class Group;  // Needed so group can access m_parent for BeamlineNodes\n  public:\n    virtual ~BeamlineNode() = default;\n\n    virtual std::unique_ptr&lt;BeamlineNode&gt; clone() const = 0;\n\n    virtual bool isGroup() const { return false; }    // Overridden in Group\n    virtual bool isElement() const { return false; }  // Overridden in Element\n    virtual bool isSource() const { return false; }   // Overridden in Source\n\n    virtual glm::dvec4 getPosition() const = 0;\n\n    virtual glm::dmat4 getOrientation() const = 0;\n\n    glm::dvec4 getWorldPosition() const;\n\n    glm::dmat4 getWorldOrientation() const;\n\n    virtual std::string getName() const    = 0;\n    virtual void setName(std::string name) = 0;\n\n    bool hasParent() const { return m_parent != nullptr; }\n\n    const BeamlineNode* getParent() const { return m_parent; }\n    BeamlineNode* getParent() { return m_parent; }\n\n    const BeamlineNode* getRoot() const;\n    BeamlineNode* getRoot();\n\n    int getObjectId() const;\n\n    // declarative fashion api\n    // the index operators are declared in BeamlineNode but only work when the BeamlineNode is a group. defined here so they can be called without\n    // casting an object to Group\n\n    virtual const BeamlineNode* operator[](size_t index) const;\n    virtual BeamlineNode* operator[](size_t index);\n\n    virtual const BeamlineNode* operator[](const std::string&amp; name) const;\n    virtual BeamlineNode* operator[](const std::string&amp; name);\n\n    const Group* asGroup() const;\n    Group* asGroup();\n\n    const DesignSource* asSource() const;\n    DesignSource* asSource();\n\n    const DesignElement* asElement() const;\n    DesignElement* asElement();\n\n  private:\n    BeamlineNode* m_parent = nullptr;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/StringConversion_8h/","title":"File StringConversion.h","text":"<p>FileList &gt; Beamline &gt; StringConversion.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"Shader/LightSources/LightSource.h\"</code></li> <li><code>#include \"Material/materials.xmacro\"</code></li> </ul>"},{"location":"rayxCore/StringConversion_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/StringConversion_8h/#macros","title":"Macros","text":"Type Name define X (e, z, a, rho) <code>{Material::e, #e},</code> define X (e, z, a, rho) <code>{Material::e, #e},</code>"},{"location":"rayxCore/StringConversion_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/StringConversion_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    e,\n    z,\n    a,\n    rho\n) `{Material::e, #e},`\n</code></pre>"},{"location":"rayxCore/StringConversion_8h/#define-x_1","title":"define X","text":"<pre><code>#define X (\n    e,\n    z,\n    a,\n    rho\n) `{Material::e, #e},`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Beamline/StringConversion.h</code></p>"},{"location":"rayxCore/StringConversion_8h_source/","title":"File StringConversion.h","text":"<p>File List &gt; Beamline &gt; StringConversion.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n#include \"Shader/LightSources/LightSource.h\"\n\nnamespace rayx {\n\n// String conversion functions\n\n// SpreadType conversion\nconst std::map&lt;SpreadType, std::string&gt; SpreadTypeToString = {\n    {SpreadType::HardEdge, \"HardEdge\"}, {SpreadType::SoftEdge, \"SoftEdge\"}, {SpreadType::SeparateEnergies, \"SeparateEnergies\"}};\nconst std::map&lt;std::string, SpreadType&gt; StringToSpreadType = {\n    {\"HardEdge\", SpreadType::HardEdge}, {\"SoftEdge\", SpreadType::SoftEdge}, {\"SeparateEnergies\", SpreadType::SeparateEnergies}};\n\n// EnergyDistributionType conversion\nconst std::map&lt;EnergyDistributionType, std::string&gt; EnergyDistributionTypeToString = {{EnergyDistributionType::File, \"File\"},\n                                                                                      {EnergyDistributionType::Values, \"Values\"},\n                                                                                      {EnergyDistributionType::Total, \"Total\"},\n                                                                                      {EnergyDistributionType::Param, \"Param\"}};\nconst std::map&lt;std::string, EnergyDistributionType&gt; StringToEnergyDistributionType = {{\"File\", EnergyDistributionType::File},\n                                                                                      {\"Values\", EnergyDistributionType::Values},\n                                                                                      {\"Total\", EnergyDistributionType::Total},\n                                                                                      {\"Param\", EnergyDistributionType::Param}};\n\n// SourceDist conversion\nconst std::map&lt;SourceDist, std::string&gt; SourceDistToString = {\n    {SourceDist::Uniform, \"Uniform\"}, {SourceDist::Gaussian, \"Gaussian\"}, {SourceDist::Thirds, \"Thirds\"}, {SourceDist::Circle, \"Circle\"}};\nconst std::map&lt;std::string, SourceDist&gt; StringToSourceDist = {\n    {\"Uniform\", SourceDist::Uniform}, {\"Gaussian\", SourceDist::Gaussian}, {\"Thirds\", SourceDist::Thirds}, {\"Circle\", SourceDist::Circle}};\n\n// ElectronEnergyOrientation conversion\nconst std::map&lt;ElectronEnergyOrientation, std::string&gt; ElectronEnergyOrientationToString = {\n    {ElectronEnergyOrientation::Clockwise, \"Clockwise\"}, {ElectronEnergyOrientation::Counterclockwise, \"Counterclockwise\"}};\nconst std::map&lt;std::string, ElectronEnergyOrientation&gt; StringToElectronEnergyOrientation = {\n    {\"Clockwise\", ElectronEnergyOrientation::Clockwise}, {\"Counterclockwise\", ElectronEnergyOrientation::Counterclockwise}};\n\n// EnergySpreadUnit conversion\nconst std::map&lt;EnergySpreadUnit, std::string&gt; EnergySpreadUnitToString = {{EnergySpreadUnit::EU_PERCENT, \"Percent\"}, {EnergySpreadUnit::EU_eV, \"eV\"}};\nconst std::map&lt;std::string, EnergySpreadUnit&gt; StringToEnergySpreadUnit = {{\"Percent\", EnergySpreadUnit::EU_PERCENT}, {\"eV\", EnergySpreadUnit::EU_eV}};\n\n// RZPType conversion\nconst std::map&lt;RZPType, std::string&gt; RZPTypeToString = {{RZPType::Elliptical, \"Elliptical\"}, {RZPType::Meriodional, \"Meriodional\"}};\nconst std::map&lt;std::string, RZPType&gt; StringToRZPType = {{\"Elliptical\", RZPType::Elliptical}, {\"Meriodional\", RZPType::Meriodional}};\n\n// CentralBeamstop conversion\nconst std::map&lt;CentralBeamstop, std::string&gt; CentralBeamstopToString = {\n    {CentralBeamstop::None, \"None\"}, {CentralBeamstop::Rectangle, \"Rectangle\"}, {CentralBeamstop::Elliptical, \"Elliptical\"}};\nconst std::map&lt;std::string, CentralBeamstop&gt; StringToCentralBeamstop = {\n    {\"None\", CentralBeamstop::None}, {\"Rectangle\", CentralBeamstop::Rectangle}, {\"Elliptical\", CentralBeamstop::Elliptical}};\n\n// GratingMount conversion\nconst std::map&lt;GratingMount, std::string&gt; GratingMountToString = {{GratingMount::Deviation, \"Deviation\"}, {GratingMount::Incidence, \"Incidence\"}};\nconst std::map&lt;std::string, GratingMount&gt; StringToGratingMount = {{\"Deviation\", GratingMount::Deviation}, {\"Incidence\", GratingMount::Incidence}};\n\n// ParaboloidType conversion\nconst std::map&lt;ParaboloidType, std::string&gt; ParaboloidTypeToString = {{ParaboloidType::Focussing, \"Focussing\"},\n                                                                      {ParaboloidType::Collimate, \"Collimate\"}};\nconst std::map&lt;std::string, ParaboloidType&gt; StringToParaboloidType = {{\"Focussing\", ParaboloidType::Focussing},\n                                                                      {\"Collimate\", ParaboloidType::Collimate}};\n\n// CurvatureType conversion\nconst std::map&lt;CurvatureType, std::string&gt; CurvatureTypeToString = {\n    {CurvatureType::Plane, \"Plane\"},         {CurvatureType::Toroidal, \"Toroidal\"},\n    {CurvatureType::Spherical, \"Spherical\"}, {CurvatureType::Cubic, \"Cubic\"},\n    {CurvatureType::Cone, \"Cone\"},           {CurvatureType::Cylinder, \"Cylinder\"},\n    {CurvatureType::Ellipsoid, \"Ellipsoid\"}, {CurvatureType::Paraboloid, \"Paraboloid\"},\n    {CurvatureType::Quadric, \"Quadric\"},     {CurvatureType::RzpSphere, \"RzpSphere\"}};\nconst std::map&lt;std::string, CurvatureType&gt; StringToCurvatureType = {\n    {\"Plane\", CurvatureType::Plane},         {\"Toroidal\", CurvatureType::Toroidal},\n    {\"Spherical\", CurvatureType::Spherical}, {\"Cubic\", CurvatureType::Cubic},\n    {\"Cone\", CurvatureType::Cone},           {\"Cylinder\", CurvatureType::Cylinder},\n    {\"Ellipsoid\", CurvatureType::Ellipsoid}, {\"Paraboloid\", CurvatureType::Paraboloid},\n    {\"Quadric\", CurvatureType::Quadric},     {\"RzpSphere\", CurvatureType::RzpSphere}};\n\n// BehaviourType conversion\nconst std::map&lt;BehaviourType, std::string&gt; BehaviourTypeToString = {{BehaviourType::Mirror, \"Mirror\"},\n                                                                    {BehaviourType::Grating, \"Grating\"},\n                                                                    {BehaviourType::Slit, \"Slit\"},\n                                                                    {BehaviourType::Rzp, \"Rzp\"},\n                                                                    {BehaviourType::ImagePlane, \"ImagePlane\"}};\nconst std::map&lt;std::string, BehaviourType&gt; StringToBehaviourType = {{\"Mirror\", BehaviourType::Mirror},\n                                                                    {\"Grating\", BehaviourType::Grating},\n                                                                    {\"Slit\", BehaviourType::Slit},\n                                                                    {\"Rzp\", BehaviourType::Rzp},\n                                                                    {\"ImagePlane\", BehaviourType::ImagePlane}};\n// FigureRotation conversion\nconst std::map&lt;FigureRotation, std::string&gt; FigureRotationToString = {\n    {FigureRotation::Yes, \"Yes\"}, {FigureRotation::Plane, \"Plane\"}, {FigureRotation::A11, \"A11\"}};\nconst std::map&lt;std::string, FigureRotation&gt; StringToFigureRotation = {\n    {\"Yes\", FigureRotation::Yes}, {\"Plane\", FigureRotation::Plane}, {\"A11\", FigureRotation::A11}};\n\n// SigmaType conversion\nconst std::map&lt;SigmaType, std::string&gt; SigmaTypeToString = {{SigmaType::ST_STANDARD, \"Standard\"}, {SigmaType::ST_ACCURATE, \"Accurate\"}};\nconst std::map&lt;std::string, SigmaType&gt; StringToSigmaType = {{\"Standard\", SigmaType::ST_STANDARD}, {\"Accurate\", SigmaType::ST_ACCURATE}};\n\n// Material conversion\nconst std::map&lt;Material, std::string&gt; MaterialToString = {\n    {Material::REFLECTIVE, \"REFLECTIVE\"},\n    {Material::VACUUM, \"VACUUM\"},\n\n// Add other materials here as needed\n#define X(e, z, a, rho) {Material::e, #e},\n#include \"Material/materials.xmacro\"\n#undef X\n};\nconst std::map&lt;std::string, Material&gt; StringToMaterial = {\n    {\"REFLECTIVE\", Material::REFLECTIVE},\n    {\"VACUUM\", Material::VACUUM},\n// Add other materials here as needed\n#define X(e, z, a, rho) {#e, Material::e},\n#include \"Material/materials.xmacro\"\n#undef X\n};\n\n// ElementType conversion\nconst std::map&lt;ElementType, std::string&gt; ElementTypeToString = {{ElementType::CircleSource, \"Circle Source\"},\n                                                                {ElementType::CylinderMirror, \"Cylinder\"},\n                                                                {ElementType::ImagePlane, \"ImagePlane\"},\n                                                                {ElementType::MatrixSource, \"Matrix Source\"},\n                                                                {ElementType::ParaboloidMirror, \"Paraboloid\"},\n                                                                {ElementType::PlaneGrating, \"Plane Grating\"},\n                                                                {ElementType::PointSource, \"Point Source\"},\n                                                                {ElementType::ReflectionZoneplate, \"Reflection Zoneplate\"},\n                                                                {ElementType::SimpleUndulatorSource, \"Simple Undulator\"},\n                                                                {ElementType::Slit, \"Slit\"},\n                                                                {ElementType::Sphere, \"Sphere\"},\n                                                                {ElementType::ConeMirror, \"Cone\"},\n                                                                {ElementType::ExpertsMirror, \"Experts Optics\"},\n                                                                {ElementType::PlaneMirror, \"Plane Mirror\"},\n                                                                {ElementType::SphereGrating, \"Spherical Grating\"},\n                                                                {ElementType::SphereMirror, \"Sphere Mirror\"},\n                                                                {ElementType::ToroidMirror, \"Toroid\"},\n                                                                {ElementType::ToroidGrating, \"Toroidal Grating\"},\n                                                                {ElementType::DipoleSource, \"Dipole Source\"},\n                                                                {ElementType::PixelSource, \"Pixel Source\"},\n                                                                {ElementType::EllipsoidMirror, \"Ellipsoid\"},\n                                                                {ElementType::Crystal, \"Crystal\"},\n                                                                {ElementType::Foil, \"Foil\"}};\nconst std::map&lt;std::string, ElementType&gt; StringToElementType = {{\"Circle Source\", ElementType::CircleSource},\n                                                                {\"Cylinder\", ElementType::CylinderMirror},\n                                                                {\"ImagePlane\", ElementType::ImagePlane},\n                                                                {\"Matrix Source\", ElementType::MatrixSource},\n                                                                {\"Paraboloid\", ElementType::ParaboloidMirror},\n                                                                {\"Plane Grating\", ElementType::PlaneGrating},\n                                                                {\"Point Source\", ElementType::PointSource},\n                                                                {\"Reflection Zoneplate\", ElementType::ReflectionZoneplate},\n                                                                {\"Simple Undulator\", ElementType::SimpleUndulatorSource},\n                                                                {\"Slit\", ElementType::Slit},\n                                                                {\"Sphere\", ElementType::Sphere},\n                                                                {\"Cone\", ElementType::ConeMirror},\n                                                                {\"Experts Optics\", ElementType::ExpertsMirror},\n                                                                {\"Plane Mirror\", ElementType::PlaneMirror},\n                                                                {\"Spherical Grating\", ElementType::SphereGrating},\n                                                                {\"Sphere Mirror\", ElementType::SphereMirror},\n                                                                {\"Toroid\", ElementType::ToroidMirror},\n                                                                {\"Toroidal Grating\", ElementType::ToroidGrating},\n                                                                {\"Dipole Source\", ElementType::DipoleSource},\n                                                                {\"Dipole\", ElementType::DipoleSource},  // legacy rml\n                                                                {\"Pixel Source\", ElementType::PixelSource},\n                                                                {\"Ellipsoid\", ElementType::EllipsoidMirror},\n                                                                {\"Crystal\", ElementType::Crystal},\n                                                                {\"Foil\", ElementType::Foil}};\n\nconst std::map&lt;std::string, EventType&gt; StringToEventType = {\n    {\"Uninitialized\", EventType::Uninitialized}, {\"Emitted\", EventType::Emitted},   {\"HitElement\", EventType::HitElement},\n    {\"FatalError\", EventType::FatalError},       {\"Absorbed\", EventType::Absorbed}, {\"BeyondHorizon\", EventType::BeyondHorizon},\n    {\"TooManyEvents\", EventType::TooManyEvents},\n};\nconst std::map&lt;EventType, std::string&gt; EventTypeToString = {\n    {EventType::Uninitialized, \"Uninitialized\"}, {EventType::Emitted, \"Emitted\"},   {EventType::HitElement, \"HitElement\"},\n    {EventType::FatalError, \"FatalError\"},       {EventType::Absorbed, \"Absorbed\"}, {EventType::BeyondHorizon, \"BeyondHorizon\"},\n    {EventType::TooManyEvents, \"TooManyEvents\"},\n};\n\nconst std::map&lt;CutoutType, std::string&gt; CutoutTypeToString = {\n    {CutoutType::Unlimited, \"Unlimited\"}, {CutoutType::Rect, \"Rect\"}, {CutoutType::Elliptical, \"Elliptical\"}, {CutoutType::Trapezoid, \"Trapezoid\"}};\nconst std::map&lt;std::string, CutoutType&gt; StringToCutoutType = {\n    {\"Unlimited\", CutoutType::Unlimited}, {\"Rect\", CutoutType::Rect}, {\"Elliptical\", CutoutType::Elliptical}, {\"Trapezoid\", CutoutType::Trapezoid}};\n\n// Generic helper for all enums\ntemplate &lt;typename Enum&gt;\nstd::ostream&amp; streamEnum(std::ostream&amp; os, const Enum value, const std::map&lt;Enum, std::string&gt;&amp; toStringMap) {\n    if (auto it = toStringMap.find(value); it != toStringMap.end()) {\n        os &lt;&lt; it-&gt;second;\n    } else {\n        os &lt;&lt; \"&lt;unknown&gt;\";\n    }\n    return os;\n}\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SpreadType v) { return streamEnum(os, v, SpreadTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const EnergyDistributionType v) { return streamEnum(os, v, EnergyDistributionTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SourceDist v) { return streamEnum(os, v, SourceDistToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ElectronEnergyOrientation v) { return streamEnum(os, v, ElectronEnergyOrientationToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const EnergySpreadUnit v) { return streamEnum(os, v, EnergySpreadUnitToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const RZPType v) { return streamEnum(os, v, RZPTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CentralBeamstop v) { return streamEnum(os, v, CentralBeamstopToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const GratingMount v) { return streamEnum(os, v, GratingMountToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParaboloidType v) { return streamEnum(os, v, ParaboloidTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CurvatureType v) { return streamEnum(os, v, CurvatureTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const BehaviourType v) { return streamEnum(os, v, BehaviourTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const FigureRotation v) { return streamEnum(os, v, FigureRotationToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SigmaType v) { return streamEnum(os, v, SigmaTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Material v) { return streamEnum(os, v, MaterialToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ElementType v) { return streamEnum(os, v, ElementTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const EventType v) { return streamEnum(os, v, EventTypeToString); }\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CutoutType v) { return streamEnum(os, v, CutoutTypeToString); }\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_eb5348a1178842cfc1221d70dc43cea9/","title":"Dir Intern/rayx-core/src/Debug","text":"<p>FileList &gt; Debug</p>"},{"location":"rayxCore/dir_eb5348a1178842cfc1221d70dc43cea9/#files","title":"Files","text":"Type Name file Debug.h file Instrumentor.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/</code></p>"},{"location":"rayxCore/Debug_8h/","title":"File Debug.h","text":"<p>FileList &gt; Debug &gt; Debug.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Rays.h\"</code></li> <li><code>#include \"Shader/Ray.h\"</code></li> </ul>"},{"location":"rayxCore/Debug_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Debug_8h/#classes","title":"Classes","text":"Type Name struct Exit struct IgnoreLog struct Log struct Verb struct Warn"},{"location":"rayxCore/Debug_8h/#macros","title":"Macros","text":"Type Name define RAYX_DBG (C) <code>rayx::dbg(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_, #C, rayx::formatAsVec(C))</code> define RAYX_DEBUG (x) <code>/* multi line expression */</code>For quick debugging prints, this file further exposes RAYX_DBG(x). define RAYX_D_ERR <code>[**rayx::IgnoreLog**](structrayx_1_1IgnoreLog.md)()</code> define RAYX_D_LOG <code>[**rayx::IgnoreLog**](structrayx_1_1IgnoreLog.md)()</code> define RAYX_D_VERB <code>[**rayx::IgnoreLog**](structrayx_1_1IgnoreLog.md)()</code> define RAYX_D_WARN <code>[**rayx::IgnoreLog**](structrayx_1_1IgnoreLog.md)()</code> define RAYX_EXIT <code>[**rayx::Exit**](structrayx_1_1Exit.md)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_)</code> define RAYX_LOG <code>[**rayx::Log**](structrayx_1_1Log.md)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_)</code> define RAYX_VERB <code>[**rayx::Verb**](structrayx_1_1Verb.md)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_)</code> define RAYX_WARN <code>[**rayx::Warn**](structrayx_1_1Warn.md)(\\_\\_FILE\\_\\_, \\_\\_LINE\\_\\_)</code> define STRING (s) <code>#s</code> define X (type, name, flag) <code>insert(formatAsVec(rays.name));</code>"},{"location":"rayxCore/Debug_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Debug_8h/#define-rayx_dbg","title":"define RAYX_DBG","text":"<pre><code>#define RAYX_DBG (\n    C\n) `rayx::dbg(__FILE__, __LINE__, #C, rayx::formatAsVec(C))`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_debug","title":"define RAYX_DEBUG","text":"<p>For quick debugging prints, this file further exposes RAYX_DBG(x). <pre><code>#define RAYX_DEBUG (\n    x\n) `/* multi line expression */`\n</code></pre></p> <p>This file mostly exposes the RAYX_LOG, RAYX_VERB, RAYX_WARN and RAYX_EXIT macros. We mostly use these macros instead of std::cout / std::cerr for convenience reasons. These macros automatically generate a newline at the end, and also print file and line number from where the print originated. RAYX_LOG, RAYX_VERB prints to std::cout, whereas RAYX_WARN and RAYX_EXIT are printed in red and go to std::cerr. RAYX_VERB is used for \"verbose\" prints, they can be activated and deactivated using the setDebugVerbose function. Finally RAYX_EXIT is to be used for fatal errors, calling it will automatically terminate the program by calling the configurable <code>error_fn</code> defined below.</p> <p>Each of these variants also has a \"debug-only\" variant, that gets deactivated in the release mode. The \"debug-only\" variant is prefixed by \"RAYX_D_\" instead of \"RAYX_\". For example the \"debug-only\" RAYX_LOG would be RAYX_D_LOG. </p>"},{"location":"rayxCore/Debug_8h/#define-rayx_d_err","title":"define RAYX_D_ERR","text":"<pre><code>#define RAYX_D_ERR `rayx::IgnoreLog ()`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_d_log","title":"define RAYX_D_LOG","text":"<pre><code>#define RAYX_D_LOG `rayx::IgnoreLog ()`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_d_verb","title":"define RAYX_D_VERB","text":"<pre><code>#define RAYX_D_VERB `rayx::IgnoreLog ()`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_d_warn","title":"define RAYX_D_WARN","text":"<pre><code>#define RAYX_D_WARN `rayx::IgnoreLog ()`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_exit","title":"define RAYX_EXIT","text":"<pre><code>#define RAYX_EXIT `rayx::Exit (__FILE__, __LINE__)`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_log","title":"define RAYX_LOG","text":"<pre><code>#define RAYX_LOG `rayx::Log (__FILE__, __LINE__)`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_verb","title":"define RAYX_VERB","text":"<pre><code>#define RAYX_VERB `rayx::Verb (__FILE__, __LINE__)`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-rayx_warn","title":"define RAYX_WARN","text":"<pre><code>#define RAYX_WARN `rayx::Warn (__FILE__, __LINE__)`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-string","title":"define STRING","text":"<pre><code>#define STRING (\n    s\n) `#s`\n</code></pre>"},{"location":"rayxCore/Debug_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `insert(formatAsVec(rays.name));`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Debug.h</code></p>"},{"location":"rayxCore/Debug_8h_source/","title":"File Debug.h","text":"<p>File List &gt; Debug &gt; Debug.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n\n\n\n// TODO: this file has the downside, that it defines ostream operators and formatToVec for specific types. This means, that files that define these\n// types cannot include this file, due to circular dependencies. In order to improve this, the ostream operators and formatToVec functions should be\n// moved to the files that define these types.\n\n#include &lt;array&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// This include is necessary, as Debug implements a special formatting for Ray.\n#include \"Rays.h\"\n#include \"Shader/Ray.h\"\n\n// Debug only code; use it as: DEBUG(&lt;statement&gt;);\n#ifdef RAYX_DEBUG_MODE\n#define RAYX_DEBUG(x) (x)\n#else\n#define RAYX_DEBUG(x) \\\n    do {              \\\n    } while (0)\n#endif\n\n#define STRING(s) #s\n\nnamespace rayx {\n\n// OSTREAM CONVERSION\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const complex::Complex&amp; c) { return os &lt;&lt; \"{\" &lt;&lt; c.real() &lt;&lt; \", \" &lt;&lt; c.imag() &lt;&lt; \"}\"; }\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const glm::tvec2&lt;T&gt;&amp; v) {\n    return os &lt;&lt; \"{\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \"}\";\n}\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const glm::tvec3&lt;T&gt;&amp; v) {\n    return os &lt;&lt; \"{\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \"}\";\n}\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const glm::tvec4&lt;T&gt;&amp; v) {\n    return os &lt;&lt; \"{\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \", \" &lt;&lt; v.w &lt;&lt; \"}\";\n}\n\n// LOGGING SYSTEM\n\n// activates / deactivates the printing of RAYX_VERB \"verbose\" prints.\nvoid RAYX_API setDebugVerbose(bool);\n\n// reads the \"verbose\" flag.\nbool RAYX_API getDebugVerbose();\n\n// The implementation of RAYX_LOG\nstruct RAYX_API Log {\n    Log(std::string filename, int line);\n    ~Log();\n\n    template &lt;typename T&gt;\n    Log&amp; operator&lt;&lt;(T t) {\n        std::cout &lt;&lt; t;\n        return *this;\n    }\n};\n\n// The implementation of RAYX_WARN\nstruct RAYX_API Warn {\n    Warn(std::string filename, int line);\n\n    ~Warn();\n\n    template &lt;typename T&gt;\n    Warn&amp; operator&lt;&lt;(T t) {\n        std::cerr &lt;&lt; t;\n        return *this;\n    }\n};\n\n// The implementation of RAYX_EXIT\nstruct RAYX_API Exit {\n    std::string filename;\n    int line;\n\n    Exit(const std::string&amp; filename, int line);\n\n    ~Exit();\n\n    template &lt;typename T&gt;\n    Exit&amp; operator&lt;&lt;(T t) {\n        std::cerr &lt;&lt; t;\n        return *this;\n    }\n};\n\n// The implementation of RAYX_VERB\nstruct RAYX_API Verb {\n    Verb(std::string filename, int line);\n    ~Verb();\n\n    template &lt;typename T&gt;\n    Verb&amp; operator&lt;&lt;(T t) {\n        if (getDebugVerbose()) { std::cout &lt;&lt; t; }\n        return *this;\n    }\n};\n\n// An empty implementation used in release when using \"debug-only\" prints like RAYX_D_LOG.\nstruct RAYX_API IgnoreLog{template &lt;typename T&gt; IgnoreLog &amp; operator&lt;&lt;(T){return *this;\n}  // namespace rayx\n}\n;\n\n// the function to be called after RAYX_EXIT happens.\n// normally exit(1), but in the test suite it's ADD_FAILURE.\nextern void RAYX_API (*error_fn)();\n\n// Defines the actual RAYX logging macros using the structs defined above.\n// The __FILE__ and __LINE__ macros contain the current filename and linenumber.\n// They are defined for us by c++ https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html\n#define RAYX_LOG  rayx::Log(__FILE__, __LINE__)\n#define RAYX_WARN rayx::Warn(__FILE__, __LINE__)\n#define RAYX_EXIT rayx::Exit(__FILE__, __LINE__)\n#define RAYX_VERB rayx::Verb(__FILE__, __LINE__)\n\n#ifdef RAYX_DEBUG_MODE\n// In debug mode, RAYX_D_LOG is just the same as RAYX_LOG.\n#define RAYX_D_LOG  RAYX_LOG\n#define RAYX_D_WARN RAYX_WARN\n#define RAYX_D_ERR  RAYX_EXIT\n#define RAYX_D_VERB RAYX_VERB\n\n#else\n// In release mode, RAYX_D_LOG instead calls the IgnoreLog, hence discarding the print.\n#define RAYX_D_LOG  rayx::IgnoreLog()\n#define RAYX_D_WARN rayx::IgnoreLog()\n#define RAYX_D_ERR  rayx::IgnoreLog()\n#define RAYX_D_VERB rayx::IgnoreLog()\n#endif\n\n// COLLECTION DEBUGGING SYSTEM\n\n/*\n *\n * In the following we define\n * RAYX_DBG: prints collection to RAYX_LOG for debugging\n *\n * example usage:\n * RAYX_DBG(orientation);\n * RAYX_DBG(position);\n * */\n\n// catch any unimplemented usage of formatAsVec\ntemplate &lt;typename T&gt;\ninline std::vector&lt;double&gt; formatAsVec(T) {\n    // abort compilation and print type T\n    [[maybe_unused]] typedef typename T::something_made_up X;\n    return {};\n}\n\ninline std::vector&lt;double&gt; formatAsVec(int arg) { return {static_cast&lt;double&gt;(arg)}; }\ninline std::vector&lt;double&gt; formatAsVec(RandCounter arg) { return {static_cast&lt;double&gt;(arg)}; }\ninline std::vector&lt;double&gt; formatAsVec(EventType arg) { return {static_cast&lt;double&gt;(arg)}; }\ninline std::vector&lt;double&gt; formatAsVec(double arg) { return {arg}; }\ninline std::vector&lt;double&gt; formatAsVec(complex::Complex arg) { return {arg.real(), arg.imag()}; }\n\ntemplate &lt;int N, int M, typename T&gt;\ninline std::vector&lt;double&gt; formatAsVec(const glm::mat&lt;N, M, T&gt; arg) {\n    std::vector&lt;double&gt; out;\n    for (size_t i = 0; i &lt; N * M; i++) {\n        auto data = formatAsVec(arg[i / N][i % N]);\n        out.insert(out.end(), data.begin(), data.end());\n    }\n    return out;\n}\n\ntemplate &lt;int N, typename T&gt;\ninline std::vector&lt;double&gt; formatAsVec(const glm::vec&lt;N, T&gt; arg) {\n    std::vector&lt;double&gt; out;\n    for (size_t i = 0; i &lt; N; i++) {\n        auto data = formatAsVec(arg[i]);\n        out.insert(out.end(), data.begin(), data.end());\n    }\n    return out;\n}\n\ntemplate &lt;size_t N, typename T&gt;\ninline std::vector&lt;double&gt; formatAsVec(const std::array&lt;T, N&gt; arg) {\n    std::vector&lt;double&gt; out;\n    for (size_t i = 0; i &lt; N; i++) {\n        auto data = formatAsVec(arg[i]);\n        out.insert(out.end(), data.begin(), data.end());\n    }\n    return out;\n}\n\ntemplate &lt;typename T&gt;\ninline std::vector&lt;double&gt; formatAsVec(const std::vector&lt;T&gt; arg) {\n    std::vector&lt;double&gt; out;\n    for (size_t i = 0; i &lt; arg.size(); i++) {\n        auto data = formatAsVec(arg[i]);\n        out.insert(out.end(), data.begin(), data.end());\n    }\n    return out;\n}\n\ntemplate &lt;&gt;\ninline std::vector&lt;double&gt; formatAsVec&lt;double&gt;(const std::vector&lt;double&gt; arg) {\n    return arg;\n}\n\ninline std::vector&lt;double&gt; formatAsVec(const Rays&amp; rays) {\n    std::vector&lt;double&gt; out;\n    auto insert = [&amp;out](const std::vector&lt;double&gt;&amp; v) { out.insert(out.end(), v.begin(), v.end()); };\n\n#define X(type, name, flag) insert(formatAsVec(rays.name));\n\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n    return out;\n}\n\nvoid dbg(const std::string&amp; filename, int line, std::string name, std::vector&lt;double&gt; v);\n\n#define RAYX_DBG(C) rayx::dbg(__FILE__, __LINE__, #C, rayx::formatAsVec(C))\n\n}  // namespace RAYX\n</code></pre>"},{"location":"rayxCore/Instrumentor_8h/","title":"File Instrumentor.h","text":"<p>FileList &gt; Debug &gt; Instrumentor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Instrumentor_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Instrumentor_8h/#classes","title":"Classes","text":"Type Name class InstrumentationTimer"},{"location":"rayxCore/Instrumentor_8h/#macros","title":"Macros","text":"Type Name define RAYX_PROFILE_FUNCTION () <code>RAYX\\_PROFILE\\_SCOPE(\\_\\_PRETTY\\_FUNCTION\\_\\_)</code> define RAYX_PROFILE_FUNCTION_STDOUT () <code>RAYX\\_PROFILE\\_SCOPE\\_STDOUT(\\_\\_func\\_\\_)</code> define RAYX_PROFILE_SCOPE (name) <code>[**::rayx::InstrumentationTimer**](classrayx_1_1InstrumentationTimer.md) timer##\\_\\_LINE\\_\\_(name, false)</code> define RAYX_PROFILE_SCOPE_STDOUT (name) <code>[**::rayx::InstrumentationTimer**](classrayx_1_1InstrumentationTimer.md) timer##\\_\\_LINE\\_\\_(name, true)</code> define __PRETTY_FUNCTION__ <code>\\_\\_FUNCSIG\\_\\_</code>"},{"location":"rayxCore/Instrumentor_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Instrumentor_8h/#define-rayx_profile_function","title":"define RAYX_PROFILE_FUNCTION","text":"<pre><code>#define RAYX_PROFILE_FUNCTION (\n\n) `RAYX_PROFILE_SCOPE(__PRETTY_FUNCTION__)`\n</code></pre>"},{"location":"rayxCore/Instrumentor_8h/#define-rayx_profile_function_stdout","title":"define RAYX_PROFILE_FUNCTION_STDOUT","text":"<pre><code>#define RAYX_PROFILE_FUNCTION_STDOUT (\n\n) `RAYX_PROFILE_SCOPE_STDOUT(__func__)`\n</code></pre>"},{"location":"rayxCore/Instrumentor_8h/#define-rayx_profile_scope","title":"define RAYX_PROFILE_SCOPE","text":"<pre><code>#define RAYX_PROFILE_SCOPE (\n    name\n) `::rayx::InstrumentationTimer timer##__LINE__(name, false)`\n</code></pre>"},{"location":"rayxCore/Instrumentor_8h/#define-rayx_profile_scope_stdout","title":"define RAYX_PROFILE_SCOPE_STDOUT","text":"<pre><code>#define RAYX_PROFILE_SCOPE_STDOUT (\n    name\n) `::rayx::InstrumentationTimer timer##__LINE__(name, true)`\n</code></pre>"},{"location":"rayxCore/Instrumentor_8h/#define-__pretty_function__","title":"define __PRETTY_FUNCTION__","text":"<pre><code>#define __PRETTY_FUNCTION__ `__FUNCSIG__`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Debug/Instrumentor.h</code></p>"},{"location":"rayxCore/Instrumentor_8h_source/","title":"File Instrumentor.h","text":"<p>File List &gt; Debug &gt; Instrumentor.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Basic instrumentation profiler by Cherno\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nextern bool RAYX_API BENCH_FLAG;\nclass RAYX_API InstrumentationTimer {\n  public:\n    InstrumentationTimer(const char* name, bool canPrint) : m_Name(name), m_isStopped(false), m_canPrint(canPrint) {\n        if (BENCH_FLAG) m_StartTimepoint = std::chrono::high_resolution_clock::now();\n    }\n\n    ~InstrumentationTimer() {\n        if (!m_isStopped) Stop();\n    }\n\n    void Stop() {\n        if (BENCH_FLAG) {\n            auto endTimepoint = std::chrono::high_resolution_clock::now();\n\n            long long start = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_StartTimepoint).time_since_epoch().count();\n            long long end   = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(endTimepoint).time_since_epoch().count();\n\n            if (m_canPrint) {\n                long long duration = end - start;\n                double seconds     = duration * 0.000001;\n                std::cout &lt;&lt; \"BENCH: \" &lt;&lt; m_Name &lt;&lt; \":\" &lt;&lt; std::endl &lt;&lt; seconds &lt;&lt; \"s\" &lt;&lt; std::endl;\n            }\n\n            m_isStopped = true;\n        }\n    }\n\n  private:\n    const char* m_Name;\n    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimepoint;\n    bool m_isStopped;\n    bool m_canPrint;\n};\n\n}  // namespace rayx\n\n// Define profiling macros\n#define RAYX_PROFILE_SCOPE(name) ::rayx::InstrumentationTimer timer##__LINE__(name, false)\n// Allows for printing of benchmarking results if BENCH_FLAG is set to true\n#define RAYX_PROFILE_SCOPE_STDOUT(name) ::rayx::InstrumentationTimer timer##__LINE__(name, true)\n#if !defined(__PRETTY_FUNCTION__) &amp;&amp; !defined(__GNUC__)\n#define __PRETTY_FUNCTION__ __FUNCSIG__\n#endif\n#define RAYX_PROFILE_FUNCTION() RAYX_PROFILE_SCOPE(__PRETTY_FUNCTION__)\n// Allows for printing of benchmarking results if BENCH_FLAG is set to true\n#define RAYX_PROFILE_FUNCTION_STDOUT() RAYX_PROFILE_SCOPE_STDOUT(__func__)\n</code></pre>"},{"location":"rayxCore/dir_603eb215cde9b420eb11b725e93865f2/","title":"Dir Intern/rayx-core/src/Design","text":"<p>FileList &gt; Design</p>"},{"location":"rayxCore/dir_603eb215cde9b420eb11b725e93865f2/#files","title":"Files","text":"Type Name file DesignElement.h file DesignSource.h file Value.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/</code></p>"},{"location":"rayxCore/DesignElement_8h/","title":"File DesignElement.h","text":"<p>FileList &gt; Design &gt; DesignElement.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Beamline/Node.h\"</code></li> <li><code>#include \"Element/Element.h\"</code></li> <li><code>#include \"Value.h\"</code></li> </ul>"},{"location":"rayxCore/DesignElement_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DesignElement_8h/#classes","title":"Classes","text":"Type Name class DesignElement <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/DesignElement.h</code></p>"},{"location":"rayxCore/DesignElement_8h_source/","title":"File DesignElement.h","text":"<p>File List &gt; Design &gt; DesignElement.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Beamline/Node.h\"\n#include \"Element/Element.h\"\n#include \"Value.h\"\n\nnamespace rayx {\n\nclass RAYX_API DesignElement : public BeamlineNode {\n  public:\n    DesignElement();\n    DesignElement(std::string name);\n    ~DesignElement() = default;\n\n    // Delete copy constructor because shallow copies of DesignMap lead to unexpected behavior\n    DesignElement(const DesignElement&amp; other)            = delete;\n    DesignElement&amp; operator=(const DesignElement&amp; other) = delete;\n\n    // Allow move\n    DesignElement(DesignElement&amp;&amp; other) noexcept;\n    DesignElement&amp; operator=(DesignElement&amp;&amp; other) noexcept;\n    // Allow intentional copies\n    std::unique_ptr&lt;BeamlineNode&gt; clone() const override;\n\n    DesignMap m_elementParameters;\n    OpticalElementAndTransform compile(const glm::dvec4&amp; groupPosition, const glm::dmat4&amp; groupOrientation) const;\n\n    bool isElement() const override { return true; }\n\n    std::string getName() const override;\n    void setName(std::string s) override;\n\n    ElementType getType() const;\n    void setType(ElementType s);\n\n    void setPosition(glm::dvec4 p);\n    glm::dvec4 getPosition() const override;\n\n    void setOrientation(glm::dmat4x4 o);\n    glm::dmat4x4 getOrientation() const override;\n\n    void setSlopeError(SlopeError s);\n    SlopeError getSlopeError() const;\n\n    void setAzimuthalAngle(Rad r);\n    Rad getAzimuthalAngle() const;\n\n    void setMaterial(Material m);\n    Material getMaterial() const;\n\n    void setCutout(Cutout c);\n    Cutout getCutout() const;\n    Cutout getGlobalCutout() const;\n\n    void setVLSParameters(const std::array&lt;double, 6&gt;&amp; values);\n    std::array&lt;double, 6&gt; getVLSParameters() const;\n\n    void setExpertsOptics(Surface value);\n    Surface getExpertsOptics() const;\n\n    void setExpertsCubic(Surface value);\n    Surface getExpertsCubic() const;\n\n    void setDistancePreceding(double d);\n    double getDistancePreceding() const;\n\n    void setTotalHeight(double d);\n    double getTotalHeight() const;\n\n    void setOpeningShape(CutoutType shape);\n    CutoutType getOpeningShape() const;\n\n    void setOpeningWidth(double d);\n    double getOpeningWidth() const;\n\n    void setOpeningHeight(double d);\n    double getOpeningHeight() const;\n\n    void setCentralBeamstop(CentralBeamstop d);\n    CentralBeamstop getCentralBeamstop() const;\n\n    void setStopWidth(double d);\n    double getStopWidth() const;\n\n    void setStopHeight(double height);\n    double getStopHeight() const;\n\n    void setTotalWidth(double width);\n    double getTotalWidth() const;\n\n    void setProfileKind(int value);\n    int getProfileKind() const;\n\n    void setProfileFile(double value);\n    double getProfileFile() const;\n\n    void setTotalLength(double value);\n    double getTotalLength() const;\n\n    void setGrazingIncAngle(Rad value);\n    Rad getGrazingIncAngle() const;\n\n    void setDeviationAngle(Rad value);\n    Rad getDeviationAngle() const;\n\n    void setEntranceArmLength(double value);\n    double getEntranceArmLength() const;\n\n    void setExitArmLength(double value);\n    double getExitArmLength() const;\n\n    void setRadiusDirection(CylinderDirection value);\n    CylinderDirection getRadiusDirection() const;\n\n    // Setter and Getter for radius\n    void setRadius(double value);\n    double getRadius() const;\n\n    void setCalcRadius();\n    void setCalcRadiusDeviationAngle();\n\n    void setDesignGrazingIncAngle(Rad value);\n    Rad getDesignGrazingIncAngle() const;\n\n    // Setter and Getter for longHalfAxisA\n    void setLongHalfAxisA(double value);\n    double getLongHalfAxisA() const;\n\n    // Setter and Getter for shortHalfAxisB\n    void setShortHalfAxisB(double value);\n    double getShortHalfAxisB() const;\n\n    void setParameterA11(double value);\n    double getParameterA11() const;\n\n    // Setter and Getter for figureRotation\n    void setFigureRotation(FigureRotation value);\n    FigureRotation getFigureRotation() const;\n\n    void setArmLength(double value);\n    double getArmLength() const;\n\n    void setParameterP(double value);\n    double getParameterP() const;\n\n    void setParameterPType(double value);\n    double getParameterPType() const;\n\n    void setLineDensity(double value);\n    double getLineDensity() const;\n\n    void setShortRadius(double value);\n    double getShortRadius() const;\n\n    // Setter and Getter for longRadius\n    void setLongRadius(double value);\n    double getLongRadius() const;\n\n    void setFresnelZOffset(double value);\n    double getFresnelZOffset() const;\n\n    void setDesignAlphaAngle(Rad value);\n    Rad getDesignAlphaAngle() const;\n\n    void setDesignBetaAngle(Rad value);\n    Rad getDesignBetaAngle() const;\n\n    void setDesignOrderOfDiffraction(int value);\n    int getDesignOrderOfDiffraction() const;\n\n    void setDesignEnergy(double value);\n    double getDesignEnergy() const;\n\n    void setDesignSagittalEntranceArmLength(double value);\n    double getDesignSagittalEntranceArmLength() const;\n\n    void setDesignSagittalExitArmLength(double value);\n    double getDesignSagittalExitArmLength() const;\n\n    // Setter and Getter for designMeridionalEntranceArmLength\n    void setDesignMeridionalEntranceArmLength(double value);\n    double getDesignMeridionalEntranceArmLength() const;\n\n    // Setter and Getter for designMeridionalExitArmLength\n    void setDesignMeridionalExitArmLength(double value);\n    double getDesignMeridionalExitArmLength() const;\n\n    // Setter and Getter for orderOfDiffraction\n    void setOrderOfDiffraction(int value);\n    int getOrderOfDiffraction() const;\n\n    void setAdditionalOrder(int value);\n    int getAdditionalOrder() const;\n\n    void setImageType(int value);\n    int getImageType() const;\n\n    void setCurvatureType(CurvatureType value);\n    CurvatureType getCurvatureType() const;\n\n    void setBehaviourType(BehaviourType value);\n    BehaviourType getBehaviourType() const;\n\n    void setCrystalType(CrystalType value);\n    CrystalType getCrystalType() const;\n\n    void setCrystalMaterial(const std::string&amp; value);\n    std::string getCrystalMaterial() const;\n\n    void setOffsetAngleType(OffsetAngleType value);\n    OffsetAngleType getOffsetAngleType() const;\n\n    void setOffsetAngle(Rad value);\n    Rad getOffsetAngle() const;\n\n    void setStructureFactorReF0(double value);\n    double getStructureFactorReF0() const;\n\n    void setStructureFactorImF0(double value);\n    double getStructureFactorImF0() const;\n\n    void setStructureFactorReFH(double value);\n    double getStructureFactorReFH() const;\n\n    void setStructureFactorImFH(double value);\n    double getStructureFactorImFH() const;\n\n    void setStructureFactorReFHC(double value);\n    double getStructureFactorReFHC() const;\n\n    void setStructureFactorImFHC(double value);\n    double getStructureFactorImFHC() const;\n\n    void setUnitCellVolume(double value);\n    double getUnitCellVolume() const;\n\n    void setDSpacing2(double value);\n    double getDSpacing2() const;\n\n    void setThicknessSubstrate(double value);\n    double getThicknessSubstrate() const;\n\n    void setRoughnessSubstrate(double value);\n    double getRoughnessSubstrate() const;\n\n    void setDesignPlane(DesignPlane value);\n    DesignPlane getDesignPlane() const;\n\n    void setSurfaceCoatingType(SurfaceCoatingType value);\n    SurfaceCoatingType getSurfaceCoatingType() const;\n\n    void setMultilayerCoating(const Coating::MultilayerCoating&amp; coating);\n\n    Coating getCoating() const;\n\n    void setMaterialCoating(Material value);\n    Material getMaterialCoating() const;\n\n    void setThicknessCoating(double value);\n    double getThicknessCoating() const;\n\n    void setRoughnessCoating(double value);\n    double getRoughnessCoating() const;\n};\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DesignSource_8h/","title":"File DesignSource.h","text":"<p>FileList &gt; Design &gt; DesignSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Beamline/Node.h\"</code></li> <li><code>#include \"Value.h\"</code></li> </ul>"},{"location":"rayxCore/DesignSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DesignSource_8h/#classes","title":"Classes","text":"Type Name class DesignSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/DesignSource.h</code></p>"},{"location":"rayxCore/DesignSource_8h_source/","title":"File DesignSource.h","text":"<p>File List &gt; Design &gt; DesignSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Beamline/Node.h\"\n#include \"Value.h\"\n\nnamespace rayx {\n\nclass RAYX_API DesignSource : public BeamlineNode {\n  public:\n    DesignSource();\n    DesignSource(std::string name);\n    ~DesignSource() = default;\n\n    // Delete copy constructor because shallow copies of DesignMap lead to unexpected behavior\n    DesignSource(const DesignSource&amp; other)            = delete;\n    DesignSource&amp; operator=(const DesignSource&amp; other) = delete;\n\n    // Allow move\n    DesignSource(DesignSource&amp;&amp; other) noexcept;\n    DesignSource&amp; operator=(DesignSource&amp;&amp; other) noexcept;\n\n    // Allow intentional copies\n    std::unique_ptr&lt;BeamlineNode&gt; clone() const override;\n\n    DesignMap m_elementParameters;\n\n    bool isSource() const override { return true; }\n\n    void setStokeslin0(double value);\n    void setStokeslin45(double value);\n    void setStokescirc(double value);\n    glm::dvec4 getStokes() const;\n\n    void setName(std::string s) override;\n    std::string getName() const override;\n\n    void setType(ElementType s);\n    ElementType getType() const;\n\n    void setWidthDist(SourceDist value);\n    SourceDist getWidthDist() const;\n\n    void setHeightDist(SourceDist value);\n    SourceDist getHeightDist() const;\n\n    void setHorDist(SourceDist value);\n    SourceDist getHorDist() const;\n\n    void setVerDist(SourceDist value);\n    SourceDist getVerDist() const;\n\n    void setHorDivergence(double value);\n    double getHorDivergence() const;\n\n    void setVerDivergence(double value);\n    double getVerDivergence() const;\n\n    void setVerEBeamDivergence(double value);\n    double getVerEBeamDivergence() const;\n\n    void setSourceDepth(double value);\n    double getSourceDepth() const;\n\n    void setSourceHeight(double value);\n    double getSourceHeight() const;\n\n    void setSourceWidth(double value);\n    double getSourceWidth() const;\n\n    void setBendingRadius(double value);\n    double getBendingRadius() const;\n\n    void setEnergySpread(double value);\n    double getEnergySpread() const;\n\n    void setEnergySpreadType(SpreadType value);\n    SpreadType getEnergySpreadType() const;\n\n    void setEnergyDistributionType(EnergyDistributionType value);\n    EnergyDistributionType getEnergyDistributionType() const;\n\n    void setEnergyDistributionFile(std::string value);\n\n    void setEnergySpreadUnit(EnergySpreadUnit value);\n    EnergySpreadUnit getEnergySpreadUnit() const;\n\n    void setElectronEnergy(double value);\n    double getElectronEnergy() const;\n\n    void setElectronEnergyOrientation(ElectronEnergyOrientation value);\n    ElectronEnergyOrientation getElectronEnergyOrientation() const;\n\n    void setNumberOfSeparateEnergies(int value);\n    int getNumberOfSeparateEnergies() const;\n\n    void setEnergy(double value);\n    double getEnergy() const;\n\n    void setPhotonFlux(double value);\n    double getPhotonFlux() const;\n\n    EnergyDistributionVariant getEnergyDistribution() const;\n\n    void setNumberOfRays(int value);\n    int getNumberOfRays() const;\n\n    // TODO: the w component is not used\n    void setPosition(glm::dvec4 p);\n    glm::dvec4 getPosition() const override;\n\n    void setOrientation(glm::dmat4x4 o);\n    glm::dmat4x4 getOrientation() const override;\n\n    void setNumOfCircles(int value);\n    int getNumOfCircles() const;\n\n    void setMaxOpeningAngle(Rad value);\n    Rad getMaxOpeningAngle() const;\n\n    void setMinOpeningAngle(Rad value);\n    Rad getMinOpeningAngle() const;\n\n    void setDeltaOpeningAngle(Rad value);\n    Rad getDeltaOpeningAngle() const;\n\n    void setSigmaType(SigmaType value);\n    SigmaType getSigmaType() const;\n\n    void setUndulatorLength(double value);\n    double getUndulatorLength() const;\n\n    void setElectronSigmaX(double value);\n    double getElectronSigmaX() const;\n\n    void setElectronSigmaXs(double value);\n    double getElectronSigmaXs() const;\n\n    void setElectronSigmaY(double value);\n    double getElectronSigmaY() const;\n\n    void setElectronSigmaYs(double value);\n    double getElectronSigmaYs() const;\n\n    void setRayList(Rays rays);\n    void setRayList(std::shared_ptr&lt;Rays&gt;&amp; rays);\n    std::shared_ptr&lt;Rays&gt; getRayList() const;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Value_8h/","title":"File Value.h","text":"<p>FileList &gt; Design &gt; Value.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include \"Angle.h\"</code></li> <li><code>#include \"Beamline/EnergyDistribution.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Debug/Debug.h\"</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> <li><code>#include \"Element/Surface.h\"</code></li> <li><code>#include \"Material/Material.h\"</code></li> <li><code>#include \"Rml/xml.h\"</code></li> </ul>"},{"location":"rayxCore/Value_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Value_8h/#classes","title":"Classes","text":"Type Name class DesignMap class ConstIterator class Iterator class Undefined <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Design/Value.h</code></p>"},{"location":"rayxCore/Value_8h_source/","title":"File Value.h","text":"<p>File List &gt; Design &gt; Value.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iterator&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;variant&gt;\n\n// Include your other dependencies.\n#include \"Angle.h\"\n#include \"Beamline/EnergyDistribution.h\"\n#include \"Core.h\"\n#include \"Debug/Debug.h\"\n#include \"Element/Cutout.h\"\n#include \"Element/Surface.h\"\n#include \"Material/Material.h\"\n#include \"Rml/xml.h\"\n\nnamespace rayx {\n\nenum class ValueType {\n    Undefined,\n    Double,\n    Int,\n    String,\n    Map,\n    Dvec4,\n    Dmat4x4,\n    Bool,\n    Rad,\n    Material,\n    CentralBeamstop,\n    Cutout,\n    CutoutType,\n    EventType,\n    CylinderDirection,\n    FigureRotation,\n    CurvatureType,\n    Surface,\n    SourceDist,\n    SpreadType,\n    EnergyDistributionType,\n    EnergySpreadUnit,\n    ElectronEnergyOrientation,\n    SigmaType,\n    BehaviourType,\n    ElementType,\n    GratingMount,\n    CrystalType,\n    DesignPlane,\n    SurfaceCoatingType,\n    RayList,\n};\n\nclass Undefined {};\n\nclass DesignMap;\n\nusing Map = std::unordered_map&lt;std::string, std::shared_ptr&lt;DesignMap&gt;&gt;;\n\nclass RAYX_API DesignMap {\n  public:\n    // Constructors\n    DesignMap() : m_variant(Undefined()) {}\n    DesignMap(double x) : m_variant(x) {}\n    DesignMap(int x) : m_variant(x) {}\n    DesignMap(bool x) : m_variant(x) {}\n    DesignMap(const std::string&amp; x) : m_variant(x) {}\n    DesignMap(Map x) : m_variant(x) {}\n    DesignMap(glm::dvec4 x) : m_variant(x) {}\n    DesignMap(glm::dmat4x4 x) : m_variant(x) {}\n    DesignMap(Rad x) : m_variant(x) {}\n    DesignMap(Material x) : m_variant(x) {}\n    DesignMap(CentralBeamstop x) : m_variant(x) {}\n    DesignMap(Cutout x) : m_variant(x) {}\n    DesignMap(CutoutType x) : m_variant(x) {}\n    DesignMap(EventType x) : m_variant(x) {}\n    DesignMap(CylinderDirection x) : m_variant(x) {}\n    DesignMap(FigureRotation x) : m_variant(x) {}\n    DesignMap(CurvatureType x) : m_variant(x) {}\n    DesignMap(Surface x) : m_variant(x) {}\n    DesignMap(SourceDist x) : m_variant(x) {}\n    DesignMap(SpreadType x) : m_variant(x) {}\n    DesignMap(EnergyDistributionType x) : m_variant(x) {}\n    DesignMap(EnergySpreadUnit x) : m_variant(x) {}\n    DesignMap(SigmaType x) : m_variant(x) {}\n    DesignMap(BehaviourType x) : m_variant(x) {}\n    DesignMap(ElementType x) : m_variant(x) {}\n    DesignMap(GratingMount x) : m_variant(x) {}\n    DesignMap(CrystalType x) : m_variant(x) {}\n    DesignMap(DesignPlane x) : m_variant(x) {}\n    DesignMap(SurfaceCoatingType x) : m_variant(x) {}\n    DesignMap(std::shared_ptr&lt;Rays&gt; x) : m_variant(x) {}\n\n    // Assignment operators\n    void operator=(double x) { m_variant = x; }\n    void operator=(int x) { m_variant = x; }\n    void operator=(bool x) { m_variant = x; }\n    void operator=(const std::string&amp; x) { m_variant = x; }\n    void operator=(Map x) { m_variant = x; }\n    void operator=(glm::dvec4 x) { m_variant = x; }\n    void operator=(glm::dmat4 x) { m_variant = x; }\n    void operator=(Rad x) { m_variant = x; }\n    void operator=(Material x) { m_variant = x; }\n    void operator=(CentralBeamstop x) { m_variant = x; }\n    void operator=(Cutout x) { m_variant = x; }\n    void operator=(CutoutType x) { m_variant = x; }\n    void operator=(EventType x) { m_variant = x; }\n    void operator=(CylinderDirection x) { m_variant = x; }\n    void operator=(FigureRotation x) { m_variant = x; }\n    void operator=(CurvatureType x) { m_variant = x; }\n    void operator=(Surface x) { m_variant = x; }\n    void operator=(SourceDist x) { m_variant = x; }\n    void operator=(SpreadType x) { m_variant = x; }\n    void operator=(EnergyDistributionType x) { m_variant = x; }\n    void operator=(EnergySpreadUnit x) { m_variant = x; }\n    void operator=(ElectronEnergyOrientation x) { m_variant = x; }\n    void operator=(SigmaType x) { m_variant = x; }\n    void operator=(BehaviourType x) { m_variant = x; }\n    void operator=(GratingMount x) { m_variant = x; }\n    void operator=(ElementType x) { m_variant = x; }\n    void operator=(CrystalType x) { m_variant = x; }\n    void operator=(DesignPlane x) { m_variant = x; }\n    void operator=(SurfaceCoatingType x) { m_variant = x; }\n    void operator=(std::shared_ptr&lt;Rays&gt; x) { m_variant = x; }\n\n    // Deep copy (clone) method.\n    DesignMap clone() const;\n\n    // Accessor functions.\n    ValueType type() const;\n    double as_double() const;\n    int as_int() const;\n    bool as_bool() const;\n    std::string as_string() const;\n    Map as_map() const;\n    glm::dvec4 as_dvec4() const;\n    glm::dmat4 as_dmat4x4() const;\n    Rad as_rad() const;\n    Material as_material() const;\n    CentralBeamstop as_centralBeamStop() const;\n    Cutout as_cutout() const;\n    CutoutType as_openingShape() const;\n    EventType as_eventType() const;\n    CylinderDirection as_cylinderDirection() const;\n    FigureRotation as_figureRotation() const;\n    CurvatureType as_curvatureType() const;\n    Surface as_surface() const;\n    SourceDist as_sourceDist() const;\n    SpreadType as_energySpreadType() const;\n    EnergyDistributionType as_energyDistType() const;\n    EnergySpreadUnit as_energySpreadUnit() const;\n    ElectronEnergyOrientation as_electronEnergyOrientation() const;\n    SigmaType as_sigmaType() const;\n    BehaviourType as_behaviourType() const;\n    ElementType as_elementType() const;\n    GratingMount as_gratingMount() const;\n    CrystalType as_crystalType() const;\n    DesignPlane as_designPlane() const;\n    SurfaceCoatingType as_surfaceCoatingType() const;\n    std::shared_ptr&lt;Rays&gt; as_rayList() const;\n\n    bool hasKey(const std::string&amp; s) const;\n\n    // Subscript operators.\n    const DesignMap&amp; operator[](const std::string&amp; s) const;\n    DesignMap&amp; operator[](const std::string&amp; s);\n\n    EnergyDistributionType as_energyDistributionType() const {\n        auto* x = std::get_if&lt;EnergyDistributionType&gt;(&amp;m_variant);\n        if (!x) throw std::runtime_error(\"as_energyDistributionType() called on non-energyDistributionType!\");\n        return *x;\n    }\n\n    // Iterator classes\n    // Iterator classes (simple wrappers around the underlying Map iterators).\n    class Iterator {\n      public:\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = std::pair&lt;const std::string, std::shared_ptr&lt;DesignMap&gt;&gt;;\n        using pointer           = value_type*;\n        using reference         = value_type&amp;;\n\n        Iterator(Map::iterator it) : m_it(it) {}\n        reference operator*() const { return *m_it; }\n        pointer operator-&gt;() { return &amp;(*m_it); }\n        Iterator&amp; operator++() {\n            ++m_it;\n            return *this;\n        }\n        Iterator operator++(int) {\n            Iterator tmp(*this);\n            ++(*this);\n            return tmp;\n        }\n        friend bool operator==(const Iterator&amp; a, const Iterator&amp; b) { return a.m_it == b.m_it; }\n        friend bool operator!=(const Iterator&amp; a, const Iterator&amp; b) { return a.m_it != b.m_it; }\n\n      private:\n        Map::iterator m_it;\n    };\n\n    class ConstIterator {\n      public:\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = const std::pair&lt;const std::string, std::shared_ptr&lt;DesignMap&gt;&gt;;\n        using pointer           = const value_type*;\n        using reference         = const value_type&amp;;\n\n        ConstIterator(Map::const_iterator it) : m_it(it) {}\n        reference operator*() const { return *m_it; }\n        pointer operator-&gt;() { return &amp;(*m_it); }\n        ConstIterator&amp; operator++() {\n            ++m_it;\n            return *this;\n        }\n        ConstIterator operator++(int) {\n            ConstIterator tmp(*this);\n            ++(*this);\n            return tmp;\n        }\n        friend bool operator==(const ConstIterator&amp; a, const ConstIterator&amp; b) { return a.m_it == b.m_it; }\n        friend bool operator!=(const ConstIterator&amp; a, const ConstIterator&amp; b) { return a.m_it != b.m_it; }\n\n      private:\n        Map::const_iterator m_it;\n    };\n\n    // Begin/end for iterators.\n    Iterator begin();\n    Iterator end();\n    ConstIterator begin() const;\n    ConstIterator end() const;\n\n  private:\n    using Variant = std::variant&lt;Undefined, double, int, ElectronEnergyOrientation, glm::dvec4, glm::dmat4x4, bool, EnergyDistributionType,\n                                 CentralBeamstop, Cutout, CutoutType, EventType, CylinderDirection, FigureRotation, Map, Surface, CurvatureType,\n                                 SourceDist, SpreadType, Rad, Material, EnergySpreadUnit, std::string, SigmaType, BehaviourType, ElementType,\n                                 GratingMount, CrystalType, DesignPlane, SurfaceCoatingType, std::shared_ptr&lt;Rays&gt;&gt;;\n    static_assert(std::is_copy_constructible_v&lt;Variant&gt;);\n\n    Variant m_variant;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_3aac88a0ca6da04f1fbf5fc0eadcf8cd/","title":"Dir Intern/rayx-core/src/Element","text":"<p>FileList &gt; Element</p>"},{"location":"rayxCore/dir_3aac88a0ca6da04f1fbf5fc0eadcf8cd/#files","title":"Files","text":"Type Name file Behaviour.h file Coating.h file Cutout.h file Element.h file Surface.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/</code></p>"},{"location":"rayxCore/Behaviour_8h/","title":"File Behaviour.h","text":"<p>FileList &gt; Element &gt; Behaviour.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Cutout.h\"</code></li> <li><code>#include \"Variant.h\"</code></li> </ul>"},{"location":"rayxCore/Behaviour_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace detail"},{"location":"rayxCore/Behaviour_8h/#classes","title":"Classes","text":"Type Name struct BehaviourTypes struct Crystal struct Foil struct Grating struct ImagePlane struct Mirror struct RZP struct Slit <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Behaviour.h</code></p>"},{"location":"rayxCore/Behaviour_8h_source/","title":"File Behaviour.h","text":"<p>File List &gt; Element &gt; Behaviour.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"Cutout.h\"\n#include \"Variant.h\"\n\nnamespace rayx {\n\n#undef m_private_serialization_params\n\n// A behaviour decides what happens whenever a ray hits the surface of this element.\n// Each behaviour type has its own `behave` function in `Behave.h`.\nenum class BehaveType { Mirror, Grating, Slit, RZP, ImagePlane, Crystal, Foil };\n\nnamespace detail {\nstruct BehaviourTypes {\n    struct Mirror {\n        // no parameters\n    };\n\n    struct Grating {\n        double m_vls[6];          // VLS coefficients\n        double m_lineDensity;     // lines per mm\n        int m_orderOfDiffraction; /* the diffraction order, usually 1 */\n    };\n\n    struct Slit {\n        Cutout m_openingCutout;   // The cutout of the small opening in the slit.\n        Cutout m_beamstopCutout;  // The cutout of the beamstop inside the small opening.\n    };\n\n    struct RZP {\n        int m_imageType;\n        int m_rzpType;\n        int m_derivationMethod;\n        int m_designOrderOfDiffraction;\n        int m_orderOfDiffraction;\n        int m_additionalOrder;\n        double m_designWavelength;\n        double m_fresnelZOffset;\n        double m_designSagittalEntranceArmLength;\n        double m_designSagittalExitArmLength;\n        double m_designMeridionalEntranceArmLength;\n        double m_designMeridionalExitArmLength;\n        double m_designAlphaAngle;\n        double m_designBetaAngle;\n    };\n\n    struct ImagePlane {\n        // no parameters\n    };\n\n    struct Crystal {\n        double m_dSpacing2;\n        double m_unitCellVolume;\n        double m_offsetAngle;\n\n        double m_structureFactorReF0;\n        double m_structureFactorImF0;\n        double m_structureFactorReFH;\n        double m_structureFactorImFH;\n        double m_structureFactorReFHC;\n        double m_structureFactorImFHC;\n    };\n\n    struct Foil {\n        // Substrates\n        double m_thicknessSubstrate;\n        double m_roughnessSubstrate;\n    };\n};\n}  // namespace detail\n\nusing Behaviour =\n    Variant&lt;detail::BehaviourTypes, detail::BehaviourTypes::Mirror, detail::BehaviourTypes::Grating, detail::BehaviourTypes::Slit,\n            detail::BehaviourTypes::RZP, detail::BehaviourTypes::ImagePlane, detail::BehaviourTypes::Crystal, detail::BehaviourTypes::Foil&gt;;\n\nclass DesignElement;\nenum class RZPType { Elliptical, Meriodional };\nenum class CentralBeamstop { None, Rectangle, Elliptical };\nBehaviour makeBehaviour(const DesignElement&amp; dele);\nBehaviour makeCrystal(const DesignElement&amp; dele);\nBehaviour makeGrating(const DesignElement&amp; dele);  //&lt; creates a Grating Behaviour from the parameters given in `dele`.\nBehaviour makeSlit(const DesignElement&amp; dele);\nBehaviour makeRZPBehaviour(const DesignElement&amp; dele);\nBehaviour makeFoil(const DesignElement&amp; dele);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Coating_8h/","title":"File Coating.h","text":"<p>FileList &gt; Element &gt; Coating.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Variant.h\"</code></li> </ul>"},{"location":"rayxCore/Coating_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace detail"},{"location":"rayxCore/Coating_8h/#classes","title":"Classes","text":"Type Name struct CoatingTypes struct MultilayerCoating struct OneCoating struct SubstrateOnly <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Coating.h</code></p>"},{"location":"rayxCore/Coating_8h_source/","title":"File Coating.h","text":"<p>File List &gt; Element &gt; Coating.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Variant.h\"\n\nnamespace rayx {\n\nenum class SurfaceCoatingType {\n    SubstrateOnly,    // No coating, only substrate\n    OneCoating,       // One coating layer\n    MultipleCoatings  // Multiple coating layers\n};\n\nnamespace detail {\nstruct CoatingTypes {\n    struct RAYX_API SubstrateOnly{\n        // No additional parameters needed\n    };\n\n    struct RAYX_API OneCoating {\n        int material;\n        double thickness;\n        double roughness;\n    };\n\n    struct RAYX_API MultilayerCoating {\n        int numLayers;\n        int material[1000];\n        double thickness[1000];\n        double roughness[1000];\n    };\n};\n}  // namespace detail\n\nusing Coating =\n    Variant&lt;detail::CoatingTypes, detail::CoatingTypes::SubstrateOnly, detail::CoatingTypes::OneCoating, detail::CoatingTypes::MultilayerCoating&gt;;\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Cutout_8h/","title":"File Cutout.h","text":"<p>FileList &gt; Element &gt; Cutout.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Variant.h\"</code></li> </ul>"},{"location":"rayxCore/Cutout_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace detail"},{"location":"rayxCore/Cutout_8h/#classes","title":"Classes","text":"Type Name struct CutoutTypes struct Elliptical struct Rect struct Trapezoid struct Unlimited <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Cutout.h</code></p>"},{"location":"rayxCore/Cutout_8h_source/","title":"File Cutout.h","text":"<p>File List &gt; Element &gt; Cutout.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"Variant.h\"\n\nnamespace rayx {\n\n// Cutout types:\n// a subset of points of the XZ-plane. used to limit the potentially infinite surfaces.\n// note that the first 3 need to be RECT; ELLIPTICAL; TRAPEZOID in order to be compatible with `geometricalShape` from Ray-UI.\nenum class CutoutType {\n    Rect,\n    Elliptical,\n    Trapezoid,\n    Unlimited,\n};\n\nnamespace detail {\nstruct RAYX_API CutoutTypes {\n    // Unlimited\n\n    // Every point (x, z) is within this cutout, it's unlimited after all.\n    // `Unlimited` doesn't have any data so it doesn't need a struct.\n    struct Unlimited {\n        // no parameters\n    };\n\n    // Rect\n\n    // A rectangle specified by width/length centered at (x=0, z=0).\n    struct Rect {\n        double m_width;\n        double m_length;\n    };\n\n    // Elliptical\n\n    // https://en.wikipedia.org/wiki/Ellipse\n    //\n    // An elliptical shape given by two diameters.\n    // It can be understood as a circle with individual stretch-factors for both dimensions.\n    // The point (x=0, z=0) lies at the center of the ellipse.\n\n    struct Elliptical {\n        double m_diameter_x;\n        double m_diameter_z;\n    };\n\n    // Trapezoid\n\n    // https://en.wikipedia.org/wiki/Trapezoid\n    //\n    // A trapezoid consists of two lines with lengths `m_widthA` and `m_widthB`, both parallel to the X-axis.\n    // These lines have a distance of `m_length`.\n    // The point (x=0, z=0) lies at the center of the trapezoid.\n\n    struct Trapezoid {\n        double m_widthA;\n        double m_widthB;\n        double m_length;\n    };\n};\n}  // namespace detail\n\nusing Cutout = Variant&lt;detail::CutoutTypes, detail::CutoutTypes::Rect, detail::CutoutTypes::Elliptical, detail::CutoutTypes::Trapezoid,\n                       detail::CutoutTypes::Unlimited&gt;;\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Element_8h/","title":"File Element.h","text":"<p>FileList &gt; Element &gt; Element.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"Behaviour.h\"</code></li> <li><code>#include \"Coating.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Cutout.h\"</code></li> <li><code>#include \"Rml/xml.h\"</code></li> <li><code>#include \"Shader/SlopeError.h\"</code></li> <li><code>#include \"Surface.h\"</code></li> </ul>"},{"location":"rayxCore/Element_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Element_8h/#classes","title":"Classes","text":"Type Name struct ObjectTransform struct OpticalElement Structure to represent an element in the ray tracing simulation. struct OpticalElementAndTransform <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Element.h</code></p>"},{"location":"rayxCore/Element_8h_source/","title":"File Element.h","text":"<p>File List &gt; Element &gt; Element.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\n#include \"Behaviour.h\"\n#include \"Coating.h\"\n#include \"Core.h\"\n#include \"Cutout.h\"\n#include \"Rml/xml.h\"\n#include \"Shader/SlopeError.h\"\n#include \"Surface.h\"\n\nnamespace rayx {\n\nclass DesignElement;\n\nenum class ElementType {\n    Undefined,\n    ImagePlane,\n    ConeMirror,\n    Crystal,\n    CylinderMirror,\n    EllipsoidMirror,\n    ExpertsMirror,\n    Foil,\n    ParaboloidMirror,\n    PlaneGrating,\n    PlaneMirror,\n    ReflectionZoneplate,\n    Slit,\n    SphereGrating,\n    Sphere,\n    SphereMirror,\n    ToroidMirror,\n    ToroidGrating,\n    PointSource,\n    MatrixSource,\n    DipoleSource,\n    PixelSource,\n    CircleSource,\n    SimpleUndulatorSource,\n    RayListSource,\n};\n\nstruct OpticalElement {\n    Behaviour m_behaviour;    \n    Surface m_surface;        \n    Cutout m_cutout;          \n    Coating m_coating;        \n    SlopeError m_slopeError;  \n    double m_azimuthalAngle;  \n    int m_material;           \n};\n\n// Ensure OpticalElement does not introduce cost on copy or default construction.\n// static_assert(std::is_trivially_copyable_v&lt;OpticalElement&gt;);\n\nstruct ObjectTransform {\n    glm::dmat4 m_inTrans;   \n    glm::dmat4 m_outTrans;  \n};\n\nRAYX_API glm::dmat4 calcTransformationMatrices(glm::dvec4 position, glm::dmat4 orientation, bool calcInMatrix, DesignPlane plane);\n\nstruct OpticalElementAndTransform {\n    OpticalElement element;\n    ObjectTransform transform;\n};\n\n// constructs an OpticalElement given all of its components. Some information that is not explicitly given, will be parsed from the ` dele`.\nOpticalElementAndTransform makeElement(const DesignElement&amp; dele, Behaviour behaviour, Surface surface, DesignPlane plane = DesignPlane::XZ,\n                                       std::optional&lt;Cutout&gt; cutout = {});\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Surface_8h/","title":"File Surface.h","text":"<p>FileList &gt; Element &gt; Surface.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Variant.h\"</code></li> </ul>"},{"location":"rayxCore/Surface_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace detail"},{"location":"rayxCore/Surface_8h/#classes","title":"Classes","text":"Type Name struct SurfaceTypes struct Cubic struct Plane struct Quadric struct Toroid <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Element/Surface.h</code></p>"},{"location":"rayxCore/Surface_8h_source/","title":"File Surface.h","text":"<p>File List &gt; Element &gt; Surface.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"Variant.h\"\n\nnamespace rayx {\n\nenum class ToroidType {\n    Convex,\n    Concave,\n};\n\n// a surface is a potentially infinite curved surface in 3d space.\n// as our elements are mostly finite in size, they are represented by a (potentially infinite) surface in combination with a finite cutout (see CTYPE\n// constants)\n\nnamespace detail {\nstruct SurfaceTypes {\n    struct Plane {\n        // no parameters\n    };\n\n    struct Quadric {\n        int m_icurv;\n        double m_a11;\n        double m_a12;\n        double m_a13;\n        double m_a14;\n        double m_a22;\n        double m_a23;\n        double m_a24;\n        double m_a33;\n        double m_a34;\n        double m_a44;\n    };\n\n    struct Toroid {\n        double m_longRadius;\n        double m_shortRadius;\n        ToroidType m_toroidType;\n    };\n\n    struct Cubic {\n        // int m_icurv;\n        double m_a11;\n        double m_a12;\n        double m_a13;\n        double m_a14;\n        double m_a22;\n        double m_a23;\n        double m_a24;\n        double m_a33;\n        double m_a34;\n        double m_a44;\n\n        double m_b12;\n        double m_b13;\n        double m_b21;\n        double m_b23;\n        double m_b31;\n        double m_b32;\n\n        double m_psi;\n    };\n};\n}  // namespace detail\n\nusing Surface = Variant&lt;detail::SurfaceTypes, detail::SurfaceTypes::Plane, detail::SurfaceTypes::Quadric, detail::SurfaceTypes::Toroid,\n                        detail::SurfaceTypes::Cubic&gt;;\n\nclass DesignElement;\nenum class CylinderDirection { LongRadiusR, ShortRadiusRho };\nSurface makeSurface(const DesignElement&amp; dele);\nSurface makeToroid(const DesignElement&amp; dele);      //&lt; creates a toroid from the parameters given in ` dele`.\nSurface makeQuadric(const DesignElement&amp; dele);     //&lt; creates a quadric from the parameters given in ` dele`.\nSurface makeCubic(const DesignElement&amp; dele);       //&lt; creates a cubic from the parameters given in ` dele`.\nSurface makeEllipsoid(const DesignElement&amp; dele);   //&lt; creates a Ellipsoid from the parameters given in ` dele`.\nSurface makeCone(const DesignElement&amp; dele);        //&lt; creates a Cone from the parameters given in ` dele`.\nSurface makeCylinder(const DesignElement&amp; dele);    //&lt; creates a Cylinder from the parameters given in ` dele`.\nSurface makeSphere(double radius);                  //&lt; creates a sphere from the radius .\nSurface makePlane();                                //&lt; creates a plane surface\nSurface makeParaboloid(const DesignElement&amp; dele);  //&lt; creates a Paraboloid from the parameters given in ` dele`.\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_af3431b45235e77f76be56c52f909c7b/","title":"Dir Intern/rayx-core/src/Material","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Material</p>"},{"location":"rayxCore/dir_af3431b45235e77f76be56c52f909c7b/#files","title":"Files","text":"Type Name file Material.h file NffTable.h file PalikTable.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/</code></p>"},{"location":"rayxCore/Material_8h/","title":"File Material.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; Material.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"materials.xmacro\"</code></li> </ul>"},{"location":"rayxCore/Material_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Material_8h/#classes","title":"Classes","text":"Type Name struct MaterialTables"},{"location":"rayxCore/Material_8h/#macros","title":"Macros","text":"Type Name define X (e, z, a, rho) <code>e = z,</code>"},{"location":"rayxCore/Material_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Material_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    e,\n    z,\n    a,\n    rho\n) `e = z,`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/Material.h</code></p>"},{"location":"rayxCore/Material_8h_source/","title":"File Material.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; Material.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nenum class Material {\n    REFLECTIVE = -2,\n    VACUUM     = -1,\n\n// Material = 0 is not used yet\n\n#define X(e, z, a, rho) e = z,\n#include \"materials.xmacro\"\n#undef X\n};\n\nbool materialFromString(const char* matname, Material* out);\n\nstruct RAYX_API MaterialTables {\n    std::vector&lt;double&gt; materials;\n    std::vector&lt;int&gt; indices;\n};\n\n// the following function loads the Palik &amp; Nff tables.\n// the tables will later be written to the mat and matIdx buffers of shader.comp\nMaterialTables RAYX_API loadMaterialTables(std::array&lt;bool, 92&gt; relevantMaterials);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/NffTable_8h/","title":"File NffTable.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; NffTable.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../Shader/RefractiveIndex.h\"</code></li> </ul>"},{"location":"rayxCore/NffTable_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/NffTable_8h/#classes","title":"Classes","text":"Type Name struct NffTable <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/NffTable.h</code></p>"},{"location":"rayxCore/NffTable_8h_source/","title":"File NffTable.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; NffTable.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// This file defines the NffEntry.\n#include \"../Shader/RefractiveIndex.h\"\n\nnamespace rayx {\nstruct NffTable {\n    std::string m_element;\n    std::vector&lt;NffEntry&gt; m_Lines;\n\n    static bool load(const char* element, NffTable* out);\n\n    // double interpolate(double x) const;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/PalikTable_8h/","title":"File PalikTable.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; PalikTable.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../Shader/RefractiveIndex.h\"</code></li> </ul>"},{"location":"rayxCore/PalikTable_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/PalikTable_8h/#classes","title":"Classes","text":"Type Name struct PalikTable <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Material/PalikTable.h</code></p>"},{"location":"rayxCore/PalikTable_8h_source/","title":"File PalikTable.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Material &gt; PalikTable.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// This file defines the PalikEntry.\n#include \"../Shader/RefractiveIndex.h\"\n\nnamespace rayx {\nstruct PalikTable {\n    std::string m_element;\n    std::vector&lt;PalikEntry&gt; m_Lines;\n\n    static bool load(const char* element, PalikTable* out);\n\n    // double interpolate(double x) const;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_b0f1a6165fb17224e128354cc7d7bccf/","title":"Dir Intern/rayx-core/src/Rml","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml</p>"},{"location":"rayxCore/dir_b0f1a6165fb17224e128354cc7d7bccf/#files","title":"Files","text":"Type Name file DesignElementWriter.h file DesignSourceWriter.h file Importer.h file Locate.h file xml.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/</code></p>"},{"location":"rayxCore/DesignElementWriter_8h/","title":"File DesignElementWriter.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; DesignElementWriter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Beamline/Beamline.h\"</code></li> <li><code>#include \"Beamline/Definitions.h\"</code></li> <li><code>#include \"Beamline/StringConversion.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> </ul>"},{"location":"rayxCore/DesignElementWriter_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/DesignElementWriter.h</code></p>"},{"location":"rayxCore/DesignElementWriter_8h_source/","title":"File DesignElementWriter.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; DesignElementWriter.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Beamline/Beamline.h\"\n#include \"Beamline/Definitions.h\"\n#include \"Beamline/StringConversion.h\"\n#include \"Core.h\"\n#include \"Element/Cutout.h\"\n\nnamespace rayx {\n\nvoid getSurfaceCoating(xml::Parser parser, DesignElement* de) {\n    if (parser.parseSurfaceCoatingType() == SurfaceCoatingType::SubstrateOnly) {\n        de-&gt;setSurfaceCoatingType(parser.parseSurfaceCoatingType());\n        return;\n    } else if (parser.parseSurfaceCoatingType() == SurfaceCoatingType::OneCoating) {\n        de-&gt;setSurfaceCoatingType(parser.parseSurfaceCoatingType());\n        de-&gt;setMaterialCoating(parser.parseMaterial());\n        de-&gt;setThicknessCoating(parser.parseThicknessCoating());\n        de-&gt;setRoughnessCoating(parser.parseRoughnessCoating());\n    } else if (parser.parseSurfaceCoatingType() == SurfaceCoatingType::MultipleCoatings) {\n        de-&gt;setSurfaceCoatingType(parser.parseSurfaceCoatingType());\n        de-&gt;setMultilayerCoating(parser.parseCoating());\n        return;\n    }\n}\n\nvoid setAllMandatory(xml::Parser parser, DesignElement* de, DesignPlane dp) {\n    de-&gt;setName(parser.name());\n    de-&gt;setType(parser.type());\n\n    de-&gt;setPosition(parser.parsePosition());\n    de-&gt;setOrientation(parser.parseOrientation());\n\n    de-&gt;setSlopeError(parser.parseSlopeError());\n    de-&gt;setAzimuthalAngle(parser.parseAzimuthalAngle());\n    de-&gt;setMaterial(parser.parseMaterial());\n\n    de-&gt;setSurfaceCoatingType(SurfaceCoatingType::SubstrateOnly);\n    de-&gt;setDesignPlane(dp);\n    if (de-&gt;getType() != ElementType::ImagePlane) {\n        de-&gt;setCutout(parser.parseCutout(dp, ElementTypeToString.at(parser.type())));\n    } else {\n        de-&gt;setCutout(parser.parseCutout(dp, ElementTypeToString.at(parser.type())));\n    }\n}\n\nvoid getImageplane(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XY);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n    de-&gt;setBehaviourType(BehaviourType::ImagePlane);\n}\n\nvoid getSlit(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XY);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n    de-&gt;setBehaviourType(BehaviourType::Slit);\n\n    de-&gt;setOpeningShape(static_cast&lt;CutoutType&gt;(parser.parseOpeningShape()));\n    de-&gt;setOpeningWidth(parser.parseOpeningWidth());\n    de-&gt;setOpeningHeight(parser.parseOpeningHeight());\n    de-&gt;setCentralBeamstop(parser.parseCentralBeamstop());\n    de-&gt;setStopWidth(parser.parseTotalWidthStop());\n    de-&gt;setStopHeight(parser.parseTotalHeightStop());\n    de-&gt;setTotalWidth(parser.parseTotalWidth());\n    de-&gt;setTotalHeight(parser.parseTotalHeight());\n    de-&gt;setDistancePreceding(parser.parseDistancePreceding());\n}\n\nvoid getCone(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Cone);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setGrazingIncAngle(parser.parseGrazingIncAngle());\n    de-&gt;setEntranceArmLength(parser.parseEntranceArmLength());\n    de-&gt;setExitArmLength(parser.parseExitArmLength());\n    de-&gt;setTotalLength(parser.parseTotalLength());\n}\n\nvoid getCrystal(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n    de-&gt;setBehaviourType(BehaviourType::Crystal);\n\n    de-&gt;setCrystalType(parser.parseCrystalType());\n    de-&gt;setOffsetAngle(parser.parseOffsetAngle());\n    de-&gt;setStructureFactorReF0(parser.parseStructureFactorReF0());\n    de-&gt;setStructureFactorImF0(parser.parseStructureFactorImF0());\n    de-&gt;setStructureFactorReFH(parser.parseStructureFactorReFH());\n    de-&gt;setStructureFactorImFH(parser.parseStructureFactorImFH());\n    de-&gt;setStructureFactorReFHC(parser.parseStructureFactorReFHC());\n    de-&gt;setStructureFactorImFHC(parser.parseStructureFactorImFHC());\n    de-&gt;setUnitCellVolume(parser.parseUnitCellVolume());\n    de-&gt;setDSpacing2(parser.parseDSpacing2());\n}\n\nvoid getCylinder(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Cylinder);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setRadiusDirection(parser.parseBendingRadius());\n    de-&gt;setRadius(parser.parseRadius());\n    de-&gt;setGrazingIncAngle(parser.parseGrazingIncAngle());\n    de-&gt;setEntranceArmLength(parser.parseEntranceArmLength());\n    de-&gt;setExitArmLength(parser.parseExitArmLength());\n}\n\nvoid getEllipsoid(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Ellipsoid);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setShortHalfAxisB(parser.parseShortHalfAxisB());\n    de-&gt;setLongHalfAxisA(parser.parseLongHalfAxisA());\n    de-&gt;setDesignGrazingIncAngle(parser.parseDesignGrazingIncAngle());\n    de-&gt;setFigureRotation(parser.parseFigureRotation());\n    de-&gt;setParameterA11(parser.parseParameterA11());\n\n    de-&gt;setEntranceArmLength(parser.parseEntranceArmLength());\n    de-&gt;setExitArmLength(parser.parseExitArmLength());\n}\n\nvoid getParaboloid(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Paraboloid);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setArmLength(parser.parseArmLength());\n    de-&gt;setParameterP(parser.parseParameterP());\n    de-&gt;setParameterPType(parser.parseParameterPType());\n    de-&gt;setGrazingIncAngle(parser.parseGrazingIncAngle());\n    de-&gt;setParameterA11(parser.parseParameterA11());\n}\n\nvoid getGrating(xml::Parser parser, DesignElement* de) {\n    de-&gt;setBehaviourType(BehaviourType::Grating);\n    de-&gt;setVLSParameters(parser.parseVls());\n    de-&gt;setLineDensity(parser.parseLineDensity());\n    de-&gt;setOrderOfDiffraction(parser.parseOrderDiffraction());\n}\n\nvoid getPlaneGrating(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n\n    getGrating(parser, de);\n}\n\nvoid getSphereGrating(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Spherical);\n\n    de-&gt;setDeviationAngle(parser.parseDeviationAngle());\n    de-&gt;setEntranceArmLength(parser.parseEntranceArmLength());\n    de-&gt;setExitArmLength(parser.parseExitArmLength());\n    de-&gt;setRadius(parser.parseRadius());\n\n    getGrating(parser, de);\n}\n\nvoid getPlaneMirror(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n}\n\nvoid getSphereMirror(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Spherical);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setGrazingIncAngle(parser.parseGrazingIncAngle());\n    de-&gt;setEntranceArmLength(parser.parseEntranceArmLength());\n    de-&gt;setExitArmLength(parser.parseExitArmLength());\n    de-&gt;setRadius(parser.parseRadius());\n}\n\nvoid getToroidMirror(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Toroidal);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setShortRadius(parser.parseShortRadius());\n    de-&gt;setLongRadius(parser.parseLongRadius());\n}\n\nvoid getToroidalGrating(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Toroidal);\n    de-&gt;setBehaviourType(BehaviourType::Grating);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setShortRadius(parser.parseShortRadius());\n    de-&gt;setLongRadius(parser.parseLongRadius());\n\n    getGrating(parser, de);\n}\n\nvoid getRZP(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    CurvatureType curv = parser.parseCurvatureType();\n    if (curv == CurvatureType::Spherical) {  // special case of sphere\n        curv = CurvatureType::RzpSphere;\n    }\n    de-&gt;setCurvatureType(curv);\n    de-&gt;setBehaviourType(BehaviourType::Rzp);\n\n    de-&gt;setFresnelZOffset(parser.parseFresnelZOffset());\n    de-&gt;setDesignMeridionalExitArmLength(parser.parseExitArmLengthMer());\n    de-&gt;setDesignMeridionalEntranceArmLength(parser.parseEntranceArmLengthMer());\n    de-&gt;setDesignSagittalEntranceArmLength(parser.parseEntranceArmLengthSag());\n    de-&gt;setDesignSagittalExitArmLength(parser.parseExitArmLengthSag());\n    de-&gt;setDesignEnergy(parser.parseDesignEnergy());\n    de-&gt;setLongRadius(parser.parseLongRadius());\n    de-&gt;setDesignOrderOfDiffraction(parser.parseDesignOrderDiffraction());\n    de-&gt;setOrderOfDiffraction(parser.parseOrderDiffraction());\n    de-&gt;setDesignAlphaAngle(parser.parseDesignAlphaAngle());\n    de-&gt;setDesignBetaAngle(parser.parseDesignBetaAngle());\n    de-&gt;setImageType(parser.parseImageType());\n    de-&gt;setAdditionalOrder(parser.parseAdditionalOrder());\n    de-&gt;setShortRadius(parser.parseShortRadius());\n    de-&gt;setLongRadius(parser.parseLongRadius());\n}\n\nvoid getExpertsCubic(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Cubic);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setExpertsCubic(parser.parseCubicParameters());\n}\n\nvoid getExpertsOptics(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XZ);\n    de-&gt;setCurvatureType(CurvatureType::Quadric);\n    de-&gt;setBehaviourType(BehaviourType::Mirror);\n\n    getSurfaceCoating(parser, de);\n\n    de-&gt;setExpertsOptics(parser.parseQuadricParameters());\n}\n\nvoid getFoil(xml::Parser parser, DesignElement* de) {\n    setAllMandatory(parser, de, DesignPlane::XY);\n    de-&gt;setCurvatureType(CurvatureType::Plane);\n    de-&gt;setBehaviourType(BehaviourType::Foil);\n\n    de-&gt;setThicknessSubstrate(parser.parseThicknessSubstrate());\n    de-&gt;setRoughnessSubstrate(parser.parseRoughnessSubstrate());\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DesignSourceWriter_8h/","title":"File DesignSourceWriter.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; DesignSourceWriter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Beamline/Beamline.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> </ul>"},{"location":"rayxCore/DesignSourceWriter_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/DesignSourceWriter.h</code></p>"},{"location":"rayxCore/DesignSourceWriter_8h_source/","title":"File DesignSourceWriter.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; DesignSourceWriter.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;random&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Beamline/Beamline.h\"\n#include \"Core.h\"\n#include \"Element/Cutout.h\"\n\nnamespace rayx {\n\nvoid setAllMandatory(xml::Parser parser, DesignSource* ds) {\n    ds-&gt;setName(parser.name());\n    ds-&gt;setType(parser.type());\n    ds-&gt;setNumberOfRays(parser.parseNumberRays());\n    ds-&gt;setOrientation(parser.parseOrientation());\n    ds-&gt;setPosition(parser.parsePosition());\n}\n\nvoid setDefaultEnergy(xml::Parser parser, DesignSource* ds) {\n    ds-&gt;setEnergyDistributionType(parser.parseEnergyDistributionType());\n    ds-&gt;setEnergySpreadType(parser.parseEnergySpreadType());\n\n    if (ds-&gt;getEnergyDistributionType() == EnergyDistributionType::File) {\n        ds-&gt;setEnergyDistributionFile(parser.parseEnergyDistributionFile().generic_string());\n    } else {\n        ds-&gt;setEnergy(parser.parsePhotonEnergy());\n        ds-&gt;setEnergySpread(parser.parseEnergySpread());\n        if (ds-&gt;getEnergySpreadType() == SpreadType::SeparateEnergies) ds-&gt;setNumberOfSeparateEnergies(parser.parseNumberOfSeparateEnergies());\n    }\n}\n\nvoid setDefaultOrientation(xml::Parser parser, DesignSource* ds) {\n    ds-&gt;setHorDivergence(parser.parseHorDiv());\n    ds-&gt;setVerDivergence(parser.parseVerDiv());\n}\n\nvoid setDefaultPosition(xml::Parser parser, DesignSource* ds) {\n    ds-&gt;setSourceDepth(parser.parseSourceDepth());\n    ds-&gt;setSourceHeight(parser.parseSourceHeight());\n    ds-&gt;setSourceWidth(parser.parseSourceWidth());\n}\n\nvoid setStokes(xml::Parser parser, DesignSource* ds) {\n    ds-&gt;setStokeslin0(parser.parseLinearPol0());\n    ds-&gt;setStokeslin45(parser.parseLinearPol45());\n    ds-&gt;setStokescirc(parser.parseCircularPol());\n}\n\nvoid setPointSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n    setStokes(parser, ds);\n    setDefaultEnergy(parser, ds);\n\n    setDefaultPosition(parser, ds);\n    ds-&gt;setWidthDist(parser.parseSourceWidthDistribution());\n    ds-&gt;setHeightDist(parser.parseSourceHeightDistribution());\n\n    setDefaultOrientation(parser, ds);\n    ds-&gt;setHorDist(parser.parseHorDivDistribution());\n    ds-&gt;setVerDist(parser.parseVerDivDistribution());\n}\n\nvoid setMatrixSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n    setStokes(parser, ds);\n    setDefaultEnergy(parser, ds);\n    setDefaultPosition(parser, ds);\n    setDefaultOrientation(parser, ds);\n}\n\nvoid setDipoleSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n\n    ds-&gt;setEnergySpreadType(parser.parseEnergySpreadType());\n    ds-&gt;setPhotonFlux(parser.parsePhotonFlux());\n    ds-&gt;setElectronEnergyOrientation(parser.parseElectronEnergyOrientation());\n    ds-&gt;setElectronEnergy(parser.parseElectronEnergy());\n    ds-&gt;setEnergySpread(parser.parseEnergySpread());\n    ds-&gt;setBendingRadius(parser.parseBendingRadiusDouble());\n    ds-&gt;setSourceHeight(parser.parseSourceHeight());\n    ds-&gt;setSourceWidth(parser.parseSourceWidth());\n    ds-&gt;setVerEBeamDivergence(parser.parseVerEbeamDivergence());\n    ds-&gt;setEnergy(parser.parsePhotonEnergy());\n    ds-&gt;setEnergySpreadUnit(parser.parseEnergySpreadUnit());\n    ds-&gt;setEnergyDistributionType(parser.parseEnergyDistributionType());\n    ds-&gt;setHorDivergence(parser.parseHorDiv());\n}\n\nvoid setPixelSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n    setStokes(parser, ds);\n    setDefaultEnergy(parser, ds);\n    setDefaultPosition(parser, ds);\n    setDefaultOrientation(parser, ds);\n}\n\nvoid setCircleSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n    setStokes(parser, ds);\n    setDefaultEnergy(parser, ds);\n    setDefaultPosition(parser, ds);\n\n    ds-&gt;setNumOfCircles(parser.parseNumOfEquidistantCircles());\n    ds-&gt;setMaxOpeningAngle(parser.parseMaxOpeningAngle());\n    ds-&gt;setMinOpeningAngle(parser.parseMinOpeningAngle());\n    ds-&gt;setDeltaOpeningAngle(parser.parseDeltaOpeningAngle());\n}\n\nvoid setSimpleUndulatorSource(xml::Parser parser, DesignSource* ds) {\n    setAllMandatory(parser, ds);\n    setStokes(parser, ds);\n    setDefaultEnergy(parser, ds);\n\n    ds-&gt;setSourceDepth(parser.parseSourceDepth());\n\n    ds-&gt;setSigmaType(parser.parseSigmaType());\n\n    ds-&gt;setUndulatorLength(parser.parseUndulatorLength());\n    ds-&gt;setElectronSigmaX(parser.parseElectronSigmaX());\n    ds-&gt;setElectronSigmaXs(parser.parseElectronSigmaXs());\n    ds-&gt;setElectronSigmaY(parser.parseElectronSigmaY());\n    ds-&gt;setElectronSigmaYs(parser.parseElectronSigmaYs());\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Importer_8h/","title":"File Importer.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; Importer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"Beamline/Beamline.h\"</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Importer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/Importer.h</code></p>"},{"location":"rayxCore/Importer_8h_source/","title":"File Importer.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; Importer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n\n#include \"Beamline/Beamline.h\"\n#include \"Core.h\"\n\nnamespace rayx {\n\n// This is the central point where the beamline is loaded from an RML file.\n// Any future plans for other formats, will *not* use this Importer. It's intended for XML.\nRAYX_API Beamline importBeamline(const std::filesystem::path&amp;);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Locate_8h/","title":"File Locate.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; Locate.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Locate_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Locate_8h/#classes","title":"Classes","text":"Type Name class ResourceHandler <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/Locate.h</code></p>"},{"location":"rayxCore/Locate_8h_source/","title":"File Locate.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; Locate.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nclass RAYX_API ResourceHandler {\n  public:\n    static ResourceHandler&amp; getInstance() {\n        thread_local ResourceHandler instance;\n        return instance;\n    }\n\n    // Platform-specific implementations for resource path search\n    std::filesystem::path getExecutablePath();\n\n    // Retrieves a resource file's full path based on the relative path\n    std::filesystem::path getResourcePath(const std::filesystem::path&amp; relativePath);\n\n    // Retrieves a font file's full path based on the relative path\n    std::filesystem::path getFontPath(const std::filesystem::path&amp; relativePath);\n\n    // Adds a new lookup path where the handler will search for resources\n    void addLookUpPath(const std::filesystem::path&amp; path);\n\n  private:\n    ResourceHandler() = default;\n    bool fileExists(const std::string&amp; path);\n    bool fileExists(const std::filesystem::path&amp; path);\n    std::filesystem::path getFullPath(const std::filesystem::path&amp; baseDir, const std::filesystem::path&amp; relativePath);\n\n    std::vector&lt;std::filesystem::path&gt; lookUpPaths;  // Maintains insertion order\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/xml_8h/","title":"File xml.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; xml.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;rapidxml.hpp&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Angle.h\"</code></li> <li><code>#include \"Beamline/Definitions.h\"</code></li> <li><code>#include \"Beamline/EnergyDistribution.h\"</code></li> <li><code>#include \"Element/Coating.h\"</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> <li><code>#include \"Element/Surface.h\"</code></li> <li><code>#include \"Material/Material.h\"</code></li> <li><code>#include \"Shader/Constants.h\"</code></li> <li><code>#include \"Shader/LightSources/LightSource.h\"</code></li> <li><code>#include \"Shader/SlopeError.h\"</code></li> </ul>"},{"location":"rayxCore/xml_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace xml"},{"location":"rayxCore/xml_8h/#classes","title":"Classes","text":"Type Name struct Parser <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rml/xml.h</code></p>"},{"location":"rayxCore/xml_8h_source/","title":"File xml.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rml &gt; xml.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;filesystem&gt;\n#include &lt;glm.hpp&gt;\n#include &lt;optional&gt;\n#include &lt;rapidxml.hpp&gt;\n#include &lt;vector&gt;\n\n#include \"Angle.h\"\n#include \"Beamline/Definitions.h\"\n#include \"Beamline/EnergyDistribution.h\"\n#include \"Element/Coating.h\"\n#include \"Element/Cutout.h\"\n#include \"Element/Surface.h\"\n#include \"Material/Material.h\"\n#include \"Shader/Constants.h\"\n#include \"Shader/LightSources/LightSource.h\"\n#include \"Shader/SlopeError.h\"\n\nnamespace rayx {\n\n// forward declarations:\nclass EnergyDistribution;\nclass Group;\nenum class CentralBeamstop;\nenum class CurvatureType;\nenum class BehaviourType;\nenum class CylinderDirection;\nenum class FigureRotation;\nenum class GratingMount;\nenum class SourceDist;\nenum class ElectronEnergyOrientation;\nenum class EnergyDistributionType;\nenum class SourcePulseType;\nenum class EnergySpreadUnit;\nenum class SigmaType;\nenum class SpreadType;\nenum class ElementType;\nenum class CrystalType;\nenum class OffsetAngleType;  // TODO:see if this is needed\nenum class SurfaceCoatingType;\n\nnamespace xml {\n\n// These functions get a `paramname` argument and look for &lt;param\n// id=\"`paramname`\"&gt;...&lt;/param&gt; entries in the XML node to then return it's\n// content in the out-argument. They return `false` to express failure.\nbool param(const rapidxml::xml_node&lt;&gt;* node, const char* paramname, rapidxml::xml_node&lt;&gt;** out);\n\n// These call the above `param` function, and convert its output to the required type.\nbool paramDouble(const rapidxml::xml_node&lt;&gt;* node, const char* paramname, double* out);\nbool paramInt(const rapidxml::xml_node&lt;&gt;* node, const char* paramname, int* out);\nbool paramStr(const rapidxml::xml_node&lt;&gt;* node, const char* paramname, const char** out);\nbool paramDvec3(const rapidxml::xml_node&lt;&gt;* node, const char* paramname, glm::dvec3* out);\n\n// These functions parse more complex parts of beamline objects, and are used by multiple objects in their construction mechanism.\n// They itself use the above param* functions.\nbool paramSlopeError(const rapidxml::xml_node&lt;&gt;* node, SlopeError* out);\nbool paramVls(const rapidxml::xml_node&lt;&gt;* node, std::array&lt;double, 6&gt;* out);\nbool paramEnergyDistribution(const rapidxml::xml_node&lt;&gt;* node, const std::filesystem::path&amp; rmlFile, EnergyDistribution* out);\nbool paramMultilayer(const rapidxml::xml_node&lt;&gt;* node, Coating* out);\n\nstd::optional&lt;glm::dvec4&gt; paramPosition(const rapidxml::xml_node&lt;&gt;* node);\nstd::optional&lt;glm::dmat4x4&gt; paramOrientation(const rapidxml::xml_node&lt;&gt;* node);\n\nbool paramElectronEnergyOrientation(const rapidxml::xml_node&lt;&gt;* node, ElectronEnergyOrientation* out);\nbool paramSourcePulseType(const rapidxml::xml_node&lt;&gt;* node, SourcePulseType* out);\n\nbool paramMaterial(const rapidxml::xml_node&lt;&gt;* node, Material* out);\n\n// node needs to be a &lt;group&gt;-tag, output will be written to `out`.\nstd::optional&lt;Group&gt; parseGroup(rapidxml::xml_node&lt;&gt;* node);\n\n// The Parser gives you utility functions to construct your own objects from RML files.\nstruct RAYX_API Parser {\n    Parser(rapidxml::xml_node&lt;&gt;* node, std::filesystem::path rmlFile);\n\n    const char* name() const;\n\n    ElementType type() const;\n\n    // parsers for fundamental types\n    double parseDouble(const char* paramname) const;\n    int parseInt(const char* paramname) const;\n    const char* parseStr(const char* paramname) const;\n    glm::dvec3 parseDvec3(const char* paramname) const;\n\n    // parsers for derived parameters\n    SlopeError parseSlopeError() const;\n    std::array&lt;double, 6&gt; parseVls() const;\n    glm::dvec4 parsePosition() const;\n    glm::dmat4x4 parseOrientation() const;\n    Material parseMaterial() const;\n    Material parseMaterialCoating() const;\n    Cutout parseCutout(DesignPlane, std::string) const;\n    Surface::Quadric parseQuadricParameters() const;\n    Surface::Cubic parseCubicParameters() const;\n    ElectronEnergyOrientation parseElectronEnergyOrientation() const;\n    SourcePulseType parseSourcePulseType() const;\n    double parseImageType() const;\n    double parseAdditionalOrder() const;\n    Rad parseAzimuthalAngle() const;\n    std::filesystem::path parseEnergyDistributionFile() const;\n    Coating::MultilayerCoating parseCoating() const;\n\n    // Parsers for trivial derived parameters\n    // this allows for convenient type-safe access to the corresponding parameters.\n    inline int parseNumberRays() const { return parseInt(\"numberRays\"); }\n    inline double parseSourceWidth() const { return parseDouble(\"sourceWidth\"); }\n    inline double parseSourceHeight() const { return parseDouble(\"sourceHeight\"); }\n    inline double parseSourceDepth() const { return parseDouble(\"sourceDepth\"); }\n    inline double parseHorDiv() const { return parseDouble(\"horDiv\") / 1000.0; }\n    inline double parseVerDiv() const { return parseDouble(\"verDiv\") / 1000.0; }\n    inline SourceDist parseSourceWidthDistribution() const { return static_cast&lt;SourceDist&gt;(parseInt(\"sourceWidthDistribution\")); }\n    inline SourceDist parseSourceHeightDistribution() const { return static_cast&lt;SourceDist&gt;(parseInt(\"sourceHeightDistribution\")); }\n    inline SourceDist parseHorDivDistribution() const { return static_cast&lt;SourceDist&gt;(parseInt(\"horDivDistribution\")); }\n    inline SourceDist parseVerDivDistribution() const { return static_cast&lt;SourceDist&gt;(parseInt(\"verDivDistribution\")); }\n    inline int parseLinearPol0() const { return parseInt(\"linearPol_0\"); }\n    inline int parseLinearPol45() const { return parseInt(\"linearPol_45\"); }\n    inline int parseCircularPol() const { return parseInt(\"circularPol\"); }\n    inline double parseTotalWidth() const { return parseDouble(\"totalWidth\"); }\n    inline double parseTotalLength() const { return parseDouble(\"totalLength\"); }\n    inline double parseTotalHeight() const { return parseDouble(\"totalHeight\"); }\n    inline Rad parseGrazingIncAngle() const { return Deg(parseDouble(\"grazingIncAngle\")).toRad(); }\n    inline Rad parseDeviationAngle() const { return Deg(parseDouble(\"deviationAngle\")).toRad(); }\n    inline double parseArmLength() const { return parseDouble(\"armLength\"); }\n    inline double parseEntranceArmLength() const { return parseDouble(\"entranceArmLength\"); }\n    inline double parseExitArmLength() const { return parseDouble(\"exitArmLength\"); }\n    inline double parseEntranceArmLengthMer() const { return parseDouble(\"entranceArmLengthMer\"); }\n    inline double parseExitArmLengthMer() const { return parseDouble(\"exitArmLengthMer\"); }\n    inline double parseEntranceArmLengthSag() const { return parseDouble(\"entranceArmLengthSag\"); }\n    inline double parseExitArmLengthSag() const { return parseDouble(\"exitArmLengthSag\"); }\n    inline CentralBeamstop parseCentralBeamstop() const { return static_cast&lt;CentralBeamstop&gt;(parseInt(\"centralBeamstop\")); }\n    inline double parseTotalWidthStop() const { return parseDouble(\"stopWidth\"); }\n    inline double parseTotalHeightStop() const { return parseDouble(\"stopHeight\"); }\n    inline double parseOpeningWidth() const { return parseDouble(\"openingWidth\"); }\n    inline double parseOpeningHeight() const { return parseDouble(\"openingHeight\"); }\n    inline double parseOpeningShape() const { return parseDouble(\"openingShape\"); }\n    inline GratingMount parseGratingMount() const { return static_cast&lt;GratingMount&gt;(parseInt(\"gratingMount\")); }\n    inline double parseRadius() const { return parseDouble(\"radius\"); }\n    inline double parseDesignEnergy() const { return parseDouble(\"designEnergy\"); }\n    inline double parseLineDensity() const { return parseDouble(\"lineDensity\"); }\n    inline double parseOrderDiffraction() const { return parseDouble(\"orderDiffraction\"); }\n    inline double parseDesignEnergyMounting() const { return parseDouble(\"designEnergyMounting\"); }\n\n    inline CurvatureType parseCurvatureType() const { return static_cast&lt;CurvatureType&gt;(parseInt(\"curvatureType\")); }\n\n    inline double parseDesignOrderDiffraction() const { return parseDouble(\"designOrderDiffraction\"); }\n    inline Rad parseDesignAlphaAngle() const { return Deg(parseDouble(\"designAlphaAngle\")).toRad(); }\n    inline Rad parseDesignBetaAngle() const { return Deg(parseDouble(\"designBetaAngle\")).toRad(); }\n    inline double parseShortRadius() const { return parseDouble(\"shortRadius\"); }\n    inline double parseLongRadius() const { return parseDouble(\"longRadius\"); }\n    inline double parseFresnelZOffset() const { return parseDouble(\"FresnelZOffset\"); }\n    inline CylinderDirection parseBendingRadius() const { return static_cast&lt;CylinderDirection&gt;(parseInt(\"bendingRadius\")); }\n    inline double parseBendingRadiusDouble() const { return parseDouble(\"bendingRadius\"); }\n    inline double parseParameterA11() const { return parseDouble(\"parameter_a11\"); }\n    inline FigureRotation parseFigureRotation() const { return static_cast&lt;FigureRotation&gt;(parseInt(\"figureRotation\")); }\n    inline Rad parseDesignGrazingIncAngle() const { return Deg(parseDouble(\"designGrazingIncAngle\")).toRad(); }\n    inline double parseLongHalfAxisA() const { return parseDouble(\"longHalfAxisA\"); }\n    inline double parseShortHalfAxisB() const { return parseDouble(\"shortHalfAxisB\"); }\n    // if old ray ui file, need to recalculate position and orientation because\n    // those in rml file are wrong. not necessary when our recalculated position\n    // and orientation is stored\n    inline double parseDistancePreceding() const { return parseDouble(\"distancePreceding\"); }\n    inline double parseVerEbeamDivergence() const { return parseDouble(\"verEbeamDiv\"); }\n    inline double parseElectronEnergy() const { return parseDouble(\"electronEnergy\"); }\n    inline int parseAlignmentError() const { return parseInt(\"alignmentError\"); }\n    inline double parsePhotonFlux() const { return parseDouble(\"photonFlux\"); }\n    inline double parsePhotonEnergy() const { return parseDouble(\"photonEnergy\"); }\n    inline double parseEnergySpread() const { return parseDouble(\"energySpread\"); }\n    inline SpreadType parseEnergySpreadType() const { return static_cast&lt;SpreadType&gt;(parseInt(\"energySpreadType\")); }\n    inline EnergyDistributionType parseEnergyDistributionType() const {\n        return static_cast&lt;EnergyDistributionType&gt;(parseInt(\"energyDistributionType\"));\n    }\n    inline EnergySpreadUnit parseEnergySpreadUnit() const { return static_cast&lt;EnergySpreadUnit&gt;(parseInt(\"energySpreadUnit\")); }\n    inline int parseNumberOfSeparateEnergies() const { return parseInt(\"SeparateEnergies\"); }\n    inline int parseNumOfEquidistantCircles() const { return static_cast&lt;int&gt;(parseDouble(\"numberCircles\")); }\n    inline Rad parseMaxOpeningAngle() const { return parseDouble(\"maximumOpeningAngle\") / 1000.0; }\n    inline Rad parseMinOpeningAngle() const { return parseDouble(\"minimumOpeningAngle\") / 1000.0; }\n    inline Rad parseDeltaOpeningAngle() const { return parseDouble(\"deltaOpeningAngle\") / 1000.0; }\n\n    inline double parseParameterP() const { return parseDouble(\"parameter_P\"); }\n    inline double parseParameterPType() const { return parseDouble(\"parameter_P_type\"); }\n\n    inline SigmaType parseSigmaType() const { return static_cast&lt;SigmaType&gt;(parseInt(\"sigmaType\")); }\n    inline double parseUndulatorLength() const { return parseDouble(\"undulatorLength\"); }\n    inline double parseElectronSigmaX() const { return parseDouble(\"electronSigmaX\"); }\n    inline double parseElectronSigmaXs() const { return parseDouble(\"electronSigmaXs\"); }\n    inline double parseElectronSigmaY() const { return parseDouble(\"electronSigmaY\"); }\n    inline double parseElectronSigmaYs() const { return parseDouble(\"electronSigmaYs\"); }\n\n    inline CrystalType parseCrystalType() const { return static_cast&lt;CrystalType&gt;(parseInt(\"crystalType\")); }\n    inline std::string parseCrystalMaterial() const { return parseStr(\"crystalMaterial\"); }\n    inline OffsetAngleType parseOffsetAngleType() const { return static_cast&lt;OffsetAngleType&gt;(parseInt(\"offsetAngleType\")); }\n    inline Rad parseOffsetAngle() const { return parseInt(\"offsetAngle\"); }\n    inline double parseStructureFactorReF0() const { return parseDouble(\"structureFactorReF0\"); }\n    inline double parseStructureFactorImF0() const { return parseDouble(\"structureFactorImF0\"); }\n    inline double parseStructureFactorReFH() const { return parseDouble(\"structureFactorReFH\"); }\n    inline double parseStructureFactorImFH() const { return parseDouble(\"structureFactorImFH\"); }\n    inline double parseStructureFactorReFHC() const { return parseDouble(\"structureFactorReFHC\"); }\n    inline double parseStructureFactorImFHC() const { return parseDouble(\"structureFactorImFHC\"); }\n    inline double parseUnitCellVolume() const { return parseDouble(\"unitCellVolume\"); }\n    inline double parseDSpacing2() const { return parseDouble(\"dSpacing2\"); }\n    inline int parseProfileKind() const { return parseInt(\"profileKind\"); }\n\n    inline double parseThicknessSubstrate() const { return parseDouble(\"thicknessSubstrate\"); }\n    inline double parseRoughnessSubstrate() const { return parseDouble(\"roughnessSubstrate\"); }\n    inline double parseDensitySubstrate() const { return parseDouble(\"densitySubstrate\"); }\n\n    inline SurfaceCoatingType parseSurfaceCoatingType() const {\n        return static_cast&lt;SurfaceCoatingType&gt;(parseInt(\"surfaceCoating\"));\n    }  // 0 = substrate only, 1 = one coating, 2 = multiple coatings\n    inline double parseThicknessCoating() const { return parseDouble(\"thicknessCoating\"); }\n    inline double parseRoughnessCoating() const { return parseDouble(\"roughnessCoating\"); }\n\n    // the XML node of the object you intend to parse.\n    rapidxml::xml_node&lt;&gt;* node;\n\n    // the RML file we are currently parsing.\n    std::filesystem::path rmlFile;\n};\n\n}  // namespace xml\n\nusing DesignObject = xml::Parser;\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_956ee0b8d0170a9bc6fd4fec1af269d0/","title":"Dir Intern/rayx-core/src/Shader","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader</p>"},{"location":"rayxCore/dir_956ee0b8d0170a9bc6fd4fec1af269d0/#files","title":"Files","text":"Type Name file ApplySlopeError.h file Approx.h file Behave.h file Collision.h file Complex.h file Constants.h file Crystal.h file Cubic.h file CutoutFns.h file Diffraction.h file Efficiency.h file ElectricField.h file EventType.h file ImageType.h file InvocationState.h file LineDensity.h file Rand.h file Ray.h file RaysPtr.h file RecordEvent.h file Refrac.h file RefractiveIndex.h file SlopeError.h file SphericalCoords.h file Throw.h file Trace.h file Transmission.h file Utils.h"},{"location":"rayxCore/dir_956ee0b8d0170a9bc6fd4fec1af269d0/#directories","title":"Directories","text":"Type Name dir LightSources <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/</code></p>"},{"location":"rayxCore/ApplySlopeError_8h/","title":"File ApplySlopeError.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ApplySlopeError.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> </ul>"},{"location":"rayxCore/ApplySlopeError_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/ApplySlopeError.h</code></p>"},{"location":"rayxCore/ApplySlopeError_8h_source/","title":"File ApplySlopeError.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ApplySlopeError.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"InvocationState.h\"\n\nnamespace rayx {\n\nstruct Rand;\n\nRAYX_FN_ACC glm::dvec3 RAYX_API normalCartesian(glm::dvec3 normal, double x_rad, double z_rad);\n\nRAYX_FN_ACC glm::dvec3 RAYX_API normalCylindrical(glm::dvec3 normal, double x_rad, double z_rad);\n\nRAYX_FN_ACC glm::dvec3 applySlopeError(glm::dvec3 normal, SlopeError error, int O_type, Rand&amp; __restrict rand);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Approx_8h/","title":"File Approx.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Approx.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Approx_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Approx.h</code></p>"},{"location":"rayxCore/Approx_8h_source/","title":"File Approx.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Approx.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC double RAYX_API dpow(double a, int b);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Behave_8h/","title":"File Behave.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Behave.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Collision.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> <li><code>#include \"Ray.h\"</code></li> </ul>"},{"location":"rayxCore/Behave_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Behave.h</code></p>"},{"location":"rayxCore/Behave_8h_source/","title":"File Behave.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Behave.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Collision.h\"\n#include \"Core.h\"\n#include \"InvocationState.h\"\n#include \"Ray.h\"\n\nnamespace rayx {\n\n\nRAYX_FN_ACC void behaveCrystal(detail::Ray&amp; __restrict ray, const Behaviour::Crystal&amp; __restrict crystal, const CollisionPoint&amp; __restrict col);\nRAYX_FN_ACC void behaveSlit(detail::Ray&amp; __restrict ray, const Behaviour::Slit&amp; __restrict slit);\nRAYX_FN_ACC void behaveRZP(detail::Ray&amp; __restrict ray, const Behaviour::RZP&amp; __restrict rzp, const CollisionPoint&amp; __restrict col);\nRAYX_FN_ACC void behaveGrating(detail::Ray&amp; __restrict ray, const Behaviour::Grating&amp; __restrict grating, const CollisionPoint&amp; __restrict col);\nRAYX_FN_ACC void behaveMirror(detail::Ray&amp; __restrict ray, const CollisionPoint&amp; __restrict col, const Coating&amp; __restrict coating, int material,\n                              const int* __restrict materialIndices, const double* __restrict materialTable);\nRAYX_FN_ACC void behaveFoil(detail::Ray&amp; __restrict ray, const Behaviour::Foil&amp; __restrict foil, const CollisionPoint&amp; __restrict col, int material,\n                            const int* __restrict materialIndices, const double* __restrict materialTable);\nRAYX_FN_ACC void behaveImagePlane(detail::Ray&amp; __restrict ray);\nRAYX_FN_ACC void behave(detail::Ray&amp; __restrict ray, const CollisionPoint&amp; __restrict col, const OpticalElement&amp; __restrict element,\n                        const int* __restrict materialIndices, const double* __restrict materialTable);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Collision_8h/","title":"File Collision.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Collision.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> <li><code>#include \"Rand.h\"</code></li> <li><code>#include \"Ray.h\"</code></li> </ul>"},{"location":"rayxCore/Collision_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Collision_8h/#classes","title":"Classes","text":"Type Name struct CollisionPoint struct CollisionWithElement <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Collision.h</code></p>"},{"location":"rayxCore/Collision_8h_source/","title":"File Collision.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Collision.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n\n#include \"Core.h\"\n#include \"Element/Cutout.h\"\n#include \"InvocationState.h\"\n#include \"Rand.h\"\n#include \"Ray.h\"\n\nnamespace rayx {\n\nstruct RAYX_API CollisionPoint {\n    glm::dvec3 hitpoint;\n    glm::dvec3 normal;\n};\nstatic_assert(std::is_trivially_copyable_v&lt;CollisionPoint&gt;);\nusing OptCollisionPoint = std::optional&lt;CollisionPoint&gt;;\n\nstruct CollisionWithElement {\n    CollisionPoint point;\n    int elementIndex;\n};\nstatic_assert(std::is_trivially_copyable_v&lt;CollisionWithElement&gt;);\nusing OptCollisionWithElement = std::optional&lt;CollisionWithElement&gt;;\n\nRAYX_FN_ACC OptCollisionPoint getQuadricCollision(const glm::dvec3&amp; __restrict rayPosition, const glm::dvec3&amp; __restrict rayDirection,\n                                                  const Surface::Quadric&amp; __restrict quadric);\n\nRAYX_FN_ACC OptCollisionPoint getCubicCollision(const glm::dvec3&amp; __restrict rayPosition, const glm::dvec3&amp; __restrict rayDirection,\n                                                const Surface::Cubic&amp; __restrict cu);\n\nRAYX_FN_ACC OptCollisionPoint getToroidCollision(const glm::dvec3&amp; __restrict rayPosition, const glm::dvec3&amp; __restrict rayDirection,\n                                                 const Surface::Toroid&amp; __restrict toroid, bool isTriangul);\n\nRAYX_FN_ACC OptCollisionPoint RAYX_API findCollisionInElementCoordsWithoutSlopeError(const glm::dvec3&amp; __restrict rayPosition,\n                                                                                     const glm::dvec3&amp; __restrict rayDirection,\n                                                                                     const Surface&amp; __restrict surface,\n                                                                                     const Cutout&amp; __restrict cutout, bool isTriangul);\n\nRAYX_FN_ACC OptCollisionPoint findCollisionInElementCoords(const glm::dvec3&amp; __restrict rayPosition, const glm::dvec3&amp; __restrict rayDirection,\n                                                           const OpticalElement&amp; __restrict element, Rand&amp; __restrict rand);\n\nRAYX_FN_ACC OptCollisionWithElement findCollisionWithElements(glm::dvec3 rayPosition, glm::dvec3 rayDirection,\n                                                              const OpticalElement* __restrict elements, const ObjectTransform* __restrict,\n                                                              const int numSources, const int numElements, Rand&amp; __restrict rand);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Complex_8h/","title":"File Complex.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Complex.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include &lt;complex&gt;</code></li> </ul>"},{"location":"rayxCore/Complex_8h/#namespaces","title":"Namespaces","text":"Type Name namespace glm namespace rayx namespace complex <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Complex.h</code></p>"},{"location":"rayxCore/Complex_8h_source/","title":"File Complex.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Complex.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;glm.hpp&gt;\n\n#include \"Core.h\"\n\n#if defined(RAYX_CUDA_ENABLED)\n#include &lt;cuda/std/complex&gt;\n#else\n#include &lt;complex&gt;\n#endif\n\nnamespace rayx {\n\nnamespace complex {\ntemplate &lt;typename T&gt;\n#if defined(RAYX_CUDA_ENABLED)\nusing tcomplex = cuda::std::complex&lt;T&gt;;\n#else\nusing tcomplex = std::complex&lt;T&gt;;\n#endif\n\nusing Complex = tcomplex&lt;double&gt;;\n}  // namespace complex\n\nusing cvec2 = glm::tvec2&lt;complex::Complex&gt;;\nusing cvec3 = glm::tvec3&lt;complex::Complex&gt;;\nusing cmat3 = glm::tmat3x3&lt;complex::Complex&gt;;\nstatic_assert(std::is_default_constructible_v&lt;cvec2&gt;);\nstatic_assert(std::is_default_constructible_v&lt;cvec3&gt;);\nstatic_assert(std::is_default_constructible_v&lt;cmat3&gt;);\n\nnamespace complex {\n#if defined(RAYX_CUDA_ENABLED)\nusing cuda::std::abs;\nusing cuda::std::arg;\nusing cuda::std::conj;\nusing cuda::std::exp;\nusing cuda::std::log;\nusing cuda::std::log10;\nusing cuda::std::norm;\nusing cuda::std::polar;\nusing cuda::std::pow;\nusing cuda::std::proj;\nusing cuda::std::real;\nusing cuda::std::sqrt;\n\nusing cuda::std::acos;\nusing cuda::std::asin;\nusing cuda::std::atan;\nusing cuda::std::cos;\nusing cuda::std::sin;\nusing cuda::std::tan;\n\nusing cuda::std::acosh;\nusing cuda::std::asinh;\nusing cuda::std::atanh;\nusing cuda::std::cosh;\nusing cuda::std::sinh;\nusing cuda::std::tanh;\n#else\nusing std::abs;\nusing std::arg;\nusing std::conj;\nusing std::exp;\nusing std::log;\nusing std::log10;\nusing std::norm;\nusing std::polar;\nusing std::pow;\nusing std::proj;\nusing std::real;\nusing std::sqrt;\n\nusing std::acos;\nusing std::asin;\nusing std::atan;\nusing std::cos;\nusing std::sin;\nusing std::tan;\n\nusing std::acosh;\nusing std::asinh;\nusing std::atanh;\nusing std::cosh;\nusing std::sinh;\nusing std::tanh;\n#endif\n}  // namespace complex\n\n// add some helper function for glm::tvec of complex\nnamespace complex {\nRAYX_FN_ACC\ninline glm::dvec2 abs(cvec2 v) { return glm::dvec2(abs(v.x), abs(v.y)); }\n\nRAYX_FN_ACC\ninline glm::dvec3 abs(cvec3 v) { return glm::dvec3(abs(v.x), abs(v.y), abs(v.z)); }\n\nRAYX_FN_ACC\ninline glm::dvec2 arg(cvec2 v) { return glm::dvec2(arg(v.x), arg(v.y)); }\n\nRAYX_FN_ACC\ninline glm::dvec3 arg(cvec3 v) { return glm::dvec3(arg(v.x), arg(v.y), arg(v.z)); }\n\nRAYX_FN_ACC\ninline cvec2 polar(glm::dvec2 mag, glm::dvec2 theta) { return cvec2(polar(mag.x, theta.x), polar(mag.y, theta.y)); }\n\nRAYX_FN_ACC\ninline cvec3 polar(glm::dvec3 mag, glm::dvec3 theta) { return cvec3(polar(mag.x, theta.x), polar(mag.y, theta.y), polar(mag.z, theta.z)); }\n}  // namespace complex\n\n}  // namespace rayx\n\nnamespace glm {\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; v, T scalar) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(v.x * scalar, v.y * scalar, v.z * scalar);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(vec&lt;3, T, Q&gt; const&amp; v, rayx::complex::tcomplex&lt;T&gt; scalar) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(v.x * scalar, v.y * scalar, v.z * scalar);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; v,\n                                                                                 rayx::complex::tcomplex&lt;T&gt; scalar) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(v.x * scalar, v.y * scalar, v.z * scalar);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(T scalar, vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; v) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(scalar * v.x, scalar * v.y, scalar * v.z);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(rayx::complex::tcomplex&lt;T&gt; scalar, vec&lt;3, T, Q&gt; const&amp; v) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(scalar * v.x, scalar * v.y, scalar * v.z);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(rayx::complex::tcomplex&lt;T&gt; scalar,\n                                                                                 vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; v) {\n    return vec&lt;3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;(scalar * v.x, scalar * v.y, scalar * v.z);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::col_type operator*(\n    mat&lt;3, 3, T, Q&gt; const&amp; m, typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::row_type const&amp; v) {\n    return typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::col_type(\n        m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z, m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z, m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::row_type operator*(\n    typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::col_type const&amp; v, mat&lt;3, 3, T, Q&gt; const&amp; m) {\n    return typename mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt;::row_type(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z, m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z, m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(mat&lt;3, 3, T, Q&gt; const&amp; m1,\n                                                                                    mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; m2) {\n    using namespace rayx::complex;\n\n    T const SrcA00 = m1[0][0];\n    T const SrcA01 = m1[0][1];\n    T const SrcA02 = m1[0][2];\n    T const SrcA10 = m1[1][0];\n    T const SrcA11 = m1[1][1];\n    T const SrcA12 = m1[1][2];\n    T const SrcA20 = m1[2][0];\n    T const SrcA21 = m1[2][1];\n    T const SrcA22 = m1[2][2];\n\n    tcomplex&lt;T&gt; const SrcB00 = m2[0][0];\n    tcomplex&lt;T&gt; const SrcB01 = m2[0][1];\n    tcomplex&lt;T&gt; const SrcB02 = m2[0][2];\n    tcomplex&lt;T&gt; const SrcB10 = m2[1][0];\n    tcomplex&lt;T&gt; const SrcB11 = m2[1][1];\n    tcomplex&lt;T&gt; const SrcB12 = m2[1][2];\n    tcomplex&lt;T&gt; const SrcB20 = m2[2][0];\n    tcomplex&lt;T&gt; const SrcB21 = m2[2][1];\n    tcomplex&lt;T&gt; const SrcB22 = m2[2][2];\n\n    return mat&lt;3, 3, tcomplex&lt;T&gt;, Q&gt;{\n        SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02, SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02,\n        SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02, SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12,\n        SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12, SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12,\n        SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22, SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22,\n        SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22,\n    };\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; m1,\n                                                                                    mat&lt;3, 3, T, Q&gt; const&amp; m2) {\n    using namespace rayx::complex;\n\n    tcomplex&lt;T&gt; const SrcA00 = m1[0][0];\n    tcomplex&lt;T&gt; const SrcA01 = m1[0][1];\n    tcomplex&lt;T&gt; const SrcA02 = m1[0][2];\n    tcomplex&lt;T&gt; const SrcA10 = m1[1][0];\n    tcomplex&lt;T&gt; const SrcA11 = m1[1][1];\n    tcomplex&lt;T&gt; const SrcA12 = m1[1][2];\n    tcomplex&lt;T&gt; const SrcA20 = m1[2][0];\n    tcomplex&lt;T&gt; const SrcA21 = m1[2][1];\n    tcomplex&lt;T&gt; const SrcA22 = m1[2][2];\n\n    T const SrcB00 = m2[0][0];\n    T const SrcB01 = m2[0][1];\n    T const SrcB02 = m2[0][2];\n    T const SrcB10 = m2[1][0];\n    T const SrcB11 = m2[1][1];\n    T const SrcB12 = m2[1][2];\n    T const SrcB20 = m2[2][0];\n    T const SrcB21 = m2[2][1];\n    T const SrcB22 = m2[2][2];\n\n    return mat&lt;3, 3, tcomplex&lt;T&gt;, Q&gt;{\n        SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02, SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02,\n        SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02, SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12,\n        SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12, SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12,\n        SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22, SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22,\n        SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22,\n    };\n}\n\ntemplate &lt;typename T, qualifier Q&gt;\nGLM_FUNC_QUALIFIER GLM_CONSTEXPR mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; operator*(mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; m1,\n                                                                                    mat&lt;3, 3, rayx::complex::tcomplex&lt;T&gt;, Q&gt; const&amp; m2) {\n    using namespace rayx::complex;\n\n    tcomplex&lt;T&gt; const SrcA00 = m1[0][0];\n    tcomplex&lt;T&gt; const SrcA01 = m1[0][1];\n    tcomplex&lt;T&gt; const SrcA02 = m1[0][2];\n    tcomplex&lt;T&gt; const SrcA10 = m1[1][0];\n    tcomplex&lt;T&gt; const SrcA11 = m1[1][1];\n    tcomplex&lt;T&gt; const SrcA12 = m1[1][2];\n    tcomplex&lt;T&gt; const SrcA20 = m1[2][0];\n    tcomplex&lt;T&gt; const SrcA21 = m1[2][1];\n    tcomplex&lt;T&gt; const SrcA22 = m1[2][2];\n\n    tcomplex&lt;T&gt; const SrcB00 = m2[0][0];\n    tcomplex&lt;T&gt; const SrcB01 = m2[0][1];\n    tcomplex&lt;T&gt; const SrcB02 = m2[0][2];\n    tcomplex&lt;T&gt; const SrcB10 = m2[1][0];\n    tcomplex&lt;T&gt; const SrcB11 = m2[1][1];\n    tcomplex&lt;T&gt; const SrcB12 = m2[1][2];\n    tcomplex&lt;T&gt; const SrcB20 = m2[2][0];\n    tcomplex&lt;T&gt; const SrcB21 = m2[2][1];\n    tcomplex&lt;T&gt; const SrcB22 = m2[2][2];\n\n    return mat&lt;3, 3, tcomplex&lt;T&gt;, Q&gt;{\n        SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02, SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02,\n        SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02, SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12,\n        SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12, SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12,\n        SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22, SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22,\n        SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22,\n    };\n}\n\n}  // namespace glm\n</code></pre>"},{"location":"rayxCore/Constants_8h/","title":"File Constants.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Constants.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"EventType.h\"</code></li> <li><code>#include \"ImageType.h\"</code></li> </ul>"},{"location":"rayxCore/Constants_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Constants.h</code></p>"},{"location":"rayxCore/Constants_8h_source/","title":"File Constants.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Constants.h</p> <p>Go to the documentation of this file</p> <pre><code>// The shader-internal constants are mostly defined in this file.\n\n#pragma once\n\n#include \"Core.h\"\n#include \"EventType.h\"\n#include \"ImageType.h\"\n\nnamespace rayx {\n\nconstexpr double INV_NM_TO_EVOLT = 1239.841984332002622;\n\nconstexpr double PI = 3.14159265358979323846264338327950;\n// 141592653589793238462643383279502884197169399\n\n// DipoleSource Constants\n\nconstexpr double ELECTRON_VOLT = 1.602176634e-19;\n\nconstexpr double SPEED_OF_LIGHT = 299792458;  // Checked 2019-7-25, PB, NIST (exact): speed of light in vacuo [m/s]\n\nconstexpr double ELEMENTARY_CHARGE = 1.602176634e-19;  // Checked 2019-7-25, PB, NIST (exact): minus charge of electron [As] or [C]\n\nconstexpr double PLANCK = 6.62607015e-34;  // Checked 2019-7-25, PB, NIST (exact): Planck constant [Js]\n\nconstexpr double PLANCK_BAR = PLANCK / (2 * PI);\n\nconstexpr double ELECTRON_MASS = 9.1093837015e-31;  // Checked 2019-7-25, PB, NIST: mass of electron [kg];\n\nconstexpr double FACTOR_ELECTRON_ENERGY_SC = 1957;\n\nconstexpr double FINE_STRUCTURE_CONSTANT = 7.2973525693e-3;  // Checked 2020-2-18, PB, NIST: fine-structure constant, no units\n\nconstexpr double ELECTRIC_PERMITTIVITY = 8.8541878128e-12;  // Checked 2019-7-25, PB, NIST: dielectricity of vacuum, or vacuum electric permittivity\n                                                            // [As/Vm] or [F/m]; Standard uncertainty: 0.0000000013e-12\n\nconstexpr double FACTOR_SCHWINGER_RAY = 1.2556937e15;\n\nconstexpr double ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT = 2.6544187279929558624e-3;\n\nconstexpr double ELECTRON_RADIUS = 2.8179403205e-6;  // Classical electron radius (nm)\n// constexpr double ELECTRON_RADIUS = (ELEMENTARY_CHARGE / (SPEED_OF_LIGHT * SPEED_OF_LIGHT)) * 1.e9;  // Classical electron radius in nm\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Crystal_8h/","title":"File Crystal.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Crystal.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"Complex.h\"</code></li> <li><code>#include \"Constants.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Utils.h\"</code></li> </ul>"},{"location":"rayxCore/Crystal_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Crystal.h</code></p>"},{"location":"rayxCore/Crystal_8h_source/","title":"File Crystal.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Crystal.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#include \"Complex.h\"\n#include \"Constants.h\"\n#include \"Core.h\"\n#include \"Utils.h\"\n\nnamespace rayx {\n\n// **********************************************************\n// Function to calculate the local normal incidence angle theta\n// from the direction cosines of the surface normal and the ray.\n// The **negative** normal vector is used.\n// Input:\n//   al, am, an - direction cosines of the surface normal\n//   fx, fy, fz - direction cosines of the incoming ray\n// Output:\n//   returns theta - the angle of incidence in radians\n// **********************************************************\nRAYX_FN_ACC\ninline double getTheta(const glm::dvec3&amp; __restrict rayDirection, const glm::dvec3&amp; __restrict normal, double offsetAngle) {\n    double al = normal[0];\n    double am = normal[1];\n    double an = normal[2];\n\n    double fx = rayDirection[0];\n    double fy = rayDirection[1];\n    double fz = rayDirection[2];\n\n    // Normalize incoming ray vector\n    double fn = complex::sqrt(fx * fx + fy * fy + fz * fz);\n    if (fn == 0.0) fn = 1.0;\n    fx /= fn;\n    fy /= fn;\n    fz /= fn;\n\n    // Dot product of normalized ray and surface normal\n    double ar = fx * al + fy * am + fz * an;\n\n    // Clamp ar to the range [-1.0, 1.0] since std::clamp is not supported in CUDA\n    if (ar &lt; -1.0) {\n        ar = -1.0;\n    } else if (ar &gt; 1.0) {\n        ar = 1.0;\n    }\n\n    double theta = complex::acos(ar) - PI / 2;\n    theta        = theta + offsetAngle;\n    return theta;  // TODO Fanny check how to correct this\n}\n\nRAYX_FN_ACC\ninline double getBraggAngle(double energy, double dSpacing2) {\n    int order           = 1;\n    double wavelength   = energyToWaveLength(energy);\n    double theta_factor = (order * wavelength) / dSpacing2;\n\n    // Check for physical validity\n    if (theta_factor &gt; 1.0) {\n        return -1.0;  // No reflection possible\n    }\n\n    double theta = asin(theta_factor);  // In radians\n    return theta;\n}\n\nRAYX_FN_ACC\ninline double getAsymmetryFactor(double braggAngle, double alpha) {\n    double numerator   = complex::sin(braggAngle - alpha);\n    double denominator = complex::sin(braggAngle + alpha);\n\n    if (denominator == 0.0) return 0.0;  // avoid division by zero\n\n    return numerator / denominator;\n}\n\nRAYX_FN_ACC\ninline double getDiffractionPrefactor(double wavelength, double unitCellVolume) {\n    // Avoid division by zero\n    if (wavelength &lt;= 0.0 || unitCellVolume &lt;= 0.0) { return 0.0; }\n    double result = (ELECTRON_RADIUS * wavelength * wavelength) / PI / unitCellVolume;\n    return result;\n}\n\nRAYX_FN_ACC\ninline complex::Complex computeEta(double theta, double bragg, double asymmetry, double structureFactorReFH, double structureFactorImFH,\n                                   double structureFactorReFHC, double structureFactorImFHC, double structureFactorReF0, double structureFactorImF0,\n                                   double polFactor, double gamma) {\n    // Calculate numerator terms\n    complex::Complex top_term1 = asymmetry * (theta - bragg) * sin(2.0 * theta);\n    complex::Complex top_term2 = 0.5 * gamma * complex::Complex(structureFactorReF0, structureFactorImF0) * (1.0 - asymmetry);\n    complex::Complex top       = top_term1 + top_term2;\n\n    // Calculate denominator terms\n    double bottom_term1 = gamma * polFactor;\n    double bottom_term2 = sqrt(fabs(asymmetry));\n    complex::Complex FH(structureFactorReFH, structureFactorImFH);\n    complex::Complex FHC(structureFactorReFHC, structureFactorImFHC);\n    complex::Complex bottom_term3 = sqrt(FH * FHC);\n\n    complex::Complex bottom = bottom_term1 * bottom_term2 * bottom_term3;\n\n    // Final eta calculation\n    complex::Complex eta = top / bottom;\n    return eta;\n}\n\nRAYX_FN_ACC\ninline complex::Complex computeR(complex::Complex eta, double structureFactorReFH, double structureFactorImFH, double structureFactorReFHC,\n                                 double structureFactorImFHC) {\n    complex::Complex one(1.0, 0.0);\n    complex::Complex FH(structureFactorReFH, structureFactorImFH);\n    complex::Complex FHC(structureFactorReFHC, structureFactorImFHC);\n\n    if (complex::real(eta) &gt; 0.0) {\n        return (eta - sqrt(eta * eta - one)) * sqrt(FH / FHC);\n    } else {\n        return (eta + sqrt(eta * eta - one)) * sqrt(FH / FHC);\n    }\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Cubic_8h/","title":"File Cubic.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Cubic.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Ray.h\"</code></li> </ul>"},{"location":"rayxCore/Cubic_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Cubic.h</code></p>"},{"location":"rayxCore/Cubic_8h_source/","title":"File Cubic.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Cubic.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"Ray.h\"\n\nnamespace rayx {\n\n// TODO: doku\nRAYX_FN_ACC glm::dvec3 RAYX_API cubicPosition(const glm::dvec3&amp; __restrict rayPosition, const double alpha);\n\nRAYX_FN_ACC glm::dvec3 RAYX_API cubicDirection(const glm::dvec3&amp; __restrict rayDirection, double alph);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/CutoutFns_8h/","title":"File CutoutFns.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; CutoutFns.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include \"Element/Cutout.h\"</code></li> </ul>"},{"location":"rayxCore/CutoutFns_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/CutoutFns.h</code></p>"},{"location":"rayxCore/CutoutFns_8h_source/","title":"File CutoutFns.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; CutoutFns.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n\n#include \"Element/Cutout.h\"\n\nnamespace rayx {\n\n// checks whether the point (x, z) is within the cutout.\nRAYX_FN_ACC bool RAYX_API inCutout(Cutout cutout, double x, double z);\n\n// returns a matrix M where (M[i].x, M[i].z) are the key points of our cutout.\n// The key points are typically points on the boundary of the cutout.\nRAYX_FN_ACC glm::dmat4 RAYX_API keyCutoutPoints(Cutout cutout);\n\n// returns width and length of the bounding box.\nRAYX_FN_ACC glm::dvec2 RAYX_API cutoutBoundingBox(Cutout cutout);\n\n// checks whether c1 is a subset of c2, and prints an error otherwise.\n// might not find all subset-violations, but should find most of them.\n// (might not find all Ellipsoid vs Trapezoid violations)\nRAYX_FN_ACC void RAYX_API assertCutoutSubset(Cutout c1, Cutout c2);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Diffraction_8h/","title":"File Diffraction.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Diffraction.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> </ul>"},{"location":"rayxCore/Diffraction_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Diffraction.h</code></p>"},{"location":"rayxCore/Diffraction_8h_source/","title":"File Diffraction.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Diffraction.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"InvocationState.h\"\n\nnamespace rayx {\n\nstruct Rand;\n\n// Calculates the factorial of n: n!\nRAYX_FN_ACC double RAYX_API fact(int n);\n\nRAYX_FN_ACC double RAYX_API bessel1(double v);\n\nRAYX_FN_ACC void bessel_diff(double radius, double wl, double&amp; dphi, double&amp; dpsi, Rand&amp; rand);\n\nRAYX_FN_ACC void fraun_diff(double dim, double wl, double&amp; dAngle, Rand&amp; rand);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Efficiency_8h/","title":"File Efficiency.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Efficiency.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Constants.h\"</code></li> <li><code>#include \"ElectricField.h\"</code></li> <li><code>#include \"Rand.h\"</code></li> </ul>"},{"location":"rayxCore/Efficiency_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Efficiency_8h/#classes","title":"Classes","text":"Type Name struct ComplexFresnelCoeffs struct FresnelCoeffs <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Efficiency.h</code></p>"},{"location":"rayxCore/Efficiency_8h_source/","title":"File Efficiency.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Efficiency.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Constants.h\"\n#include \"ElectricField.h\"\n#include \"Rand.h\"\n\nnamespace rayx {\n\nstruct FresnelCoeffs {\n    double s;\n    double p;\n};\n\nstruct ComplexFresnelCoeffs {\n    complex::Complex s;\n    complex::Complex p;\n};\n\nRAYX_FN_ACC inline double angleBetweenUnitVectors(glm::dvec3 a, glm::dvec3 b) { return glm::acos(glm::dot(a, b)); }\n\nRAYX_FN_ACC\ninline complex::Complex calcRefractAngle(const complex::Complex incidentAngle, const complex::Complex iorI, const complex::Complex iorT) {\n    return complex::asin((iorI / iorT) * complex::sin(incidentAngle));\n}\n\nRAYX_FN_ACC\ninline complex::Complex calcBrewstersAngle(const complex::Complex iorI, const complex::Complex iorT) { return complex::atan(iorT / iorI); }\n\nRAYX_FN_ACC\ninline complex::Complex calcCriticalAngle(const complex::Complex iorI, const complex::Complex iorT) { return complex::asin(iorT / iorI); }\n\nRAYX_FN_ACC\ninline ComplexFresnelCoeffs calcReflectAmplitude(const complex::Complex incidentAngle, const complex::Complex refractAngle,\n                                                 const complex::Complex iorI, const complex::Complex iorT) {\n    const auto cos_i = complex::cos(incidentAngle);\n    const auto cos_t = complex::cos(refractAngle);\n\n    const auto s = (iorI * cos_i - iorT * cos_t) / (iorI * cos_i + iorT * cos_t);\n    const auto p = (iorT * cos_i - iorI * cos_t) / (iorT * cos_i + iorI * cos_t);\n\n    return {\n        .s = s,\n        .p = p,\n    };\n}\n\nRAYX_FN_ACC\ninline ComplexFresnelCoeffs calcRefractAmplitude(const complex::Complex incidentAngle, const complex::Complex refractAngle,\n                                                 const complex::Complex iorI, const complex::Complex iorT) {\n    const auto cos_i = complex::cos(incidentAngle);\n    const auto cos_t = complex::cos(refractAngle);\n\n    const auto s = (2.0 * iorI * cos_i) / (iorI * cos_i + iorT * cos_t);\n    const auto p = (2.0 * iorI * cos_i) / (iorT * cos_i + iorI * cos_t);\n\n    return {\n        .s = s,\n        .p = p,\n    };\n}\n\nRAYX_FN_ACC\ninline FresnelCoeffs calcReflectIntensity(const ComplexFresnelCoeffs reflectAmplitude) {\n    const auto s = (reflectAmplitude.s * complex::conj(reflectAmplitude.s)).real();\n    const auto p = (reflectAmplitude.p * complex::conj(reflectAmplitude.p)).real();\n\n    return {\n        .s = s,\n        .p = p,\n    };\n}\n\nRAYX_FN_ACC\ninline FresnelCoeffs calcRefractIntensity(const ComplexFresnelCoeffs refract_amplitude, const complex::Complex incidentAngle,\n                                          const complex::Complex refractAngle, const complex::Complex iorI, const complex::Complex iorT) {\n    const auto r = ((iorT * complex::cos(refractAngle)) / (iorI * complex::cos(incidentAngle))).real();\n\n    const auto s = r * (refract_amplitude.s * complex::conj(refract_amplitude.s)).real();\n    const auto p = r * (refract_amplitude.p * complex::conj(refract_amplitude.p)).real();\n\n    return {\n        .s = s,\n        .p = p,\n    };\n}\n\nRAYX_FN_ACC\ninline cmat3 calcJonesMatrix(const ComplexFresnelCoeffs amplitude) {\n    return {\n        amplitude.s, 0, 0, 0, amplitude.p, 0, 0, 0, 1,\n    };\n}\n\nRAYX_FN_ACC\ninline cmat3 calcPolaririzationMatrix(const glm::dvec3 incidentVec, const glm::dvec3 reflectOrRefractVec, const glm::dvec3 normalVec,\n                                      const ComplexFresnelCoeffs amplitude) {\n    // TODO: cross product is not numerically stable here, if indicentVec == reflectOrRefractVec\n    // we dont need the lenght of the vector resulting from the cross product, but only the direciton.\n    // this may could be done by calculation angles instead of a vector.\n    // fixing this removes the check in interceptReflect, that specializes for normal incidence\n    glm::dvec3 s0;\n    if (incidentVec == glm::dvec3(0.0, 0.0, 1.0)) {\n        s0 = glm::dvec3(1.0, 0.0, 0.0);  // beliebig orthogonal zu (0,0,-1)\n    } else {\n        s0 = glm::normalize(glm::cross(incidentVec, -normalVec));\n    }\n    const auto s1 = s0;\n    const auto p0 = glm::cross(incidentVec, s0);\n    const auto p1 = glm::cross(reflectOrRefractVec, s0);\n\n    const auto out = glm::dmat3(s1, p1, reflectOrRefractVec);\n\n    const auto in = glm::dmat3(s0.x, p0.x, incidentVec.x, s0.y, p0.y, incidentVec.y, s0.z, p0.z, incidentVec.z);\n\n    const auto jonesMatrix = calcJonesMatrix(amplitude);\n\n    return out * jonesMatrix * in;\n}\n\nRAYX_FN_ACC\ninline cmat3 calcPolaririzationMatrixFoil(const glm::dvec3 incidentVec, const glm::dvec3 normalVec, const ComplexFresnelCoeffs amplitude) {\n    glm::dvec3 s0;\n    if (glm::length(glm::cross(incidentVec, normalVec)) &lt; 1e-10) {\n        if (std::abs(incidentVec.x) &gt; 1e-6) {\n            s0 = glm::normalize(glm::dvec3(-incidentVec.y, incidentVec.x, 0.0));\n        } else {\n            s0 = glm::normalize(glm::dvec3(0.0, -incidentVec.z, incidentVec.y));\n        }\n    } else {\n        s0 = glm::normalize(glm::cross(incidentVec, normalVec));\n    }\n\n    const glm::dvec3 p0 = glm::normalize(glm::cross(incidentVec, s0));\n\n    const glm::dmat3 in = glm::dmat3(s0.x, p0.x, incidentVec.x, s0.y, p0.y, incidentVec.y, s0.z, p0.z, incidentVec.z);\n\n    const cmat3 jonesMatrix = calcJonesMatrix(amplitude);\n\n    const glm::dmat3 out = glm::transpose(in);\n\n    return out * jonesMatrix * in;\n}\n\nRAYX_FN_ACC\ninline cmat3 calcReflectPolarizationMatrixAtNormalIncidence(const ComplexFresnelCoeffs amplitude) {\n    // since no plane of incidence is defined at normal incidence,\n    // s and p components are equal and only contain the base reflectivity and a phase shift of 180 degrees\n    // here we apply the base reflectivity and phase shift independent of the ray direction to all components\n    return {\n        amplitude.s, 0, 0, 0, amplitude.s, 0, 0, 0, amplitude.s,\n    };\n}\n\n// Berechnet die komplexe Reflexionsamplitude f\u00fcr eine einzelne d\u00fcnne Schicht (ohne Rauigkeit)\nRAYX_FN_ACC\ninline ComplexFresnelCoeffs computeSingleCoatingReflectance(const complex::Complex incidentAngle, const double wavelength, const double thickness,\n                                                            const complex::Complex iorI,  // n0: z.\u202fB. Vakuum\n                                                            const complex::Complex iorC,  // n1: Beschichtung\n                                                            const complex::Complex iorS   // n2: Substrat\n) {\n    // Winkel in der Beschichtung und im Substrat\n    const auto theta1 = calcRefractAngle(incidentAngle, iorI, iorC);\n    const auto theta2 = calcRefractAngle(theta1, iorC, iorS);\n\n    // Fresnel\u2011Reflexion an beiden Grenzfl\u00e4chen\n    auto r01 = calcReflectAmplitude(incidentAngle, theta1, iorI, iorC);\n    auto r12 = calcReflectAmplitude(theta1, theta2, iorC, iorS);\n\n    // Phasenverschiebung im Film\n    const auto delta = (2.0 * PI / wavelength) * iorC * complex::cos(theta1) * thickness;\n    const auto phase = complex::exp(complex::Complex(0.0, 2.0) * delta);\n\n    // Interferenzformel (Parratt f\u00fcr 1 Schicht)\n    const auto r_s = (r01.s + r12.s * phase) / (complex::Complex(1.0) + r01.s * r12.s * phase);\n    const auto r_p = (r01.p + r12.p * phase) / (complex::Complex(1.0) + r01.p * r12.p * phase);\n\n    return {r_s, r_p};\n}\n\nRAYX_FN_ACC\ninline ComplexFresnelCoeffs computeMultilayerReflectance(\n    const complex::Complex incidentAngle, const double wavelength, int numLayers,\n    const double* __restrict thicknesses,    // L\u00e4ngen: numLayers\n    const complex::Complex* __restrict iors  // L\u00e4ngen: numLayers + 2 (Vakuum + Schichten + Substrat)\n) {\n    constexpr int MAX_ANGLES = 18;  // unterst\u00fctzt bis zu 16 Schichten\n    complex::Complex thetas[MAX_ANGLES];\n\n    // Einfallswinkel in den einzelnen Schichten\n    thetas[0] = incidentAngle;\n    for (int i = 1; i &lt;= numLayers + 1; ++i) { thetas[i] = calcRefractAngle(thetas[i - 1], iors[i - 1], iors[i]); }\n\n    // Startwert: Reflexion an Substratgrenze\n    ComplexFresnelCoeffs r = calcReflectAmplitude(thetas[numLayers], thetas[numLayers + 1], iors[numLayers], iors[numLayers + 1]);\n\n    // Parratt-Rekursion von unten nach oben\n    for (int j = numLayers - 1; j &gt;= 0; --j) {\n        const auto delta = (2.0 * PI / wavelength) * iors[j + 1] * complex::cos(thetas[j + 1]) * thicknesses[j];\n        const auto phase = complex::exp(complex::Complex(0.0, 2.0) * delta);\n\n        const auto r_j = calcReflectAmplitude(thetas[j], thetas[j + 1], iors[j], iors[j + 1]);\n\n        r.s = (r_j.s + r.s * phase) / (complex::Complex(1.0) + r_j.s * r.s * phase);\n        r.p = (r_j.p + r.p * phase) / (complex::Complex(1.0) + r_j.p * r.p * phase);\n    }\n\n    return r;\n}\n\nRAYX_FN_ACC\ninline ElectricField interceptReflect(const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 reflectVec,\n                                      const glm::dvec3 normalVec, const complex::Complex iorI, const complex::Complex iorT) {\n    const auto incidentAngle = complex::Complex(angleBetweenUnitVectors(incidentVec, -normalVec), 0);\n    const auto refractAngle  = calcRefractAngle(incidentAngle, iorI, iorT);\n\n    const auto reflectAmplitude = calcReflectAmplitude(incidentAngle, refractAngle, iorI, iorT);\n\n    // TODO: make this more robust\n    const auto isNormalIncidence         = incidentVec == -normalVec;\n    const auto reflectPolarizationMatrix = isNormalIncidence ? calcReflectPolarizationMatrixAtNormalIncidence(reflectAmplitude)\n                                                             : calcPolaririzationMatrix(incidentVec, reflectVec, normalVec, reflectAmplitude);\n\n    const auto reflectElectricField = reflectPolarizationMatrix * incidentElectricField;\n    return reflectElectricField;\n}\n\nRAYX_FN_ACC\ninline ElectricField interceptReflectCrystal(const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 reflectVec,\n                                             const glm::dvec3 normalVec, ComplexFresnelCoeffs reflectAmplitude) {\n    // TODO: make this more robust\n    const auto reflectPolarizationMatrix = calcPolaririzationMatrix(incidentVec, reflectVec, normalVec, reflectAmplitude);\n\n    const auto reflectElectricField = reflectPolarizationMatrix * incidentElectricField;\n    return reflectElectricField;\n}\n\nRAYX_FN_ACC\ninline ElectricField interceptFoil(const ElectricField incidentElectricField, const glm::dvec3 incidentVec, const glm::dvec3 normalVec,\n                                   ComplexFresnelCoeffs transCoeffs) {\n    // TODO: make this more robust\n    const auto transmittPolarizationMatrix = calcPolaririzationMatrixFoil(incidentVec, normalVec, transCoeffs);\n\n    const auto transmittElectricField = transmittPolarizationMatrix * incidentElectricField;\n    return transmittElectricField;\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/ElectricField_8h/","title":"File ElectricField.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ElectricField.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Complex.h\"</code></li> <li><code>#include \"Constants.h\"</code></li> </ul>"},{"location":"rayxCore/ElectricField_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/ElectricField_8h/#classes","title":"Classes","text":"Type Name struct RotationBase <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/ElectricField.h</code></p>"},{"location":"rayxCore/ElectricField_8h_source/","title":"File ElectricField.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ElectricField.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Complex.h\"\n#include \"Constants.h\"\n\nnamespace rayx {\n\nusing Stokes             = glm::dvec4;\nusing ElectricField      = cvec3;\nusing LocalElectricField = cvec2;\n\nstatic_assert(std::is_default_constructible_v&lt;ElectricField&gt;);\nstatic_assert(std::is_default_constructible_v&lt;LocalElectricField&gt;);\n#ifndef GLM_FORCE_XYZW_ONLY\n#error \"GLM_FORCE_XYZW_ONLY should be defined, to enable default construction of ElectricField\"\n#endif\n\nRAYX_FN_ACC\ninline double intensity(const LocalElectricField field) {\n    const auto mag = complex::abs(field);\n    return glm::dot(mag, mag);\n}\n\nRAYX_FN_ACC\ninline double intensity(const ElectricField field) {\n    const auto mag = complex::abs(field);\n    return glm::dot(mag, mag);\n}\n\nRAYX_FN_ACC\ninline double intensity(const Stokes stokes) { return stokes.x; }\n\nRAYX_FN_ACC\ninline double degreeOfPolarization(const Stokes stokes) { return glm::length(glm::dvec3(stokes.y, stokes.z, stokes.w)) / stokes.x; }\n\nRAYX_FN_ACC\ninline ElectricField advanceElectricField(const ElectricField field, double waveLength, const double opticalPathLength) {\n    // bring wavelength from nanometers into millimeters\n    waveLength /= 1e6;\n\n    // compute wave number (2\u03c0 / \u03bb), since opticalPathLength already includes IOR\n    const double waveNumber = 2.0 * PI / waveLength;\n\n    // reduce the distance modulo wavelength to avoid large angle errors\n    const double reducedDistance = std::fmod(opticalPathLength, waveLength);\n\n    // compute the phase shift\n    const double deltaPhi = waveNumber * reducedDistance;\n\n    // apply the phase shift as a complex exponential\n    const auto phaseShift = complex::exp(complex::Complex(0.0, deltaPhi));\n\n    return field * phaseShift;\n}\n\n/*\n *  rotation of electric field\n */\n\nstruct RotationBase {\n    glm::dvec3 right;\n    glm::dvec3 up;\n    glm::dvec3 forward;\n};\n\n// Computes a base given a forward vector\n// A convention for the up and right vectors is implemented, making this function well defined and for all forward directions\n// TODO(Sven): this convention should be exchanged with one that does not branch\nRAYX_FN_ACC\ninline RotationBase forwardVectorToBaseConvention(const glm::dvec3 forward) {\n    glm::dvec3 up;\n    glm::dvec3 right;\n\n    // test if the forward vector is close to being vertical\n    const auto close_to_vertical = glm::abs(glm::dot(forward, glm::dvec3(0, 1, 0))) &gt; .5;\n\n    // if the forward vector is not close to being vertical, we initialize the up vector to (0, 1, 0)\n    if (!close_to_vertical) {\n        up    = glm::dvec3(0, 1, 0);\n        right = glm::normalize(glm::cross(up, forward));\n        up    = glm::normalize(glm::cross(forward, right));\n    }\n\n    // otherwise initialize the right vector to (1, 0, 0)\n    else {\n        right = glm::dvec3(1, 0, 0);\n        up    = glm::normalize(glm::cross(forward, right));\n        right = glm::normalize(glm::cross(up, forward));\n    }\n\n    return RotationBase{\n        .right   = right,\n        .up      = up,\n        .forward = forward,\n    };\n}\n\n// Computes a rotation matrix given a forward vector. This matrix can be used to align an object with a direction\nRAYX_FN_ACC\ninline glm::dmat3 rotationMatrixWithBaseConvention(const glm::dvec3 forward) {\n    const auto base = forwardVectorToBaseConvention(forward);\n    return glm::dmat3(base.right, base.up, base.forward);\n}\n\nRAYX_FN_ACC\ninline glm::dmat3 rotationMatrix(const glm::dvec3 forward, const glm::dvec3 up) {\n    const auto right = glm::cross(up, forward);\n    return glm::dmat3(right, up, forward);\n}\n\n/*\n *  conversion between local and global electric field\n */\n\nRAYX_FN_ACC\ninline ElectricField localToGlobalElectricFieldWithBaseConvention(const LocalElectricField localField, const glm::dvec3 forward) {\n    return rotationMatrixWithBaseConvention(forward) * ElectricField(localField, complex::Complex{0, 0});\n}\n\nRAYX_FN_ACC\ninline ElectricField localToGlobalElectricField(const LocalElectricField localField, const glm::dvec3 forward, const glm::dvec3 up) {\n    return rotationMatrix(forward, up) * ElectricField(localField, complex::Complex{0, 0});\n}\n\nRAYX_FN_ACC\ninline ElectricField localToGlobalElectricField(const LocalElectricField localField, const glm::dmat3 rotation) {\n    return rotation * ElectricField(localField, complex::Complex{0, 0});\n}\n\nRAYX_FN_ACC\ninline LocalElectricField globalToLocalElectricFieldWithBaseConvention(const ElectricField field, const glm::dvec3 forward) {\n    return glm::transpose(rotationMatrixWithBaseConvention(forward)) * field;\n}\n\nRAYX_FN_ACC\ninline LocalElectricField globalToLocalElectricField(const ElectricField field, const glm::dvec3 forward, const glm::dvec3 up) {\n    return glm::transpose(rotationMatrix(forward, up)) * field;\n}\n\nRAYX_FN_ACC\ninline LocalElectricField globalToLocalElectricField(const ElectricField field, const glm::dmat3 rotation) { return rotation * field; }\n\n/*\n *  conversion between stokes and electric field\n */\n\nRAYX_FN_ACC\ninline Stokes localElectricFieldToStokes(const LocalElectricField field) {\n    const auto mag   = complex::abs(field);\n    const auto theta = complex::arg(field);\n\n    return Stokes(mag.x * mag.x + mag.y * mag.y, mag.x * mag.x - mag.y * mag.y, 2.0 * mag.x * mag.y * glm::cos(theta.x - theta.y),\n                  2.0 * mag.x * mag.y * glm::sin(theta.x - theta.y));\n}\n\nRAYX_FN_ACC\ninline LocalElectricField stokesToLocalElectricField(const Stokes stokes) {\n    const auto x_real  = glm::sqrt((stokes.x + stokes.y) / 2.0);\n    const auto y_mag   = glm::sqrt((stokes.x - stokes.y) / 2.0);\n    const auto y_theta = -1.0 * glm::atan(stokes.w, stokes.z);\n    const auto y       = complex::polar(y_mag, y_theta);\n    return LocalElectricField({x_real, 0}, y);\n}\n\nRAYX_FN_ACC\ninline ElectricField stokesToElectricFieldWithBaseConvention(const Stokes stokes, const glm::dvec3 forward) {\n    return localToGlobalElectricFieldWithBaseConvention(stokesToLocalElectricField(stokes), forward);\n}\n\nRAYX_FN_ACC\ninline ElectricField stokesToElectricField(const Stokes stokes, const glm::dvec3 forward, const glm::dvec3 up) {\n    return localToGlobalElectricField(stokesToLocalElectricField(stokes), forward, up);\n}\n\nRAYX_FN_ACC\ninline ElectricField stokesToElectricField(const Stokes stokes, const glm::dmat3 rotation) {\n    return rotation * ElectricField(stokesToLocalElectricField(stokes), complex::Complex{0, 0});\n}\n\nRAYX_FN_ACC\ninline ElectricField electricFieldToStokesWithBaseConvention(const ElectricField field, const glm::dvec3 forward) {\n    return localElectricFieldToStokes(globalToLocalElectricFieldWithBaseConvention(field, forward));\n}\n\nRAYX_FN_ACC\ninline ElectricField electricFieldToStokes(const ElectricField field, const glm::dvec3 forward, const glm::dvec3 up) {\n    return localElectricFieldToStokes(globalToLocalElectricField(field, forward, up));\n}\n\nRAYX_FN_ACC\ninline ElectricField electricFieldToStokes(const ElectricField field, const glm::dmat3 rotation) {\n    return localElectricFieldToStokes(globalToLocalElectricField(field, rotation));\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/EventType_8h/","title":"File EventType.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; EventType.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"Throw.h\"</code></li> </ul>"},{"location":"rayxCore/EventType_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/EventType.h</code></p>"},{"location":"rayxCore/EventType_8h_source/","title":"File EventType.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; EventType.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"Throw.h\"\n\nnamespace rayx {\n\n// TODO: doc this enum and all its members\nenum class EventType : uint32_t {\n    Uninitialized = 0,\n    Emitted       = 1,\n    HitElement    = 2,\n    FatalError    = 3,\n    Absorbed      = 4,\n    BeyondHorizon = 5,\n    TooManyEvents = 6,\n};\n\nRAYX_FN_ACC inline bool isRayTerminated(const EventType eventType) {\n    return !(eventType == EventType::Emitted || eventType == EventType::HitElement);\n}\n\nRAYX_FN_ACC inline void terminateRay(EventType&amp; __restrict dstEventType, const EventType srcEventType) {\n    _debug_warn(!isRayTerminated(dstEventType), \"ray about to be terminated, but ray is already terminated!\");\n    _debug_assert(isRayTerminated(srcEventType), \"ray about to be terminated, but provided event type (%d) is not a valid termination event type!\",\n                  static_cast&lt;int&gt;(srcEventType));\n    dstEventType = srcEventType;\n}\n\nenum class EventTypeMask : std::underlying_type_t&lt;EventType&gt; {\n    None          = 0,\n    Uninitialized = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Uninitialized),\n    Emitted       = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Emitted),\n    HitElement    = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::HitElement),\n    FatalError    = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::FatalError),\n    Absorbed      = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::Absorbed),\n    BeyondHorizon = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::BeyondHorizon),\n    TooManyEvents = 1 &lt;&lt; static_cast&lt;int&gt;(EventType::TooManyEvents),\n};\n\nRAYX_FN_ACC constexpr inline EventTypeMask operator|(const EventTypeMask lhs, const EventTypeMask rhs) {\n    return static_cast&lt;EventTypeMask&gt;(static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(lhs) &amp;\n                                      static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(rhs));\n}\nRAYX_FN_ACC constexpr inline EventTypeMask operator&amp;(const EventTypeMask lhs, const EventTypeMask rhs) {\n    return static_cast&lt;EventTypeMask&gt;(static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(lhs) &amp;\n                                      static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(rhs));\n}\nRAYX_FN_ACC constexpr inline EventTypeMask operator^(const EventTypeMask lhs, const EventTypeMask rhs) {\n    return static_cast&lt;EventTypeMask&gt;(static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(lhs) ^\n                                      static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(rhs));\n}\nRAYX_FN_ACC constexpr inline EventTypeMask operator~(const EventTypeMask lhs) {\n    return static_cast&lt;EventTypeMask&gt;(~static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(lhs));\n}\nRAYX_FN_ACC constexpr inline bool operator!(const EventTypeMask lhs) { return lhs == EventTypeMask::None; }\n\nRAYX_FN_ACC constexpr inline EventTypeMask operator|=(EventTypeMask&amp; lhs, const EventTypeMask rhs) { return lhs = lhs | rhs; }\nRAYX_FN_ACC constexpr inline EventTypeMask operator&amp;=(EventTypeMask&amp; lhs, const EventTypeMask rhs) { return lhs = lhs &amp; rhs; }\nRAYX_FN_ACC constexpr inline EventTypeMask operator^=(EventTypeMask&amp; lhs, const EventTypeMask rhs) { return lhs = lhs ^ rhs; }\n\nRAYX_FN_ACC constexpr inline EventTypeMask eventTypeToMask(const EventType eventType) {\n    return static_cast&lt;EventTypeMask&gt;(std::underlying_type_t&lt;EventTypeMask&gt;(1) &lt;&lt; static_cast&lt;std::underlying_type_t&lt;EventTypeMask&gt;&gt;(eventType));\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/ImageType_8h/","title":"File ImageType.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ImageType.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/ImageType_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/ImageType.h</code></p>"},{"location":"rayxCore/ImageType_8h_source/","title":"File ImageType.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; ImageType.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n\nnamespace rayx {\n\n// The ImageType is a parameter within the RZP.\n// It's different possible values are listed below.\n// These numbers are chosen to be compatible with RAY-UI.\nconstexpr int IT_POINT2POINT                     = 0;\nconstexpr int IT_POINT2HORIZONTAL_LINE           = 4;\nconstexpr int IT_POINT2HORIZONTAL_DIVERGENT_LINE = 5;\nconstexpr int IT_ASTIGMATIC2ASTIGMATIC           = 12;\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_cb81b8b75f2631c43a24c900d3ef53db/","title":"Dir Intern/rayx-core/src/Shader/LightSources","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources</p>"},{"location":"rayxCore/dir_cb81b8b75f2631c43a24c900d3ef53db/#files","title":"Files","text":"Type Name file CircleSource.h file DipoleSource.h file LightSource.h file MatrixSource.h file PixelSource.h file PointSource.h file RayListSource.h file SimpleUndulatorSource.h"},{"location":"rayxCore/dir_cb81b8b75f2631c43a24c900d3ef53db/#directories","title":"Directories","text":"Type Name dir EnergyDistributions <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/</code></p>"},{"location":"rayxCore/CircleSource_8h/","title":"File CircleSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; CircleSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/CircleSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/CircleSource_8h/#classes","title":"Classes","text":"Type Name class CircleSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/CircleSource.h</code></p>"},{"location":"rayxCore/CircleSource_8h_source/","title":"File CircleSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; CircleSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nclass RAYX_API CircleSource : public LightSourceBase {\n  public:\n    CircleSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant&amp; __restrict energyDistribution,\n                                   Rand&amp; __restrict rand) const;\n\n    RAYX_FN_ACC glm::dvec3 getDirection(Rand&amp; __restrict rand) const;\n\n  private:\n    // Geometric Params\n    // SourcePulseType m_sourceDistributionType;  // TODO unused.\n\n    glm::dvec4 m_pol;\n\n    double m_sourceDepth;\n    double m_sourceHeight;\n    double m_sourceWidth;\n\n    int m_numOfCircles;\n    Rad m_maxOpeningAngle;\n    Rad m_minOpeningAngle;\n    Rad m_deltaOpeningAngle;\n    // std::vector&lt;SOURCE_LENGTH&gt; m_source_lengths;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DipoleSource_8h/","title":"File DipoleSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; DipoleSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;list&gt;</code></li> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/DipoleSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DipoleSource_8h/#classes","title":"Classes","text":"Type Name class DipoleSource struct PsiAndStokes <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/DipoleSource.h</code></p>"},{"location":"rayxCore/DipoleSource_8h_source/","title":"File DipoleSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; DipoleSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;list&gt;\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nstruct PsiAndStokes {\n    glm::dvec4 stokes;\n    double psi;\n};\n\nRAYX_API double get_factorCriticalEnergy();\nRAYX_API double get_factorElectronEnergy();\nRAYX_API double get_factorOmega();\nRAYX_API RAYX_FN_ACC double dipoleBessel(double hnue, double zeta);\nRAYX_API RAYX_FN_ACC glm::dvec4 getStokesSyn(double energy, double psi1, double psi2, double electronEnergy, double criticalEnergy,\n                                             ElectronEnergyOrientation electronEnergyOrientation);\nRAYX_API RAYX_FN_ACC PsiAndStokes calcDipoleFold(double psi, double photonEnergy, double sigpsi, double electronEnergy, double criticalEnergy,\n                                                 ElectronEnergyOrientation electronEnergyOrientation, Rand&amp; __restrict rand);\nRAYX_API double calcMaxIntensity(double photonEnergy, double verDivergence, double electronEnergy, double criticalEnergy,\n                                 ElectronEnergyOrientation electronEnergyOrientation, Rand&amp; __restrict rand);\nRAYX_API double calcVerDivergence(double energy, double sigv, double electronEnergy, double criticalEnergy);\nRAYX_API RAYX_FN_ACC double getDipoleInterpolation(double energy);\nRAYX_API RAYX_FN_ACC double schwinger(double energy, double gamma, double criticalEnergy);\nRAYX_API double calcMaxFlux(double photonEnergy, double energySpread, double criticalEnergy, double gamma);\nRAYX_API double calcGamma(double electronEnergy);\n\nclass RAYX_API DipoleSource : public LightSourceBase {\n  public:\n    DipoleSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, Rand&amp; __restrict rand) const;\n\n  private:\n    // calculate Ray-Information\n    RAYX_FN_ACC glm::dvec3 getXYZPosition(double, Rand&amp; __restrict rand) const;\n    RAYX_FN_ACC PsiAndStokes getPsiandStokes(double, Rand&amp; __restrict rand) const;\n\n    // support functions\n    RAYX_FN_ACC double getNormalFromRange(double range, Rand&amp; __restrict rand) const;\n    RAYX_FN_ACC double getEnergy(Rand&amp; __restrict rand) const;\n\n    // Geometric Params\n    double m_bendingRadius;\n    ElectronEnergyOrientation m_electronEnergyOrientation;\n    // SourcePulseType m_sourcePulseType;\n    // double m_photonFlux;\n    // EnergyDistribution m_energySpreadType;\n\n    double m_sourceHeight;\n    double m_sourceWidth;\n\n    // double m_sigpsi;\n    // glm::dvec4 m_stokes;\n    double m_electronEnergy;\n    double m_criticalEnergy;\n    double m_photonEnergy;\n    double m_verEbeamDivergence;\n    // double m_flux;\n    // double m_totalPower;\n    // double m_bandwidth;\n    // double m_magneticFieldStrength;\n    double m_gamma;\n    // double m_beta;\n    // double m_photonWaveLength;\n    // double m_sourcePulseLength;\n    // double m_sourcePathLength;\n    // double m_phaseJitter;\n    // double m_horDivDegrees;\n    // double m_horDivSeconds;\n    double m_energySpread;\n    // EnergySpreadUnit m_energySpreadUnit;\n    // double m_photonFluxOrg;\n    double m_maxFlux;\n    double m_maxIntensity;\n    double m_horDivergence;\n    double m_verDivergence;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_3f2a90e89ce1c1a61675040d0f20e2d8/","title":"Dir Intern/rayx-core/src/Shader/LightSources/EnergyDistributions","text":"<p>FileList &gt; EnergyDistributions</p>"},{"location":"rayxCore/dir_3f2a90e89ce1c1a61675040d0f20e2d8/#files","title":"Files","text":"Type Name file EnergyDistribution.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/EnergyDistributions/</code></p>"},{"location":"rayxCore/Shader_2LightSources_2EnergyDistributions_2EnergyDistribution_8h/","title":"File EnergyDistribution.h","text":"<p>FileList &gt; EnergyDistributions &gt; EnergyDistribution.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Beamline/EnergyDistribution.h\"</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> <li><code>#include \"Variant.h\"</code></li> </ul>"},{"location":"rayxCore/Shader_2LightSources_2EnergyDistributions_2EnergyDistribution_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Shader_2LightSources_2EnergyDistributions_2EnergyDistribution_8h/#classes","title":"Classes","text":"Type Name struct EnergyDistributionDataBase struct EnergyDistributionList <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/EnergyDistributions/EnergyDistribution.h</code></p>"},{"location":"rayxCore/Shader_2LightSources_2EnergyDistributions_2EnergyDistribution_8h_source/","title":"File EnergyDistribution.h","text":"<p>File List &gt; EnergyDistributions &gt; EnergyDistribution.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Beamline/EnergyDistribution.h\"\n#include \"Core.h\"\n#include \"Shader/Rand.h\"\n#include \"Variant.h\"\n\nnamespace rayx {\n\nstruct EnergyDistributionList {\n    double* __restrict prefixWeights;\n    double* __restrict energies;\n    double weightSum;\n    int size;\n    bool continous;\n};\n\nstruct EnergyDistributionDataBase {\n    using HardEdge               = rayx::HardEdge;\n    using SoftEdge               = rayx::SoftEdge;\n    using SeparateEnergies       = rayx::SeparateEnergies;\n    using EnergyDistributionList = rayx::EnergyDistributionList;\n};\n\nusing EnergyDistributionDataVariant = Variant&lt;EnergyDistributionDataBase, EnergyDistributionDataBase::HardEdge, EnergyDistributionDataBase::SoftEdge,\n                                              SeparateEnergies, EnergyDistributionDataBase::EnergyDistributionList&gt;;\n\nRAYX_FN_ACC double selectEnergy(const HardEdge&amp; __restrict hardEdge, Rand&amp; __restrict rand);\nRAYX_FN_ACC double selectEnergy(const SoftEdge&amp; __restrict softEdge, Rand&amp; __restrict rand);\nRAYX_FN_ACC double selectEnergy(const SeparateEnergies&amp; __restrict separateEnergies, Rand&amp; __restrict rand);\nRAYX_FN_ACC double selectEnergy(const EnergyDistributionList&amp; __restrict energyDistributionList, Rand&amp; __restrict rand);\nRAYX_FN_ACC double selectEnergy(const EnergyDistributionDataVariant&amp; __restrict energyDistribution, Rand&amp; __restrict rand);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/LightSource_8h/","title":"File LightSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; LightSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Element/Element.h\"</code></li> <li><code>#include \"EnergyDistributions/EnergyDistribution.h\"</code></li> <li><code>#include \"Rml/xml.h\"</code></li> <li><code>#include \"Shader/Ray.h\"</code></li> </ul>"},{"location":"rayxCore/LightSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/LightSource_8h/#classes","title":"Classes","text":"Type Name class LightSourceBase <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/LightSource.h</code></p>"},{"location":"rayxCore/LightSource_8h_source/","title":"File LightSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; LightSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;glm.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Element/Element.h\"\n#include \"EnergyDistributions/EnergyDistribution.h\"\n#include \"Rml/xml.h\"\n#include \"Shader/Ray.h\"\n\nnamespace rayx {\n\nenum class SourceDist { Uniform, Gaussian, Thirds, Circle };  // SourceDist::Thirds represents PixelSource Footprint\nenum class ElectronEnergyOrientation { Clockwise, Counterclockwise };\nenum class EnergySpreadUnit { EU_PERCENT, EU_eV };\nenum class SigmaType { ST_STANDARD, ST_ACCURATE };\nenum class SourcePulseType { None };\n\nclass DesignSource;\n\nclass RAYX_API LightSourceBase {\n  protected:\n    LightSourceBase(const DesignSource&amp;);\n\n    RAYX_FN_ACC static glm::dvec3 getDirectionFromAngles(double phi, double psi);\n\n    int32_t m_numberOfRays;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/MatrixSource_8h/","title":"File MatrixSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; MatrixSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/MatrixSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/MatrixSource_8h/#classes","title":"Classes","text":"Type Name class MatrixSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/MatrixSource.h</code></p>"},{"location":"rayxCore/MatrixSource_8h_source/","title":"File MatrixSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; MatrixSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nclass DesignSource;\n\nclass RAYX_API MatrixSource : public LightSourceBase {\n  public:\n    MatrixSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant&amp; __restrict energyDistribution,\n                                   Rand&amp; __restrict rand) const;\n\n  private:\n    glm::dvec4 m_pol;\n\n    double m_horDivergence;\n    double m_verDivergence;\n    double m_sourceDepth;\n    double m_sourceHeight;\n    double m_sourceWidth;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/PixelSource_8h/","title":"File PixelSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; PixelSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/PixelSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/PixelSource_8h/#classes","title":"Classes","text":"Type Name class PixelSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/PixelSource.h</code></p>"},{"location":"rayxCore/PixelSource_8h_source/","title":"File PixelSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; PixelSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nclass RAYX_API PixelSource : public LightSourceBase {\n  public:\n    PixelSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant&amp; __restrict energyDistribution,\n                                   Rand&amp; __restrict rand) const;\n\n  private:\n    // Geometric Params\n    // SourcePulseType m_sourceDistributionType;  // TODO unused.\n\n    glm::dvec4 m_pol;\n\n    double m_horDivergence;\n    double m_verDivergence;\n    double m_sourceDepth;\n    double m_sourceHeight;\n    double m_sourceWidth;\n    // std::vector&lt;SOURCE_LENGTH&gt; m_source_lengths;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/PointSource_8h/","title":"File PointSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; PointSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/PointSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/PointSource_8h/#classes","title":"Classes","text":"Type Name class PointSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/PointSource.h</code></p>"},{"location":"rayxCore/PointSource_8h_source/","title":"File PointSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; PointSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nclass RAYX_API PointSource : public LightSourceBase {\n  public:\n    PointSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant&amp; __restrict energyDistribution,\n                                   Rand&amp; __restrict rand) const;\n\n  private:\n    // Geometric Params\n    SourceDist m_widthDist;\n    SourceDist m_heightDist;\n    SourceDist m_horDist;\n    SourceDist m_verDist;\n    // SourcePulseType m_sourceDistributionType;  // TODO unused.\n\n    glm::dvec4 m_pol;\n\n    double m_horDivergence;\n    double m_verDivergence;\n    double m_sourceDepth;\n    double m_sourceHeight;\n    double m_sourceWidth;\n    // std::vector&lt;SOURCE_LENGTH&gt; m_source_lengths;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/RayListSource_8h/","title":"File RayListSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; RayListSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Rays.h\"</code></li> </ul>"},{"location":"rayxCore/RayListSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/RayListSource_8h/#classes","title":"Classes","text":"Type Name struct RayListSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/RayListSource.h</code></p>"},{"location":"rayxCore/RayListSource_8h_source/","title":"File RayListSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; RayListSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Rays.h\"\n\nnamespace rayx {\n\nstruct RAYX_API RayListSource {\n    RaysPtr rays;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/SimpleUndulatorSource_8h/","title":"File SimpleUndulatorSource.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; SimpleUndulatorSource.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LightSource.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/SimpleUndulatorSource_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/SimpleUndulatorSource_8h/#classes","title":"Classes","text":"Type Name class SimpleUndulatorSource <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LightSources/SimpleUndulatorSource.h</code></p>"},{"location":"rayxCore/SimpleUndulatorSource_8h_source/","title":"File SimpleUndulatorSource.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LightSources &gt; SimpleUndulatorSource.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"LightSource.h\"\n#include \"Shader/Rand.h\"\n\nnamespace rayx {\n\nclass RAYX_API SimpleUndulatorSource : public LightSourceBase {\n  public:\n    SimpleUndulatorSource(const DesignSource&amp;);\n\n    RAYX_FN_ACC detail::Ray genRay(const int rayPathIndex, const int sourceId, const EnergyDistributionDataVariant&amp; __restrict energyDistribution,\n                                   Rand&amp; __restrict rand) const;\n\n    RAYX_FN_ACC double getCoord(const double extent, Rand&amp; __restrict rand) const;\n\n  private:\n    // Geometric Params\n    double m_horDivergence;\n    double m_verDivergence;\n    double m_sourceDepth;\n    double m_sourceHeight;\n    double m_sourceWidth;\n\n    // double m_undulatorSigma;\n    // double m_undulatorSigmaS;\n    double m_photonEnergy;\n    // double m_photonWaveLength;\n\n    // SourcePulseType m_sourceDistributionType;  // TODO unused.\n\n    glm::dvec4 m_pol;\n\n    // std::vector&lt;SOURCE_LENGTH&gt; m_source_lengths;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/InvocationState_8h/","title":"File InvocationState.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; InvocationState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Element/Element.h\"</code></li> <li><code>#include \"RaysPtr.h\"</code></li> </ul>"},{"location":"rayxCore/InvocationState_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/InvocationState_8h/#classes","title":"Classes","text":"Type Name struct ConstState stores all constant buffers struct MutableState stores all mutable buffers <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/InvocationState.h</code></p>"},{"location":"rayxCore/InvocationState_8h_source/","title":"File InvocationState.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; InvocationState.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Element/Element.h\"\n#include \"RaysPtr.h\"\n\nnamespace rayx {\n\nenum class Sequential { No, Yes };\n\nstruct RAYX_API ConstState {\n    int maxEvents;\n    Sequential sequential = Sequential::No;\n    int numSources;\n    int numElements;\n    int outputEventsGridStride;\n\n    ObjectTransform* __restrict objectTransforms;\n    OpticalElement* __restrict elements;\n    int* __restrict materialIndices;\n    double* __restrict materialTable;\n    bool* __restrict objectRecordMask;  // Mask that decides which elements to record events for (array length is numElements)\n    RayAttrMask attrRecordMask;\n    RaysPtr rays;\n};\n\nstruct RAYX_API MutableState {\n    RaysPtr events;\n    bool* __restrict storedFlags;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/LineDensity_8h/","title":"File LineDensity.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LineDensity.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Element/Behaviour.h\"</code></li> <li><code>#include \"Ray.h\"</code></li> </ul>"},{"location":"rayxCore/LineDensity_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/LineDensity.h</code></p>"},{"location":"rayxCore/LineDensity_8h_source/","title":"File LineDensity.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; LineDensity.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"Element/Behaviour.h\"\n#include \"Ray.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC double RAYX_API vlsGrating(double lineDensity, glm::dvec3 normal, double z, const double vls[6]);\n\nRAYX_FN_ACC void RAYX_API RZPLineDensity(const glm::dvec3&amp; __restrict position, const glm::dvec3&amp; __restrict normal,\n                                         const Behaviour::RZP&amp; __restrict b, double&amp; __restrict DX, double&amp; __restrict DZ);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Rand_8h/","title":"File Rand.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Rand.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Rand_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Rand_8h/#classes","title":"Classes","text":"Type Name struct Rand <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Rand.h</code></p>"},{"location":"rayxCore/Rand_8h_source/","title":"File Rand.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Rand.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nusing RandCounter = uint64_t;\n\n/*\n * Title: \"Squares: A Fast Counter-Based RNG\"\n * Author: Bernard Widynski\n * Date: November 24, 2020\n * URL: https://arxiv.org/pdf/2004.06278.pdf\n */\n// generates 64-Bit random integers\nRAYX_FN_ACC RandCounter RAYX_API squares64(RandCounter&amp; ctr);\n\n// generates uniformly distributed doubles between 0 and 1 from one 64-Bit\n// random integer\nRAYX_FN_ACC double RAYX_API squaresDoubleRNG(RandCounter&amp; ctr);\n\n// creates (via the Box-Muller transform) a normal distributed double with mean\n// mu and standard deviation sigma\nRAYX_FN_ACC double RAYX_API squaresNormalRNG(RandCounter&amp; ctr, double mu, double sigma);\n\nstruct Rand {\n    Rand() noexcept {}\n\n    Rand(const Rand&amp;)            = delete;\n    Rand(Rand&amp;&amp;)                 = default;\n    Rand&amp; operator=(const Rand&amp;) = delete;\n    Rand&amp; operator=(Rand&amp;&amp;)      = default;\n\n    RAYX_FN_ACC\n    explicit Rand(const RandCounter ctr) noexcept : counter(ctr) {}\n\n    RAYX_FN_ACC\n    explicit Rand(const int rayPathIndex, const int numRaysTotal, const double randomSeed) noexcept {\n        // ray specific \"seed\" for random numbers -&gt; every ray has a different starting value for the counter that creates the random number\n        const RandCounter MAX_UINT64   = ~(static_cast&lt;RandCounter&gt;(0));\n        const double MAX_UINT64_DOUBLE = 18446744073709551616.0;\n        RandCounter workerCounterNum   = MAX_UINT64 / static_cast&lt;RandCounter&gt;(numRaysTotal);\n        counter                        = rayPathIndex * workerCounterNum + static_cast&lt;RandCounter&gt;(randomSeed * MAX_UINT64_DOUBLE);\n\n        // TODO: replace above with below and test if it works correctly\n        // constexpr auto MAX_UINT64 = std::numeric_limits&lt;RandCounter&gt;::max();\n        // constexpr auto MAX_UINT64_DOUBLE = static_cast&lt;double&gt;(MAX_UINT64);\n        // const auto workerCounterNum =  MAX_UINT64 / static_cast&lt;RandCounter&gt;(numRaysTotal);\n        // const auto randomPhase = static_cast&lt;RandCounter&gt;(randomSeed * MAX_UINT64_DOUBLE);\n        // counter = rayPathIndex * workerCounterNum + randomPhase;\n    }\n\n    RAYX_FN_ACC\n    uint64_t randomInt() { return squares64(counter); }\n\n    // TODO: review this function. does the combination of int and uint work as intended?\n    RAYX_FN_ACC\n    int randomIntInRange(const int min_inclusive, const int max_exclusive) {\n        return min_inclusive + squares64(counter) % (max_exclusive - min_inclusive);\n    }\n\n    RAYX_FN_ACC\n    double randomDouble() { return squaresDoubleRNG(counter); }\n\n    RAYX_FN_ACC\n    double randomDoubleInRange(const double min, const double max) { return min + randomDouble() * (max - min); }\n\n    RAYX_FN_ACC\n    double randomDoubleNormalDistributed(double mu, double sigma) { return squaresNormalRNG(counter, mu, sigma); }\n\n    RandCounter counter;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Ray_8h/","title":"File Ray.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Ray.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"ElectricField.h\"</code></li> <li><code>#include \"EventType.h\"</code></li> <li><code>#include \"Rand.h\"</code></li> </ul>"},{"location":"rayxCore/Ray_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace detail"},{"location":"rayxCore/Ray_8h/#classes","title":"Classes","text":"Type Name struct Ray <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Ray.h</code></p>"},{"location":"rayxCore/Ray_8h_source/","title":"File Ray.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Ray.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n\n#include \"Core.h\"\n#include \"ElectricField.h\"\n#include \"EventType.h\"\n#include \"Rand.h\"\n\nnamespace rayx::detail {\n\n// this struct is for the usage inside a kernel\n// it is padded for optimal memory access on the CPU\n// the GPU does not care about padding as long as Ray stays in registers\nstruct Ray {\n    // keep position and direction together for better cache performance, since they are likely to be used together\n    glm::dvec3 position;\n    glm::dvec3 direction;\n\n    double energy;\n    double optical_path_length;\n\n    ElectricField electric_field;\n\n    Rand rand;  // deletes copy constructor/assignment\n\n    int path_id;\n    int path_event_id;\n    int order;\n    int object_id;\n    int source_id;\n    EventType event_type;\n};\n\n// make sure Ray is not copy constructable/assignable to protect it from costly copies\nstatic_assert(!std::is_copy_constructible_v&lt;Ray&gt; &amp;&amp; !std::is_copy_assignable_v&lt;Ray&gt;);\n\n}  // namespace rayx::detail\n</code></pre>"},{"location":"rayxCore/RaysPtr_8h/","title":"File RaysPtr.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RaysPtr.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Rays.h\"</code></li> </ul>"},{"location":"rayxCore/RaysPtr_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/RaysPtr_8h/#classes","title":"Classes","text":"Type Name struct RaysPtr"},{"location":"rayxCore/RaysPtr_8h/#macros","title":"Macros","text":"Type Name define X (type, name, flag) <code>type\\* \\_\\_restrict name;</code>"},{"location":"rayxCore/RaysPtr_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/RaysPtr_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `type* __restrict name;`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RaysPtr.h</code></p>"},{"location":"rayxCore/RaysPtr_8h_source/","title":"File RaysPtr.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RaysPtr.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Rays.h\"\n\nnamespace rayx {\n\n// this struct is analog to struct Rays. It contains pointers to the attribute arrays\nstruct RaysPtr {\n#define X(type, name, flag) type* __restrict name;\n\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n    RAYX_FN_ACC glm::dvec3 position(const int i) const { return glm::dvec3(position_x[i], position_y[i], position_z[i]); }\n    RAYX_FN_ACC void position(const int i, const glm::dvec3 position) {\n        position_x[i] = position.x;\n        position_y[i] = position.y;\n        position_z[i] = position.z;\n    }\n\n    RAYX_FN_ACC glm::dvec3 direction(const int i) const { return glm::dvec3(direction_x[i], direction_y[i], direction_z[i]); }\n    RAYX_FN_ACC void direction(const int i, const glm::dvec3 direction) {\n        direction_x[i] = direction.x;\n        direction_y[i] = direction.y;\n        direction_z[i] = direction.z;\n    }\n\n    RAYX_FN_ACC ElectricField electric_field(const int i) const {\n        return ElectricField(electric_field_x[i], electric_field_y[i], electric_field_z[i]);\n    }\n    RAYX_FN_ACC void electric_field(const int i, const ElectricField electric_field) {\n        electric_field_x[i] = electric_field.x;\n        electric_field_y[i] = electric_field.y;\n        electric_field_z[i] = electric_field.z;\n    }\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/RecordEvent_8h/","title":"File RecordEvent.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RecordEvent.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Ray.h\"</code></li> <li><code>#include \"RaysPtr.h\"</code></li> </ul>"},{"location":"rayxCore/RecordEvent_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RecordEvent.h</code></p>"},{"location":"rayxCore/RecordEvent_8h_source/","title":"File RecordEvent.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RecordEvent.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Ray.h\"\n#include \"RaysPtr.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC\ninline int getRecordIndex(const int gid, const int numRecorded, const int gridStride) { return gid + numRecorded * gridStride; }\n\nRAYX_FN_ACC\ninline detail::Ray loadRay(const int i, const RaysPtr&amp; __restrict rays) {\n    return {\n        .position            = rays.position(i),\n        .direction           = rays.direction(i),\n        .energy              = rays.energy[i],\n        .optical_path_length = rays.optical_path_length[i],\n        .electric_field      = rays.electric_field(i),\n        .rand                = Rand(rays.rand_counter[i]),\n        .path_id             = rays.path_id[i],\n        .path_event_id       = rays.path_event_id[i],\n        .order               = rays.order[i],\n        .object_id           = rays.object_id[i],\n        .source_id           = rays.source_id[i],\n        .event_type          = rays.event_type[i],\n    };\n}\n\nRAYX_FN_ACC\ninline void storeRay(const int i, RaysPtr&amp; __restrict rays, const detail::Ray&amp; __restrict ray) {\n    rays.path_id[i]             = ray.path_id;\n    rays.path_event_id[i]       = ray.path_event_id;\n    rays.position_x[i]          = ray.position.x;\n    rays.position_y[i]          = ray.position.y;\n    rays.position_z[i]          = ray.position.z;\n    rays.event_type[i]          = ray.event_type;\n    rays.direction_x[i]         = ray.direction.x;\n    rays.direction_y[i]         = ray.direction.y;\n    rays.direction_z[i]         = ray.direction.z;\n    rays.energy[i]              = ray.energy;\n    rays.electric_field_x[i]    = ray.electric_field.x;\n    rays.electric_field_y[i]    = ray.electric_field.y;\n    rays.electric_field_z[i]    = ray.electric_field.z;\n    rays.optical_path_length[i] = ray.optical_path_length;\n    rays.order[i]               = ray.order;\n    rays.object_id[i]           = ray.object_id;\n    rays.source_id[i]           = ray.source_id;\n    rays.rand_counter[i]        = ray.rand.counter;\n}\n\nRAYX_FN_ACC\ninline bool storeRay(const int i, bool* __restrict storedFlags, RaysPtr&amp; __restrict rays, detail::Ray&amp; __restrict ray,\n                     const bool* __restrict objectRecordMask, const int objectIndex, const RayAttrMask attrRecordMask) {\n    // TODO: should we do a syncwarp here, to make the whole warp access gmem?\n\n    // object record mask\n    if (!objectRecordMask[objectIndex]) return false;\n\n    // attribute record mask\n    if (!!(attrRecordMask &amp; RayAttrMask::PathId)) rays.path_id[i] = ray.path_id;\n    if (!!(attrRecordMask &amp; RayAttrMask::PathEventId)) rays.path_event_id[i] = ray.path_event_id;\n    if (!!(attrRecordMask &amp; RayAttrMask::PositionX)) rays.position_x[i] = ray.position.x;\n    if (!!(attrRecordMask &amp; RayAttrMask::PositionY)) rays.position_y[i] = ray.position.y;\n    if (!!(attrRecordMask &amp; RayAttrMask::PositionZ)) rays.position_z[i] = ray.position.z;\n    if (!!(attrRecordMask &amp; RayAttrMask::EventType)) rays.event_type[i] = ray.event_type;\n    if (!!(attrRecordMask &amp; RayAttrMask::DirectionX)) rays.direction_x[i] = ray.direction.x;\n    if (!!(attrRecordMask &amp; RayAttrMask::DirectionY)) rays.direction_y[i] = ray.direction.y;\n    if (!!(attrRecordMask &amp; RayAttrMask::DirectionZ)) rays.direction_z[i] = ray.direction.z;\n    if (!!(attrRecordMask &amp; RayAttrMask::Energy)) rays.energy[i] = ray.energy;\n    if (!!(attrRecordMask &amp; RayAttrMask::ElectricFieldX)) rays.electric_field_x[i] = ray.electric_field.x;\n    if (!!(attrRecordMask &amp; RayAttrMask::ElectricFieldY)) rays.electric_field_y[i] = ray.electric_field.y;\n    if (!!(attrRecordMask &amp; RayAttrMask::ElectricFieldZ)) rays.electric_field_z[i] = ray.electric_field.z;\n    if (!!(attrRecordMask &amp; RayAttrMask::OpticalPathLength)) rays.optical_path_length[i] = ray.optical_path_length;\n    if (!!(attrRecordMask &amp; RayAttrMask::Order)) rays.order[i] = ray.order;\n    if (!!(attrRecordMask &amp; RayAttrMask::ObjectId)) rays.object_id[i] = ray.object_id;\n    if (!!(attrRecordMask &amp; RayAttrMask::SourceId)) rays.source_id[i] = ray.source_id;\n    if (!!(attrRecordMask &amp; RayAttrMask::RandCounter)) rays.rand_counter[i] = ray.rand.counter;\n\n    // mark as stored\n    storedFlags[i] = true;\n    return true;\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Refrac_8h/","title":"File Refrac.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Refrac.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"Complex.h\"</code></li> <li><code>#include \"Ray.h\"</code></li> <li><code>#include \"Utils.h\"</code></li> </ul>"},{"location":"rayxCore/Refrac_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Refrac.h</code></p>"},{"location":"rayxCore/Refrac_8h_source/","title":"File Refrac.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Refrac.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#include \"Complex.h\"\n#include \"Ray.h\"\n#include \"Utils.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC void refrac2D(detail::Ray&amp; __restrict ray, glm::dvec3 normal, double az, double ax);\n\nRAYX_FN_ACC glm::dvec3 refract_dvec3(glm::dvec3 I, glm::dvec3 N, double eta);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/RefractiveIndex_8h/","title":"File RefractiveIndex.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RefractiveIndex.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Complex.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> </ul>"},{"location":"rayxCore/RefractiveIndex_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/RefractiveIndex_8h/#classes","title":"Classes","text":"Type Name struct NffEntry This struct represents one line of a .nff file. struct PalikEntry This struct represents one line of a .NKP file. <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/RefractiveIndex.h</code></p>"},{"location":"rayxCore/RefractiveIndex_8h_source/","title":"File RefractiveIndex.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; RefractiveIndex.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Complex.h\"\n#include \"InvocationState.h\"\n\nnamespace rayx {\n\n\nstruct PalikEntry {\n    double m_energy;\n    double m_n;\n    double m_k;\n};\n\nstruct NffEntry {\n    double m_energy;\n\n    // atomic scattering factors:\n    double m_f1;\n    double m_f2;\n};\n\nRAYX_FN_ACC int RAYX_API getPalikEntryCount(int material, const int* materialIndices);\n\nRAYX_FN_ACC int RAYX_API getNffEntryCount(int material, const int* materialIndices);\n\nRAYX_FN_ACC PalikEntry RAYX_API getPalikEntry(int index, int material, const int* materialIndices, const double* materialTable);\n\nRAYX_FN_ACC NffEntry RAYX_API getNffEntry(int index, int material, const int* materialIndices, const double* materialTable);\n\n// returns dvec2 to represent a complex number\nRAYX_FN_ACC complex::Complex RAYX_API getRefractiveIndex(double energy, int material, const int* materialIndices, const double* materialTable);\n\n// returns dvec2(atomic mass, density) extracted from materials.xmacro\nRAYX_FN_ACC glm::dvec2 RAYX_API getAtomicMassAndRho(int material);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/SlopeError_8h/","title":"File SlopeError.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; SlopeError.h</p> <p>Go to the source code of this file</p>"},{"location":"rayxCore/SlopeError_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/SlopeError_8h/#classes","title":"Classes","text":"Type Name struct SlopeError Structure to represent slope error parameters. <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/SlopeError.h</code></p>"},{"location":"rayxCore/SlopeError_8h_source/","title":"File SlopeError.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; SlopeError.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace rayx {\n\nstruct SlopeError {\n    double m_sag;                      \n    double m_mer;                      \n    double m_thermalDistortionAmp;     \n    double m_thermalDistortionSigmaX;  \n    double m_thermalDistortionSigmaZ;  \n    double m_cylindricalBowingAmp;     \n    double m_cylindricalBowingRadius;  \n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/SphericalCoords_8h/","title":"File SphericalCoords.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; SphericalCoords.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;glm.hpp&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/SphericalCoords_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/SphericalCoords.h</code></p>"},{"location":"rayxCore/SphericalCoords_8h_source/","title":"File SphericalCoords.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; SphericalCoords.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;glm.hpp&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\n// Consider this https://en.wikipedia.org/wiki/Spherical_coordinate_system.\n// But we fix the radius r = 1, as we only care to express direction, not distance.\n\n// The definitions of phi &amp; psi might differ from their definitions at other places, due to the fact that we exchanged y with z while fixing XZ as the\n// primary plane in the shader.\n\nRAYX_FN_ACC void RAYX_API sphericalCoordsToDirection(double phi, double psi, glm::dvec3&amp; out_direction);\nRAYX_FN_ACC void RAYX_API directionToSphericalCoords(glm::dvec3 direction, double&amp; out_phi, double&amp; out_psi);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Throw_8h/","title":"File Throw.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Throw.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Throw_8h/#macros","title":"Macros","text":"Type Name define _assert (condition, string, ...) <code>if (!(condition)) \\_throw(\"assert(\" #condition \"): \" string \\_\\_VA\\_OPT\\_\\_(, ) \\_\\_VA\\_ARGS\\_\\_)</code> define _debug_assert (condition, string, ...) <code>/* multi line expression */</code> define _debug_throw (string, ...) <code>/* multi line expression */</code> define _debug_warn (condition, string, ...) <code>/* multi line expression */</code> define _throw (string, ...) <code>/* multi line expression */</code> define _warn (condition, string, ...) <code>if (!(condition)) printf(\"Warning occurred while executing kernel: \" string \"\\n\" \\_\\_VA\\_OPT\\_\\_(, ) \\_\\_VA\\_ARGS\\_\\_)</code>"},{"location":"rayxCore/Throw_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Throw_8h/#define-_assert","title":"define _assert","text":"<pre><code>#define _assert (\n    condition,\n    string,\n    ...\n) `if (!(condition)) _throw(\"assert(\" #condition \"): \" string __VA_OPT__(, ) __VA_ARGS__)`\n</code></pre>"},{"location":"rayxCore/Throw_8h/#define-_debug_assert","title":"define _debug_assert","text":"<pre><code>#define _debug_assert (\n    condition,\n    string,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/Throw_8h/#define-_debug_throw","title":"define _debug_throw","text":"<pre><code>#define _debug_throw (\n    string,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/Throw_8h/#define-_debug_warn","title":"define _debug_warn","text":"<pre><code>#define _debug_warn (\n    condition,\n    string,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/Throw_8h/#define-_throw","title":"define _throw","text":"<pre><code>#define _throw (\n    string,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/Throw_8h/#define-_warn","title":"define _warn","text":"<pre><code>#define _warn (\n    condition,\n    string,\n    ...\n) `if (!(condition)) printf(\"Warning occurred while executing kernel: \" string \"\\n\" __VA_OPT__(, ) __VA_ARGS__)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Throw.h</code></p>"},{"location":"rayxCore/Throw_8h_source/","title":"File Throw.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Throw.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cassert&gt;\n\n#include \"Core.h\"\n\n#define _throw(string, ...)                                                                       \\\n    do {                                                                                          \\\n        printf(\"Error occurred while executing kernel: \" string \"\\n\" __VA_OPT__(, ) __VA_ARGS__); \\\n        assert(false);                                                                            \\\n    } while (0)\n\n#define _assert(condition, string, ...) \\\n    if (!(condition)) _throw(\"assert(\" #condition \"): \" string __VA_OPT__(, ) __VA_ARGS__)\n\n#define _warn(condition, string, ...) \\\n    if (!(condition)) printf(\"Warning occurred while executing kernel: \" string \"\\n\" __VA_OPT__(, ) __VA_ARGS__)\n\n#ifdef RAYX_DEBUG_MODE\n#define _debug_throw(string, ...)             _throw(string __VA_OPT__(, ) __VA_ARGS__)\n#define _debug_assert(condition, string, ...) _assert(condition, string __VA_OPT__(, ) __VA_ARGS__)\n#define _debug_warn(condition, string, ...)   _warn(condition, string __VA_OPT__(, ) __VA_ARGS__)\n#else\n#define _debug_throw(string, ...) \\\n    do {                          \\\n    } while (false)\n#define _debug_assert(condition, string, ...) \\\n    do {                                      \\\n    } while (false)\n#define _debug_warn(condition, string, ...) \\\n    do {                                    \\\n    } while (false)\n#endif\n</code></pre>"},{"location":"rayxCore/Trace_8h/","title":"File Trace.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Trace.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"InvocationState.h\"</code></li> </ul>"},{"location":"rayxCore/Trace_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Trace.h</code></p>"},{"location":"rayxCore/Trace_8h_source/","title":"File Trace.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Trace.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n#include \"InvocationState.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC void traceSequential(const int gid, const ConstState&amp; __restrict constState, MutableState&amp; __restrict mutableState);\nRAYX_FN_ACC void traceNonSequential(const int gid, const ConstState&amp; __restrict constState, MutableState&amp; __restrict mutableState);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Transmission_8h/","title":"File Transmission.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Transmission.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Constants.h\"</code></li> <li><code>#include \"Efficiency.h\"</code></li> <li><code>#include \"Utils.h\"</code></li> </ul>"},{"location":"rayxCore/Transmission_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Transmission.h</code></p>"},{"location":"rayxCore/Transmission_8h_source/","title":"File Transmission.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Transmission.h</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Constants.h\"\n#include \"Efficiency.h\"\n#include \"Utils.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC\ninline ComplexFresnelCoeffs computeTransmittance(double wavelength, complex::Complex theta0, const complex::Complex&amp; indexVacuum,\n                                                 const complex::Complex&amp; indexMaterial, double thickness) {\n    using complex::Complex;\n\n    complex::Complex sinTheta1 = (indexVacuum / indexMaterial) * complex::sin(theta0);\n    complex::Complex theta1    = complex::asin(sinTheta1);\n\n    complex::Complex theta2 = theta0;  // Austritt in Vakuum, Winkel gleich theta0\n\n    // Fresnel-Koeffizienten (s- und p-Polarisation)\n    auto rs = [](complex::Complex ni, complex::Complex nt, complex::Complex thetai, complex::Complex thetat) {\n        return (ni * complex::cos(thetai) - nt * complex::cos(thetat)) / (ni * complex::cos(thetai) + nt * complex::cos(thetat));\n    };\n    auto ts = [](complex::Complex ni, complex::Complex nt, complex::Complex thetai, complex::Complex thetat) {\n        return (2.0 * ni * complex::cos(thetai)) / (ni * complex::cos(thetai) + nt * complex::cos(thetat));\n    };\n    auto rp = [](complex::Complex ni, complex::Complex nt, complex::Complex thetai, complex::Complex thetat) {\n        return (nt * complex::cos(thetai) - ni * complex::cos(thetat)) / (nt * complex::cos(thetai) + ni * complex::cos(thetat));\n    };\n    auto tp = [](complex::Complex ni, complex::Complex nt, complex::Complex thetai, complex::Complex thetat) {\n        return (2.0 * ni * complex::cos(thetai)) / (nt * complex::cos(thetai) + ni * complex::cos(thetat));\n    };\n\n    // s-Polarisation\n    complex::Complex r01s = rs(indexVacuum, indexMaterial, theta0, theta1);\n    complex::Complex t01s = ts(indexVacuum, indexMaterial, theta0, theta1);\n    complex::Complex r12s = rs(indexMaterial, indexVacuum, theta1, theta2);\n    complex::Complex t12s = ts(indexMaterial, indexVacuum, theta1, theta2);\n\n    // p-Polarisation\n    complex::Complex r01p = rp(indexVacuum, indexMaterial, theta0, theta1);\n    complex::Complex t01p = tp(indexVacuum, indexMaterial, theta0, theta1);\n    complex::Complex r12p = rp(indexMaterial, indexVacuum, theta1, theta2);\n    complex::Complex t12p = tp(indexMaterial, indexVacuum, theta1, theta2);\n\n    // Phasenverschiebung\n    complex::Complex delta = (2.0 * PI / wavelength) * indexMaterial * thickness * complex::cos(theta1);\n    complex::Complex phase = complex::exp(complex::Complex(0, 1) * delta);\n\n    // Gesamte Transmission s\n    complex::Complex numeratorS   = t01s * t12s * phase;\n    complex::Complex denominatorS = 1.0 + r01s * r12s * phase * phase;\n    complex::Complex ts_total     = numeratorS / denominatorS;\n\n    // Gesamte Transmission p\n    complex::Complex numeratorP   = t01p * t12p * phase;\n    complex::Complex denominatorP = 1.0 + r01p * r12p * phase * phase;\n    complex::Complex tp_total     = numeratorP / denominatorP;\n\n    return {.s = ts_total, .p = tp_total};\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Utils_8h/","title":"File Utils.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Utils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Ray.h\"</code></li> <li><code>#include \"Throw.h\"</code></li> </ul>"},{"location":"rayxCore/Utils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Shader/Utils.h</code></p>"},{"location":"rayxCore/Utils_8h_source/","title":"File Utils.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Shader &gt; Utils.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Ray.h\"\n#include \"Throw.h\"\n\nnamespace rayx {\n\nRAYX_FN_ACC inline double RAYX_API energyToWaveLength(double x) { return INV_NM_TO_EVOLT / x; }\n\nRAYX_FN_ACC inline double waveLengthToEnergy(const double waveLength) { return INV_NM_TO_EVOLT / waveLength; }\n\nRAYX_FN_ACC\ninline void RAYX_API rayMatrixMult(const glm::dmat4&amp; __restrict m, glm::dvec3&amp; __restrict rayPosition, glm::dvec3&amp; __restrict rayDirection) {\n    rayPosition  = glm::dvec3(m * glm::dvec4(rayPosition, 1));\n    rayDirection = glm::dvec3(m * glm::dvec4(rayDirection, 0));\n}\n\nRAYX_FN_ACC\ninline void RAYX_API rayMatrixMult(const glm::dmat4&amp; __restrict m, glm::dvec3&amp; __restrict rayPosition, glm::dvec3&amp; __restrict rayDirection,\n                                   ElectricField&amp; __restrict rayElectricField) {\n    rayPosition      = glm::dvec3(m * glm::dvec4(rayPosition, 1));\n    rayDirection     = glm::dvec3(m * glm::dvec4(rayDirection, 0));\n    rayElectricField = glm::dmat3(m) * rayElectricField;\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_81c0cd68398be7a84e5cb6bea27ed875/","title":"Dir Intern/rayx-core/src/Tracer","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer</p>"},{"location":"rayxCore/dir_81c0cd68398be7a84e5cb6bea27ed875/#files","title":"Files","text":"Type Name file Accelerator.h file DeviceConfig.h file DeviceTracer.h file GenRays.h file MegaKernelTracer.h file Tracer.h file Util.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/</code></p>"},{"location":"rayxCore/Accelerator_8h/","title":"File Accelerator.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Accelerator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;alpaka/alpaka.hpp&gt;</code></li> <li><code>#include \"Debug/Debug.h\"</code></li> </ul>"},{"location":"rayxCore/Accelerator_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Accelerator.h</code></p>"},{"location":"rayxCore/Accelerator_8h_source/","title":"File Accelerator.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Accelerator.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;alpaka/alpaka.hpp&gt;\n\n#include \"Debug/Debug.h\"\n\nnamespace rayx {\n\ntemplate &lt;typename Acc&gt;\nconstexpr inline auto getBlockSize() {\n    using Idx = alpaka::Idx&lt;Acc&gt;;\n    using Dim = alpaka::Dim&lt;Acc&gt;;\n\n    auto impl = []() -&gt; Idx {\n#if defined(ALPAKA_ACC_GPU_CUDA_ENABLED)\n        if constexpr (std::is_same_v&lt;Acc, alpaka::AccGpuCudaRt&lt;Dim, Idx&gt;&gt;) return 128;\n#endif\n\n#if defined(ALPAKA_ACC_CPU_B_OMP2_T_SEQ_ENABLED)\n        if constexpr (std::is_same_v&lt;Acc, alpaka::AccCpuOmp2Blocks&lt;Dim, Idx&gt;&gt;) return 1;\n#endif\n\n#if defined(ALPAKA_ACC_CPU_B_SEQ_T_SEQ_ENABLED)\n        if constexpr (std::is_same_v&lt;Acc, alpaka::AccCpuSerial&lt;Dim, Idx&gt;&gt;) return 1;\n#endif\n\n        return 0;  // unimplemented\n    };\n\n    constexpr Idx blockSize = impl();\n    static_assert(blockSize != static_cast&lt;Idx&gt;(0));  // getBlockSize() is not implemented for Acc\n\n    return blockSize;\n}\n\ntemplate &lt;typename Acc&gt;\ninline auto getWorkDivForAcc(alpaka::Idx&lt;Acc&gt; numElements) {\n    using Idx = alpaka::Idx&lt;Acc&gt;;\n    using Dim = alpaka::Dim&lt;Acc&gt;;\n\n    constexpr int blockSize = getBlockSize&lt;Acc&gt;();\n    const int gridSize      = (numElements - 1) / blockSize + 1;\n\n    using Vec = alpaka::Vec&lt;Dim, Idx&gt;;\n    return alpaka::WorkDivMembers&lt;Dim, Idx&gt;{\n        Vec{gridSize},\n        Vec{blockSize},\n        Vec{1},\n    };\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/","title":"File DeviceConfig.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; DeviceConfig.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/DeviceConfig_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DeviceConfig_8h/#classes","title":"Classes","text":"Type Name struct DeviceConfig struct Device"},{"location":"rayxCore/DeviceConfig_8h/#public-attributes","title":"Public Attributes","text":"Type Name All   = <code>Cpu \\| Gpu</code> Cpu   = <code>CpuSerial \\| CpuParallel</code> CpuParallel   = <code>1 &amp;lt;&amp;lt; 1</code> CpuSerial   = <code>1 &amp;lt;&amp;lt; 0</code> Gpu   = <code>GpuCuda</code> GpuCuda   = <code>1 &amp;lt;&amp;lt; 2</code> None   = <code>0</code>"},{"location":"rayxCore/DeviceConfig_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"rayxCore/DeviceConfig_8h/#variable-all","title":"variable All","text":"<pre><code>All;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-cpu","title":"variable Cpu","text":"<pre><code>Cpu;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-cpuparallel","title":"variable CpuParallel","text":"<pre><code>CpuParallel;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-cpuserial","title":"variable CpuSerial","text":"<pre><code>CpuSerial;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-gpu","title":"variable Gpu","text":"<pre><code>Gpu;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-gpucuda","title":"variable GpuCuda","text":"<pre><code>GpuCuda;\n</code></pre>"},{"location":"rayxCore/DeviceConfig_8h/#variable-none","title":"variable None","text":"<pre><code>None;\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/DeviceConfig.h</code></p>"},{"location":"rayxCore/DeviceConfig_8h_source/","title":"File DeviceConfig.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; DeviceConfig.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n\nnamespace rayx {\n\nstruct RAYX_API DeviceConfig {\n    enum RAYX_API DeviceType {\n        None        = 0,\n        CpuSerial   = 1 &lt;&lt; 0,\n        CpuParallel = 1 &lt;&lt; 1,\n        Cpu         = CpuSerial | CpuParallel,\n        GpuCuda     = 1 &lt;&lt; 2,\n        Gpu         = GpuCuda,\n        All         = Cpu | Gpu,\n    };\n\n    struct RAYX_API Device {\n        using Index = size_t;\n        using Score = size_t;\n\n        DeviceType type;\n        std::string name;\n        Index index;\n        Score score;\n        bool enable;\n    };\n\n    DeviceConfig(DeviceType fetchedDeviceType = DeviceType::All);\n    DeviceConfig(const DeviceConfig&amp;) = default;\n    DeviceConfig(DeviceConfig&amp;&amp;)      = default;\n\n    DeviceConfig&amp; operator=(const DeviceConfig&amp;) = default;\n    DeviceConfig&amp; operator=(DeviceConfig&amp;&amp;)      = default;\n\n    void dumpDevices() const;\n    size_t enabledDevicesCount() const;\n\n    DeviceConfig&amp; disableAllDevices(DeviceType deviceType = DeviceType::All);\n    DeviceConfig&amp; enableAllDevices(DeviceType deviceType = DeviceType::All);\n\n    DeviceConfig&amp; disableDeviceByIndex(const Device::Index deviceIndex);\n    DeviceConfig&amp; enableDeviceByIndex(const Device::Index deviceIndex);\n\n    DeviceConfig&amp; enableBestDevice(DeviceType deviceType = DeviceType::All);\n\n    static DeviceType availableDeviceTypes();\n\n    std::vector&lt;Device&gt; devices;\n\n  private:\n    DeviceType m_fetchedDeviceType;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/DeviceTracer_8h/","title":"File DeviceTracer.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; DeviceTracer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"ObjectMask.h\"</code></li> <li><code>#include \"Rays.h\"</code></li> <li><code>#include \"Shader/InvocationState.h\"</code></li> </ul>"},{"location":"rayxCore/DeviceTracer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/DeviceTracer_8h/#classes","title":"Classes","text":"Type Name class DeviceTracer DeviceTracer is an interface to a tracer implementation we need this interface to remove the actual implementation from the rayx api. <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/DeviceTracer.h</code></p>"},{"location":"rayxCore/DeviceTracer_8h_source/","title":"File DeviceTracer.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; DeviceTracer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"ObjectMask.h\"\n#include \"Rays.h\"\n#include \"Shader/InvocationState.h\"\n\nnamespace rayx {\n\nclass RAYX_API DeviceTracer {\n  public:\n    virtual ~DeviceTracer() = default;\n\n    virtual Rays trace(const Group&amp; beamline, Sequential sequential, const ObjectIndexMask&amp; objectRecordMask, const RayAttrMask attrRecordMask,\n                       const int maxEvents, const int maxBatchSize) = 0;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/GenRays_8h/","title":"File GenRays.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; GenRays.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;alpaka/alpaka.hpp&gt;</code></li> <li><code>#include \"Beamline/Beamline.h\"</code></li> <li><code>#include \"Beamline/StringConversion.h\"</code></li> <li><code>#include \"Debug/Instrumentor.h\"</code></li> <li><code>#include \"Random.h\"</code></li> <li><code>#include \"Rays.h\"</code></li> <li><code>#include \"Shader/LightSources/CircleSource.h\"</code></li> <li><code>#include \"Shader/LightSources/DipoleSource.h\"</code></li> <li><code>#include \"Shader/LightSources/EnergyDistributions/EnergyDistribution.h\"</code></li> <li><code>#include \"Shader/LightSources/MatrixSource.h\"</code></li> <li><code>#include \"Shader/LightSources/PixelSource.h\"</code></li> <li><code>#include \"Shader/LightSources/PointSource.h\"</code></li> <li><code>#include \"Shader/LightSources/RayListSource.h\"</code></li> <li><code>#include \"Shader/LightSources/SimpleUndulatorSource.h\"</code></li> <li><code>#include \"Shader/RaysPtr.h\"</code></li> <li><code>#include \"Shader/RecordEvent.h\"</code></li> <li><code>#include \"Util.h\"</code></li> </ul>"},{"location":"rayxCore/GenRays_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/GenRays_8h/#classes","title":"Classes","text":"Type Name struct GenRays &lt;typename Acc&gt; struct BatchConfig holds configuration state of one batch struct SourceConfig holds configuration state of sources"},{"location":"rayxCore/GenRays_8h/#macros","title":"Macros","text":"Type Name define X (type, name, flag) <code>alpaka::memcpy(q, \\*d\\_rayListSources[index].name, alpaka::createView(devHost, rays.name, numRaysSource), numRaysSource);</code> define X (type, name, flag) <code>alpaka::memcpy(q, \\*d\\_rayListSources[index].name, alpaka::createView(devHost, rays.name, numRaysSource), numRaysSource);</code>"},{"location":"rayxCore/GenRays_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/GenRays_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `alpaka::memcpy(q, *d_rayListSources[index].name, alpaka::createView(devHost, rays.name, numRaysSource), numRaysSource);`\n</code></pre>"},{"location":"rayxCore/GenRays_8h/#define-x_1","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `alpaka::memcpy(q, *d_rayListSources[index].name, alpaka::createView(devHost, rays.name, numRaysSource), numRaysSource);`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/GenRays.h</code></p>"},{"location":"rayxCore/GenRays_8h_source/","title":"File GenRays.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; GenRays.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;alpaka/alpaka.hpp&gt;\n\n#include \"Beamline/Beamline.h\"\n#include \"Beamline/StringConversion.h\"\n#include \"Debug/Instrumentor.h\"\n#include \"Random.h\"\n#include \"Rays.h\"\n#include \"Shader/LightSources/CircleSource.h\"\n#include \"Shader/LightSources/DipoleSource.h\"\n#include \"Shader/LightSources/EnergyDistributions/EnergyDistribution.h\"\n#include \"Shader/LightSources/MatrixSource.h\"\n#include \"Shader/LightSources/PixelSource.h\"\n#include \"Shader/LightSources/PointSource.h\"\n#include \"Shader/LightSources/RayListSource.h\"\n#include \"Shader/LightSources/SimpleUndulatorSource.h\"\n#include \"Shader/RaysPtr.h\"\n#include \"Shader/RecordEvent.h\"\n#include \"Util.h\"\n\nnamespace rayx {\nnamespace {\n\nstruct GenRaysKernel {\n    // DipoleSource\n    template &lt;typename Acc&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, RaysPtr dstRays, const int startRayIndexBatch, const DipoleSource source,\n                                const int sourceId, const int startRayIndex, const int numRaysTotal, const double seed, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n) {\n            const auto rayPathIndex = startRayIndex + gid;\n            auto rand               = Rand(rayPathIndex, numRaysTotal, seed);\n            const auto ray          = source.genRay(rayPathIndex, sourceId, rand);\n            const auto dstIndex     = startRayIndexBatch + gid;\n            storeRay(dstIndex, dstRays, ray);\n        }\n    }\n\n    // RayListSource\n    template &lt;typename Acc&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, RaysPtr dstRays, const int startRayIndexBatch, const RayListSource source,\n                                const int sourceId, const int srcStartIndex, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n) {\n            const auto srcIndex = srcStartIndex + gid;\n            auto ray            = loadRay(srcIndex, source.rays);\n            ray.source_id       = sourceId;\n            ray.object_id       = sourceId;\n            const auto dstIndex = startRayIndexBatch + gid;\n            storeRay(dstIndex, dstRays, ray);\n        }\n    }\n\n    // other sources\n    template &lt;typename Acc, typename Source&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, RaysPtr dstRays, const int startRayIndexBatch, const Source source, const int sourceId,\n                                const EnergyDistributionDataVariant energyDistribution, const int startRayIndex, const int numRaysTotal,\n                                const double seed, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n) {\n            const auto rayPathIndex = startRayIndex + gid;\n            auto rand               = Rand(rayPathIndex, numRaysTotal, seed);\n            const auto ray          = source.genRay(rayPathIndex, sourceId, energyDistribution, rand);\n            const auto dstIndex     = startRayIndexBatch + gid;\n            storeRay(dstIndex, dstRays, ray);\n        }\n    }\n};\n\n}  // unnamed namespace\n\ntemplate &lt;typename Acc&gt;\nstruct GenRays {\n    struct SourceConfig {\n        int numRaysTotal;\n        int numRaysBatchAtMost;\n        int numBatches;\n    };\n\n    struct BatchConfig {\n        int numRaysBatch;\n        RaysBuf&lt;Acc&gt; d_rays;\n    };\n\n    template &lt;typename Queue&gt;\n    SourceConfig update(Queue q, const Group&amp; beamline, const int maxBatchSize) {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        const auto platformHost = alpaka::PlatformCpu{};\n        const auto devHost      = alpaka::getDevByIdx(platformHost, 0);\n\n        m_startRayIndex = 0;\n\n        auto rayListSourcesIndex = 0;\n        const auto compileSource = [&amp;, this](const DesignSource&amp; designSource) -&gt; std::optional&lt;SourceVariant&gt; {\n            switch (designSource.getType()) {\n                case ElementType::PointSource:\n                    return PointSource(designSource);\n                case ElementType::MatrixSource:\n                    return MatrixSource(designSource);\n                case ElementType::DipoleSource:\n                    return DipoleSource(designSource);\n                case ElementType::PixelSource:\n                    return PixelSource(designSource);\n                case ElementType::CircleSource:\n                    return CircleSource(designSource);\n                case ElementType::SimpleUndulatorSource:\n                    return SimpleUndulatorSource(designSource);\n                case ElementType::RayListSource: {\n                    const auto index = rayListSourcesIndex++;\n                    if (static_cast&lt;int&gt;(d_rayListSources.size()) &lt;= index) d_rayListSources.emplace_back();\n                    const auto numRaysSource = static_cast&lt;int&gt;(designSource.getNumberOfRays());\n                    allocRaysBuf(q, RayAttrMask::All, d_rayListSources[index], numRaysSource);\n                    const auto&amp; rays = *designSource.getRayList();\n                    assert(rays.attrMask() == RayAttrMask::All &amp;&amp; \"rays in RayListSource must contain all attributes\");\n#define X(type, name, flag) alpaka::memcpy(q, *d_rayListSources[index].name, alpaka::createView(devHost, rays.name, numRaysSource), numRaysSource);\n                    RAYX_X_MACRO_RAY_ATTR\n#undef X\n                    return RayListSource{.rays = raysBufToRaysPtr(d_rayListSources[index])};\n                }\n                default:\n                    throw std::runtime_error(std::format(\"Unimplemented source type ({}) with name: \\\"{}\\\"\",\n                                                         ElementTypeToString.at(designSource.getType()), designSource.getName()));\n                    return std::nullopt;\n            }\n        };\n\n        auto energyDistributionListIndex     = 0;\n        const auto compileEnergyDistribution = [&amp;](const DesignSource&amp; designSource) -&gt; std::optional&lt;EnergyDistributionDataVariant&gt; {\n            // special case: DipoleSource has no energy distribution\n            if (designSource.getType() == ElementType::DipoleSource) return std::nullopt;\n            // special case: RayListSource has no energy distribution\n            if (designSource.getType() == ElementType::RayListSource) return std::nullopt;\n\n            return std::visit(\n                [&amp;]&lt;typename T&gt;(const T&amp; value) -&gt; std::optional&lt;EnergyDistributionDataVariant&gt; {\n                    if constexpr (std::is_same_v&lt;T, HardEdge&gt;) { return value; }\n                    if constexpr (std::is_same_v&lt;T, SoftEdge&gt;) { return value; }\n                    if constexpr (std::is_same_v&lt;T, SeparateEnergies&gt;) { return value; }\n                    if constexpr (std::is_same_v&lt;T, DatFile&gt;) {\n                        assert(value.m_Lines.size() &gt; 0);\n                        assert(d_energyDistributionListWeights.size() == d_energyDistributionListEnergies.size());\n\n                        // get the data\n                        std::vector&lt;double&gt; weights;\n                        std::vector&lt;double&gt; energies;\n                        for (const auto entry : value.m_Lines) {\n                            weights.push_back(entry.m_weight);\n                            energies.push_back(entry.m_energy);\n                        }\n\n                        std::vector&lt;double&gt; prefixWeights(weights.size());\n                        std::inclusive_scan(weights.begin(), weights.end(), prefixWeights.begin());\n                        const auto weightSum = weights.back() + prefixWeights.back();\n\n                        // alloc device buffers and transfer data\n                        const auto index = energyDistributionListIndex++;\n                        const auto size  = static_cast&lt;int&gt;(value.m_Lines.size());\n                        if (static_cast&lt;int&gt;(d_energyDistributionListWeights.size()) &lt;= index) {\n                            d_energyDistributionListWeights.emplace_back();\n                            d_energyDistributionListEnergies.emplace_back();\n                        }\n                        allocBuf(q, d_energyDistributionListWeights[index], size);\n                        allocBuf(q, d_energyDistributionListEnergies[index], size);\n                        alpaka::memcpy(q, *d_energyDistributionListWeights[index], alpaka::createView(devHost, prefixWeights, size));\n                        alpaka::memcpy(q, *d_energyDistributionListEnergies[index], alpaka::createView(devHost, energies, size));\n\n                        return EnergyDistributionList{\n                            .prefixWeights = alpaka::getPtrNative(*d_energyDistributionListWeights[index]),\n                            .energies      = alpaka::getPtrNative(*d_energyDistributionListEnergies[index]),\n                            .weightSum     = weightSum,\n                            .size          = size,\n                            .continous     = value.m_continuous,\n                        };\n                    }\n\n                    RAYX_EXIT &lt;&lt; \"error: unimplemented energy distribution type\";\n                    return std::nullopt;\n                },\n                designSource.getEnergyDistribution());\n        };\n\n        m_numRaysTotal      = 0;\n        auto numRaysSources = std::vector&lt;int&gt;();\n        auto sourceId       = static_cast&lt;int&gt;(0);\n\n        for (const auto* designSource : beamline.getSources()) {\n            const auto source             = *compileSource(*designSource);\n            const auto energyDistribution = compileEnergyDistribution(*designSource);\n            const auto numRaysSource      = static_cast&lt;int&gt;(designSource-&gt;getNumberOfRays());\n            m_numRaysTotal += numRaysSource;\n\n            m_sourceStates.push_back(SourceState{\n                .source                 = source,\n                .sourceId               = sourceId,\n                .energyDistribution     = energyDistribution,\n                .numRaysSource          = numRaysSource,\n                .numRaysSourceRemaining = numRaysSource,\n                .name                   = designSource-&gt;getName(),\n            });\n\n            ++sourceId;\n        }\n\n        m_numRaysBatchAtMost = std::min(m_numRaysTotal, maxBatchSize);\n\n#define X(type, name, flag) allocBuf(q, d_rays.name, m_numRaysBatchAtMost);\n\n        RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n        const auto numBatches = m_numRaysBatchAtMost ? ceilIntDivision(m_numRaysTotal, m_numRaysBatchAtMost) : 0;\n\n        m_seed = randomDouble();\n\n        return {\n            .numRaysTotal       = m_numRaysTotal,\n            .numRaysBatchAtMost = m_numRaysBatchAtMost,\n            .numBatches         = numBatches,\n        };\n    }\n\n    template &lt;typename DevAcc, typename Queue&gt;\n    BatchConfig genRaysBatch(DevAcc devAcc, Queue q, const int batchIndex) {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        const auto batchStartRayIndex    = batchIndex * m_numRaysBatchAtMost;\n        const auto numRaysTotalRemaining = m_numRaysTotal - batchStartRayIndex;\n        const auto numRaysBatch          = std::min(numRaysTotalRemaining, m_numRaysBatchAtMost);\n        auto numRaysBatchRemaining       = numRaysBatch;\n\n        for (auto&amp; sourceState : m_sourceStates) {\n            const auto numRaysBatchSource  = std::min(numRaysBatchRemaining, sourceState.numRaysSourceRemaining);\n            const auto startRayIndexSource = sourceState.numRaysSource - sourceState.numRaysSourceRemaining;\n\n            if (numRaysBatchSource) {\n                const auto startRayIndexBatch = numRaysBatch - numRaysBatchRemaining;\n                numRaysBatchRemaining -= numRaysBatchSource;\n                sourceState.numRaysSourceRemaining -= numRaysBatchSource;\n\n                std::visit(\n                    [&amp;]&lt;typename Source&gt;(const Source&amp; source) {\n                        RAYX_VERB &lt;&lt; \"execute GenRaysKernel&lt;Source&gt; with Source = '\" &lt;&lt; sourceState.name &lt;&lt; \"'\";\n\n                        // DipoleSource\n                        if constexpr (std::is_same_v&lt;Source, DipoleSource&gt;) {\n                            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, numRaysBatchSource, BlockSizeConstraint::None{}, GenRaysKernel{},\n                                                      raysBufToRaysPtr(d_rays), startRayIndexBatch, source, sourceState.sourceId, m_startRayIndex,\n                                                      m_numRaysTotal, m_seed, numRaysBatchSource);\n                        }\n\n                        // RayListSource\n                        else if constexpr (std::is_same_v&lt;Source, RayListSource&gt;) {\n                            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, numRaysBatchSource, BlockSizeConstraint::None{}, GenRaysKernel{},\n                                                      raysBufToRaysPtr(d_rays), startRayIndexBatch, source, sourceState.sourceId, startRayIndexSource,\n                                                      numRaysBatchSource);\n                        }\n\n                        // other sources\n                        else {\n                            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, numRaysBatchSource, BlockSizeConstraint::None{}, GenRaysKernel{},\n                                                      raysBufToRaysPtr(d_rays), startRayIndexBatch, source, sourceState.sourceId,\n                                                      *sourceState.energyDistribution, m_startRayIndex, m_numRaysTotal, m_seed, numRaysBatchSource);\n                        }\n                    },\n                    sourceState.source);\n\n                m_startRayIndex += numRaysBatchSource;\n\n                assert(0 &lt;= numRaysBatchRemaining);\n                if (numRaysBatchRemaining == 0) break;\n            }\n        }\n\n        return BatchConfig{\n            .numRaysBatch = numRaysBatch,\n            .d_rays       = d_rays,\n        };\n    }\n\n  private:\n    // resources per batch. constant per batch\n    RaysBuf&lt;Acc&gt; d_rays;\n\n    std::vector&lt;RaysBuf&lt;Acc&gt;&gt; d_rayListSources;\n\n    // buffers for EnergyDistributionList (DatFile)\n    std::vector&lt;OptBuf&lt;Acc, double&gt;&gt; d_energyDistributionListWeights;\n    std::vector&lt;OptBuf&lt;Acc, double&gt;&gt; d_energyDistributionListEnergies;\n\n    using SourceVariant = std::variant&lt;CircleSource, DipoleSource, MatrixSource, PixelSource, PointSource, SimpleUndulatorSource, RayListSource&gt;;\n\n    struct SourceState {\n        const SourceVariant source;\n        const int sourceId;\n        const std::optional&lt;EnergyDistributionDataVariant&gt; energyDistribution;\n        int numRaysSource;\n        int numRaysSourceRemaining;\n        std::string name;\n    };\n\n    std::vector&lt;SourceState&gt; m_sourceStates;\n    int m_startRayIndex;\n    int m_numRaysTotal;\n    int m_numRaysBatchAtMost;\n    double m_seed;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/MegaKernelTracer_8h/","title":"File MegaKernelTracer.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; MegaKernelTracer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include \"Beamline/Beamline.h\"</code></li> <li><code>#include \"Debug/Instrumentor.h\"</code></li> <li><code>#include \"DeviceTracer.h\"</code></li> <li><code>#include \"GenRays.h\"</code></li> <li><code>#include \"Material/Material.h\"</code></li> <li><code>#include \"Random.h\"</code></li> <li><code>#include \"Shader/Trace.h\"</code></li> <li><code>#include \"Util.h\"</code></li> </ul>"},{"location":"rayxCore/MegaKernelTracer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/MegaKernelTracer_8h/#classes","title":"Classes","text":"Type Name class MegaKernelTracer &lt;typename AccTag&gt; struct Resources &lt;typename Acc&gt; struct BeamlineConfig holds configuration state of allocated resources. required to trace correctly"},{"location":"rayxCore/MegaKernelTracer_8h/#macros","title":"Macros","text":"Type Name define X (type, name, flag) <code>/* multi line expression */</code> define X (type, name, flag) <code>/* multi line expression */</code>"},{"location":"rayxCore/MegaKernelTracer_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/MegaKernelTracer_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/MegaKernelTracer_8h/#define-x_1","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/MegaKernelTracer.h</code></p>"},{"location":"rayxCore/MegaKernelTracer_8h_source/","title":"File MegaKernelTracer.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; MegaKernelTracer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;numeric&gt;\n#include &lt;set&gt;\n\n#include \"Beamline/Beamline.h\"\n#include \"Debug/Instrumentor.h\"\n#include \"DeviceTracer.h\"\n#include \"GenRays.h\"\n#include \"Material/Material.h\"\n#include \"Random.h\"\n#include \"Shader/Trace.h\"\n#include \"Util.h\"\n\nnamespace rayx {\nnamespace {\n\nconstexpr int WARP_SIZE            = 32;\nconstexpr int GRID_STRIDE_MULTIPLE = WARP_SIZE;\n\nstruct TraceSequentialKernel {\n    template &lt;typename Acc&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, const ConstState constState, MutableState mutableState, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n) traceSequential(gid, constState, mutableState);\n    }\n};\n\nstruct TraceNonSequentialKernel {\n    template &lt;typename Acc&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, const ConstState constState, MutableState mutableState, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n) traceNonSequential(gid, constState, mutableState);\n    }\n};\n\nstruct ScatterCompactKernel {\n    template &lt;typename Acc, typename T&gt;\n    RAYX_FN_ACC void operator()(const Acc&amp; __restrict acc, T* __restrict dst, const T* __restrict src, const int* __restrict prefix,\n                                const bool* __restrict flags, const int n) const {\n        const auto gid = alpaka::getIdx&lt;alpaka::Grid, alpaka::Threads&gt;(acc)[0];\n\n        if (gid &lt; n &amp;&amp; flags[gid]) {\n            const auto index = prefix[gid];\n            dst[index]       = src[gid];\n        }\n    }\n};\n\n}  // unnamed namespace\n\ntemplate &lt;typename Acc&gt;\nstruct Resources {\n    using Dim = alpaka::DimInt&lt;1&gt;;\n    using Idx = int;\n\n    // resources per program execution. constant per program execution\n    OptBuf&lt;Acc, int&gt; d_materialIndices;\n    OptBuf&lt;Acc, double&gt; d_materialTable;\n\n    // resources per beamline. constant per beamline\n    OptBuf&lt;Acc, ObjectTransform&gt; d_objectTransforms;\n\n    OptBuf&lt;Acc, OpticalElement&gt; d_elements;\n\n    OptBuf&lt;Acc, bool&gt; d_objectRecordMask;\n\n    // output events per tracing. required if 'events' is enabled in output config\n    RaysBuf&lt;Acc&gt; d_eventsBatch;\n    RaysBuf&lt;Acc&gt; d_compactEventsBatch;\n    OptBuf&lt;Acc, bool&gt; d_eventStoreFlags;\n    OptBuf&lt;Acc, int&gt; d_eventStoreFlagsPrefixSum;\n\n    struct BeamlineConfig {\n        int numSources;\n        int numElements;\n    };\n\n    template &lt;typename Queue&gt;\n    BeamlineConfig update(Queue q, const Group&amp; group, int maxEvents, int numRaysBatchAtMost, const ObjectIndexMask&amp; objectRecordMask,\n                          const RayAttrMask attrRecordMask) {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        const auto platformHost = alpaka::PlatformCpu{};\n        const auto devHost      = alpaka::getDevByIdx(platformHost, 0);\n\n        // material data\n        const auto materialTables     = group.calcMinimalMaterialTables();\n        const auto&amp; materialIndices   = materialTables.indices;\n        const auto&amp; materialTable     = materialTables.materials;\n        const auto numMaterialIndices = static_cast&lt;int&gt;(materialIndices.size());\n        const auto materialTableSize  = static_cast&lt;int&gt;(materialTable.size());\n        allocBuf(q, d_materialIndices, materialIndices.size());\n        allocBuf(q, d_materialTable, materialTable.size());\n        alpaka::memcpy(q, *d_materialIndices, alpaka::createView(devHost, materialIndices, numMaterialIndices));\n        alpaka::memcpy(q, *d_materialTable, alpaka::createView(devHost, materialTable, materialTableSize));\n\n        // beamline elements\n        // TODO: this should be two arrays, one of elements, one for transforms\n        const auto elementsAndTransforms = group.compileElements();\n        auto elements                    = std::vector&lt;OpticalElement&gt;(elementsAndTransforms.size());\n        std::transform(elementsAndTransforms.begin(), elementsAndTransforms.end(), elements.begin(),\n                       [](const OpticalElementAndTransform&amp; e) { return e.element; });\n        const auto numElements = static_cast&lt;int&gt;(elements.size());\n        allocBuf(q, d_elements, numElements);\n        alpaka::memcpy(q, *d_elements, alpaka::createView(devHost, elements, numElements));\n\n        const auto sources    = group.getSources();\n        const auto numSources = static_cast&lt;int&gt;(sources.size());\n        const auto numObjects = numSources + numElements;\n\n        // object transforms\n        // TODO: compiling of sources/elements should be revisited\n        auto h_objectTransforms = std::vector&lt;ObjectTransform&gt;(numObjects);\n        std::transform(sources.begin(), sources.end(), h_objectTransforms.begin(), [](const DesignSource* designSource) {\n            return ObjectTransform{\n                // TODO: make sure to do this DesignPlane:XZ thing correctly\n                .m_inTrans  = calcTransformationMatrices(designSource-&gt;getPosition(), designSource-&gt;getOrientation(), true, DesignPlane::XZ),\n                .m_outTrans = calcTransformationMatrices(designSource-&gt;getPosition(), designSource-&gt;getOrientation(), false, DesignPlane::XZ),\n            };\n        });\n        std::transform(elementsAndTransforms.begin(), elementsAndTransforms.end(), h_objectTransforms.begin() + numSources,\n                       [](const OpticalElementAndTransform&amp; e) { return e.transform; });\n        allocBuf(q, d_objectTransforms, numObjects);\n        alpaka::memcpy(q, *d_objectTransforms, alpaka::createView(devHost, h_objectTransforms, numObjects), numObjects);\n\n        // object record mask\n        allocBuf(q, d_objectRecordMask, numObjects);\n        auto h_objectRecordMask = std::make_unique&lt;bool[]&gt;(numObjects);\n        for (int i = 0; i &lt; numObjects; ++i) { h_objectRecordMask[i] = objectRecordMask.shouldRecordObject(i); }\n        alpaka::memcpy(q, *d_objectRecordMask, alpaka::createView(devHost, h_objectRecordMask.get(), numObjects));\n\n        const auto numEventsBatchAtMost                     = numRaysBatchAtMost * maxEvents;\n        const auto numEventsBatchAtMostAccountForGridStride = nextMultiple(numRaysBatchAtMost, GRID_STRIDE_MULTIPLE) * maxEvents;\n\n        // output events and compacted output events\n        allocRaysBuf(q, attrRecordMask, d_eventsBatch, numEventsBatchAtMostAccountForGridStride);\n        allocRaysBuf(q, attrRecordMask, d_compactEventsBatch, numEventsBatchAtMost);\n\n        // event storage flags, used for compaction of events\n        allocBuf(q, d_eventStoreFlags, numEventsBatchAtMostAccountForGridStride);\n        allocBuf(q, d_eventStoreFlagsPrefixSum, numEventsBatchAtMostAccountForGridStride);\n\n        return {\n            .numSources  = numSources,\n            .numElements = numElements,\n        };\n    }\n};\n\ntemplate &lt;typename AccTag&gt;\nclass MegaKernelTracer : public DeviceTracer {\n  public:\n    explicit MegaKernelTracer(int deviceIndex) : m_deviceIndex(deviceIndex) {}\n    MegaKernelTracer(const MegaKernelTracer&amp;)            = delete;\n    MegaKernelTracer(MegaKernelTracer&amp;&amp;)                 = default;\n    MegaKernelTracer&amp; operator=(const MegaKernelTracer&amp;) = delete;\n    MegaKernelTracer&amp; operator=(MegaKernelTracer&amp;&amp;)      = default;\n\n  private:\n    using Dim = alpaka::DimInt&lt;1&gt;;\n    using Idx = int;\n    using Acc = alpaka::TagToAcc&lt;AccTag, Dim, Idx&gt;;\n\n    const int m_deviceIndex;\n    Resources&lt;Acc&gt; m_resources;\n\n    using GenRaysAcc = GenRays&lt;Acc&gt;;\n    GenRaysAcc m_genRaysResources;\n\n  public:\n    virtual Rays trace(const Group&amp; beamline, Sequential sequential, const ObjectIndexMask&amp; objectRecordMask, const RayAttrMask attrRecordMask,\n                       const int maxEventsElements, const int maxBatchSize) override {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        const auto maxEventsSources = 1;\n        const auto maxEvents        = maxEventsSources + maxEventsElements;\n\n        const auto platformHost = alpaka::PlatformCpu{};\n        const auto devHost      = alpaka::getDevByIdx(platformHost, 0);\n        const auto platformAcc  = alpaka::Platform&lt;Acc&gt;{};\n        const auto devAcc       = alpaka::getDevByIdx(platformAcc, m_deviceIndex);\n        using Queue             = alpaka::Queue&lt;Acc, alpaka::Blocking&gt;;\n        auto q                  = Queue(devAcc);\n\n        const auto sourceConf   = m_genRaysResources.update(q, beamline, maxBatchSize);\n        const auto beamlineConf = m_resources.update(q, beamline, maxEvents, sourceConf.numRaysBatchAtMost, objectRecordMask, attrRecordMask);\n\n        RAYX_VERB &lt;&lt; \"trace beamline:\";\n        RAYX_VERB &lt;&lt; \"\\t- num sources: \" &lt;&lt; beamlineConf.numSources;\n        RAYX_VERB &lt;&lt; \"\\t- num elements: \" &lt;&lt; beamlineConf.numElements;\n        RAYX_VERB &lt;&lt; \"\\t- sequential: \" &lt;&lt; (sequential == Sequential::Yes ? \"yes\" : \"no\");\n        RAYX_VERB &lt;&lt; \"\\t- max events on elements: \" &lt;&lt; maxEventsElements;\n        RAYX_VERB &lt;&lt; \"\\t- num rays: \" &lt;&lt; sourceConf.numRaysTotal;\n        RAYX_VERB &lt;&lt; \"\\t- max batch size: \" &lt;&lt; maxBatchSize;\n        RAYX_VERB &lt;&lt; \"\\t- batch size: \" &lt;&lt; sourceConf.numRaysBatchAtMost;\n        RAYX_VERB &lt;&lt; \"\\t- num batches: \" &lt;&lt; sourceConf.numBatches;\n        // TODO: print object mask\n        RAYX_VERB &lt;&lt; \"\\t- using ray attribute mask: \" &lt;&lt; to_string(attrRecordMask);\n        RAYX_VERB &lt;&lt; \"\\t- backend tag: \" &lt;&lt; AccTag{}.get_name();\n        RAYX_VERB &lt;&lt; \"\\t- device index: \" &lt;&lt; m_deviceIndex;\n        RAYX_VERB &lt;&lt; \"\\t- device name: \" &lt;&lt; alpaka::getName(devAcc);\n        RAYX_VERB &lt;&lt; \"\\t- host device name: \" &lt;&lt; alpaka::getName(devHost);\n\n        const auto numRaysBatchAtMostAccountForGridStride   = nextMultiple(sourceConf.numRaysBatchAtMost, GRID_STRIDE_MULTIPLE);\n        const auto numEventsBatchAtMostAccountForGridStride = numRaysBatchAtMostAccountForGridStride * maxEvents;\n        auto h_compactEventsBatches                         = std::vector&lt;Rays&gt;(sourceConf.numBatches);\n        auto h_eventStoreFlags                              = std::make_unique&lt;bool[]&gt;(numEventsBatchAtMostAccountForGridStride);\n        auto h_eventStoreFlagsPrefixSum                     = std::vector&lt;int&gt;(numEventsBatchAtMostAccountForGridStride);\n        auto numEventsTotal                                 = 0;\n\n        for (int batchIndex = 0; batchIndex &lt; sourceConf.numBatches; ++batchIndex) {\n            RAYX_VERB &lt;&lt; \"processing batch (\" &lt;&lt; (batchIndex + 1) &lt;&lt; \"/\" &lt;&lt; sourceConf.numBatches &lt;&lt; \")\";\n\n            // generate input rays for batch\n            auto batchConf = m_genRaysResources.genRaysBatch(devAcc, q, batchIndex);\n\n            const auto numRaysBatchAccountForGridStride   = nextMultiple(batchConf.numRaysBatch, GRID_STRIDE_MULTIPLE);\n            const auto numEventsBatchAccountForGridStride = numRaysBatchAccountForGridStride * maxEvents;\n\n            // clear buffers\n            alpaka::memset(q, *m_resources.d_eventStoreFlags, 0, numEventsBatchAccountForGridStride);\n\n            // from here we need to account for grid stride in the output buffers of the trace function: uncompacte events and storedFlag\n\n            // trace current batch\n            traceBatch(devAcc, q, beamlineConf.numSources, beamlineConf.numElements, maxEvents, sequential, attrRecordMask, batchConf,\n                       numRaysBatchAccountForGridStride);\n\n            alpaka::memcpy(q, alpaka::createView(devHost, h_eventStoreFlags.get(), numEventsBatchAccountForGridStride),\n                           *m_resources.d_eventStoreFlags, numEventsBatchAccountForGridStride);\n            const auto h_eventStoreFlagsPrefixSumEnd = std::exclusive_scan(\n                h_eventStoreFlags.get(), h_eventStoreFlags.get() + numEventsBatchAccountForGridStride, h_eventStoreFlagsPrefixSum.begin(), 0);\n            const auto numEventsBatch =\n                *(h_eventStoreFlagsPrefixSumEnd - 1);  // access the last element of the exclusive scan result to get the total count\n            alpaka::memcpy(q, *m_resources.d_eventStoreFlagsPrefixSum,\n                           alpaka::createView(devHost, h_eventStoreFlagsPrefixSum, numEventsBatchAccountForGridStride),\n                           numEventsBatchAccountForGridStride);\n\n            // TODO: here we could apply more filters by turning off storedFlags\n\n            // compact events to remove unused events\n            compactEvents(devAcc, q, numEventsBatchAccountForGridStride, attrRecordMask);\n\n            // end of acocunt for grid stride, because from here we use the compacted buffers\n\n            numEventsTotal += numEventsBatch;\n\n            h_compactEventsBatches[batchIndex] = transferEventsBatch(devHost, q, numEventsBatch, attrRecordMask);\n\n            RAYX_VERB &lt;&lt; \"finished batch (\" &lt;&lt; (batchIndex + 1) &lt;&lt; \"/\" &lt;&lt; sourceConf.numBatches &lt;&lt; \") with batch size = \" &lt;&lt; batchConf.numRaysBatch\n                      &lt;&lt; \", recorded \" &lt;&lt; numEventsBatch &lt;&lt; \" events\";\n        }\n\n        RAYX_VERB &lt;&lt; \"number of recorded events: \" &lt;&lt; numEventsTotal;\n\n        return Rays::concat(h_compactEventsBatches);\n    }\n\n  private:\n    template &lt;typename DevAcc, typename Queue&gt;\n    void traceBatch(DevAcc devAcc, Queue q, int numSources, int numElements, int maxEvents, Sequential sequential, RayAttrMask attrRecordMask,\n                    GenRaysAcc::BatchConfig&amp; batchConf, int numRaysBatchAccountForGridStride) {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        const auto constState = ConstState{\n            // constants\n            .maxEvents              = maxEvents,\n            .sequential             = sequential,\n            .numSources             = numSources,\n            .numElements            = numElements,\n            .outputEventsGridStride = numRaysBatchAccountForGridStride,\n\n            // buffers\n            .objectTransforms = alpaka::getPtrNative(*m_resources.d_objectTransforms),\n            .elements         = alpaka::getPtrNative(*m_resources.d_elements),\n            .materialIndices  = alpaka::getPtrNative(*m_resources.d_materialIndices),\n            .materialTable    = alpaka::getPtrNative(*m_resources.d_materialTable),\n            .objectRecordMask = alpaka::getPtrNative(*m_resources.d_objectRecordMask),\n            .attrRecordMask   = attrRecordMask,\n            .rays             = raysBufToRaysPtr(batchConf.d_rays),\n        };\n\n        const auto mutableState = MutableState{\n            // buffers\n            .events      = raysBufToRaysPtr(m_resources.d_eventsBatch),\n            .storedFlags = alpaka::getPtrNative(*m_resources.d_eventStoreFlags),\n        };\n\n        if (sequential == Sequential::Yes) {\n            RAYX_VERB &lt;&lt; \"execute TraceSequentialKernel\";\n            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, batchConf.numRaysBatch, BlockSizeConstraint::None{}, TraceSequentialKernel{}, constState,\n                                      mutableState, batchConf.numRaysBatch);\n        } else {\n            RAYX_VERB &lt;&lt; \"execute TraceNonSequentialKernel\";\n            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, batchConf.numRaysBatch, BlockSizeConstraint::None{}, TraceNonSequentialKernel{}, constState,\n                                      mutableState, batchConf.numRaysBatch);\n        }\n    }\n\n    template &lt;typename DevAcc, typename Queue&gt;\n    void compactEvents(DevAcc devAcc, Queue q, const int numEventsBatchAccountForGridStride, const RayAttrMask attrRecordMask) {\n        RAYX_PROFILE_FUNCTION_STDOUT();\n\n        // TODO: compare performance to single scatter kernel execution handling all attributes\n\n        auto execKernel = [&amp;]&lt;typename TOptBuf&gt;(TOptBuf&amp; compactAttrBuf, const TOptBuf&amp; attrBuf) {\n            execWithValidWorkDiv&lt;Acc&gt;(devAcc, q, numEventsBatchAccountForGridStride, BlockSizeConstraint::None{}, ScatterCompactKernel{},\n                                      alpaka::getPtrNative(*compactAttrBuf), alpaka::getPtrNative(*attrBuf),\n                                      alpaka::getPtrNative(*m_resources.d_eventStoreFlagsPrefixSum),\n                                      alpaka::getPtrNative(*m_resources.d_eventStoreFlags), numEventsBatchAccountForGridStride);\n        };\n\n#define X(type, name, flag)                                                                  \\\n    if (contains(attrRecordMask, RayAttrMask::flag)) {                                       \\\n        RAYX_VERB &lt;&lt; \"execute ScatterCompactKernel for compaction of ray attribute: \" #name; \\\n        execKernel(m_resources.d_compactEventsBatch.name, m_resources.d_eventsBatch.name);   \\\n    }\n\n        RAYX_X_MACRO_RAY_ATTR\n#undef X\n    }\n\n    template &lt;typename DevHost, typename Queue&gt;\n    Rays transferEventsBatch(DevHost&amp; devHost, Queue q, const int numEventsBatch, const RayAttrMask attrRecordMask) {\n        const auto transfer = [&amp;]&lt;typename T&gt;(std::vector&lt;T&gt;&amp; dst, const OptBuf&lt;Acc, T&gt;&amp; d_compactEventsBatch) {\n            // resize to fit source events and element events\n            dst.resize(numEventsBatch);\n\n            // transfer\n            alpaka::memcpy(q, alpaka::createView(devHost, dst, numEventsBatch), *d_compactEventsBatch, numEventsBatch);\n        };\n\n        Rays h_compactEventsBatch;\n\n#define X(type, name, flag) \\\n    if (contains(attrRecordMask, RayAttrMask::flag)) transfer(h_compactEventsBatch.name, m_resources.d_compactEventsBatch.name);\n\n        RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n        return h_compactEventsBatch;\n    }\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Tracer_8h/","title":"File Tracer.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Tracer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"DeviceConfig.h\"</code></li> <li><code>#include \"DeviceTracer.h\"</code></li> <li><code>#include \"Rays.h\"</code></li> </ul>"},{"location":"rayxCore/Tracer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Tracer_8h/#classes","title":"Classes","text":"Type Name class Tracer <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Tracer.h</code></p>"},{"location":"rayxCore/Tracer_8h_source/","title":"File Tracer.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Tracer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"DeviceConfig.h\"\n#include \"DeviceTracer.h\"\n#include \"Rays.h\"\n\n// Abstract Tracer base class.\nnamespace rayx {\n\n// this value is picked in a 'good' way if it can divide number of rays without rest. for a number of rays picked by humans, this\n// value is probably good. though, if it could be power of two, the shader would benefit\nconstexpr int DEFAULT_BATCH_SIZE = 100000;\n\nconstexpr int defaultMaxEvents(const int numObjects) { return numObjects * 2 + 8; }\n\nclass RAYX_API Tracer {\n  public:\n    Tracer(const DeviceConfig&amp; deviceConfig = DeviceConfig().enableBestDevice());\n\n    // This will call the trace implementation of a subclass\n    // See `BundleHistory` for information about the return value.\n    // `max_batch_size` corresponds to the maximal number of rays that will be put into `traceRaw` in one batch.\n\n    Rays trace(const Group&amp; group, const Sequential sequential = Sequential::No, const ObjectMask&amp; objectRecordMask = ObjectMask::all(),\n               const RayAttrMask attrRecordMask = RayAttrMask::All, std::optional&lt;int&gt; maxEvents = std::nullopt,\n               std::optional&lt;int&gt; maxBatchSize = std::nullopt);\n\n  private:\n    std::shared_ptr&lt;DeviceTracer&gt; m_deviceTracer;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Util_8h/","title":"File Util.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Util.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;alpaka/alpaka.hpp&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Debug/Instrumentor.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> <li><code>#include \"Shader/RaysPtr.h\"</code></li> </ul>"},{"location":"rayxCore/Util_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx namespace BlockSizeConstraint"},{"location":"rayxCore/Util_8h/#classes","title":"Classes","text":"Type Name struct AtLeast struct AtMost struct Exact struct InRange struct None struct RaysBuf &lt;typename Acc&gt;"},{"location":"rayxCore/Util_8h/#macros","title":"Macros","text":"Type Name define X (type, name, flag) <code>OptBuf&amp;lt;Acc, type&amp;gt; name;</code> define X (type, name, flag) <code>OptBuf&amp;lt;Acc, type&amp;gt; name;</code> define X (type, name, flag) <code>OptBuf&amp;lt;Acc, type&amp;gt; name;</code>"},{"location":"rayxCore/Util_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Util_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `OptBuf&lt;Acc, type&gt; name;`\n</code></pre>"},{"location":"rayxCore/Util_8h/#define-x_1","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `OptBuf&lt;Acc, type&gt; name;`\n</code></pre>"},{"location":"rayxCore/Util_8h/#define-x_2","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `OptBuf&lt;Acc, type&gt; name;`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Tracer/Util.h</code></p>"},{"location":"rayxCore/Util_8h_source/","title":"File Util.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Tracer &gt; Util.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;alpaka/alpaka.hpp&gt;\n#include &lt;optional&gt;\n#include &lt;vector&gt;\n\n#include \"Debug/Instrumentor.h\"\n#include \"Shader/Rand.h\"\n#include \"Shader/RaysPtr.h\"\n\nnamespace rayx {\n\ntemplate &lt;typename Acc, typename T&gt;\nusing OptBuf = std::optional&lt;alpaka::Buf&lt;Acc, T, alpaka::DimInt&lt;1&gt;, int32_t&gt;&gt;;\n\n// this struct is analog to struct Rays. It contains OptBufs instead of vectors, so it can be used as buffers on CPU or GPU\ntemplate &lt;typename Acc&gt;\nstruct RaysBuf {\n#define X(type, name, flag) OptBuf&lt;Acc, type&gt; name;\n\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n};\n\ntemplate &lt;typename Acc&gt;\nRaysPtr raysBufToRaysPtr(RaysBuf&lt;Acc&gt;&amp; buf) {\n    return RaysPtr{\n#define X(type, name, flag) .name = buf.name ? alpaka::getPtrNative(*buf.name) : nullptr,\n\n        RAYX_X_MACRO_RAY_ATTR\n#undef X\n    };\n}\n\ninline int ceilIntDivision(const int dividend, const int divisor) { return (divisor + dividend - 1) / divisor; }\n\ninline int nextPowerOfTwo(const int value) { return static_cast&lt;int&gt;(glm::pow(2, glm::ceil(glm::log(value) / glm::log(2)))); }\n\ninline int nextMultiple(const int value, const int divisor) {\n    if (divisor == 0) RAYX_EXIT &lt;&lt; \"error: divisor must not be zero\";\n\n    auto remainder = value % divisor;\n\n    if (remainder == 0)\n        return value;  // already a multiple\n    else\n        return value + (divisor - remainder);  // next bigger multiple\n}\ntemplate &lt;typename Queue, typename Buf&gt;\ninline void allocBuf(Queue q, std::optional&lt;Buf&gt;&amp; buf, const int size) {\n    using Idx  = alpaka::Idx&lt;Buf&gt;;\n    using Elem = alpaka::Elem&lt;Buf&gt;;\n\n    const auto shouldAlloc = !buf || alpaka::getExtents(*buf)[0] &lt; size;\n    if (shouldAlloc) RAYX_VERB &lt;&lt; (!buf ? \"new alloc on device: \" : \"realloc on device: \") &lt;&lt; nextPowerOfTwo(size * sizeof(Elem)) &lt;&lt; \" bytes\";\n    if (shouldAlloc) buf = alpaka::allocAsyncBufIfSupported&lt;Elem, Idx&gt;(q, nextPowerOfTwo(size));\n}\n\ntemplate &lt;typename Queue, typename Acc&gt;\ninline void allocRaysBuf(Queue q, const RayAttrMask attrMask, RaysBuf&lt;Acc&gt;&amp; raysBuf, const int size) {\n#define X(type, name, flag) \\\n    if (contains(attrMask, RayAttrMask::flag)) allocBuf(q, raysBuf.name, size);\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n}\n\nnamespace BlockSizeConstraint {\n\nstruct None {};\n\nstruct Exact {\n    int value;\n};\n\nstruct AtLeast {\n    int value;\n};\n\nstruct AtMost {\n    int value;\n};\n\nstruct InRange {\n    int atLeast;\n    int atMost;\n};\n\nusing Variant = std::variant&lt;None, Exact, AtLeast, AtMost, InRange&gt;;\n\n}  // namespace BlockSizeConstraint\n\n// TODO: maybe make a PR to alpaka for alpaka::Acc&lt;Dev&gt; to extract Acc from DevAcc (= Dev&lt;Platform&lt;Acc&gt;&gt;)\ntemplate &lt;typename Acc, typename DevAcc, typename Queue, typename Kernel, typename... Args&gt;\ninline void execWithValidWorkDiv(DevAcc devAcc, Queue q, const int numElements, BlockSizeConstraint::Variant blockSizeConstraint,\n                                 const Kernel&amp; kernel, Args&amp;&amp;... args) {\n    const auto conf = alpaka::KernelCfg&lt;Acc&gt;{\n        .gridElemExtent                        = numElements,\n        .threadElemExtent                      = 1,\n        .blockThreadMustDivideGridThreadExtent = false,\n    };\n\n    auto workDiv = alpaka::getValidWorkDiv(conf, devAcc, kernel, std::forward&lt;Args&gt;(args)...);\n    std::visit(\n        [&amp;]&lt;typename BlockSizeConstraintType&gt;(BlockSizeConstraintType constraint) {\n            if constexpr (std::is_same_v&lt;BlockSizeConstraintType, BlockSizeConstraint::Exact&gt;) {\n                assert(workDiv.m_blockThreadExtent[0] &lt;= constraint.value &amp;&amp; \"BlockSizeConstraint::Exact exceeds the capabilities this device\");\n                workDiv.m_blockThreadExtent = constraint.value;\n                workDiv.m_gridBlockExtent   = ceilIntDivision(numElements, constraint.value);\n            }\n\n            if constexpr (std::is_same_v&lt;BlockSizeConstraintType, BlockSizeConstraint::AtMost&gt;) {\n                if (constraint.value &lt; workDiv.m_blockThreadExtent[0]) {\n                    workDiv.m_blockThreadExtent = constraint.value;\n                    workDiv.m_gridBlockExtent   = ceilIntDivision(numElements, constraint.value);\n                }\n            }\n\n            if constexpr (std::is_same_v&lt;BlockSizeConstraintType, BlockSizeConstraint::AtLeast&gt;) {\n                assert(constraint.value &lt;= workDiv.m_blockThreadExtent[0] &amp;&amp; \"BlockSizeConstraint::AtLeast exceeds the capabilities this device\");\n            }\n\n            if constexpr (std::is_same_v&lt;BlockSizeConstraintType, BlockSizeConstraint::InRange&gt;) {\n                assert(constraint.atLeast &lt;= workDiv.m_blockThreadExtent[0] &amp;&amp; \"BlockSizeConstraint::InRange exceeds capabilities of this device\");\n                if (constraint.atMost &lt; workDiv.m_blockThreadExtent[0]) {\n                    workDiv.m_blockThreadExtent = constraint.atMost;\n                    workDiv.m_gridBlockExtent   = ceilIntDivision(numElements, constraint.atMost);\n                }\n            }\n        },\n        blockSizeConstraint);\n\n    RAYX_VERB &lt;&lt; \"execute kernel with launch config: \"\n              &lt;&lt; \"blocks = \" &lt;&lt; workDiv.m_gridBlockExtent[0] &lt;&lt; \", \"\n              &lt;&lt; \"threads = \" &lt;&lt; workDiv.m_blockThreadExtent[0];\n\n    alpaka::exec&lt;Acc&gt;(q, workDiv, kernel, std::forward&lt;Args&gt;(args)...);\n}\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/dir_d1c815520a7617c58c603daf30348a97/","title":"Dir Intern/rayx-core/src/Writer","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Writer</p>"},{"location":"rayxCore/dir_d1c815520a7617c58c603daf30348a97/#files","title":"Files","text":"Type Name file CsvWriter.h file H5Writer.h <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Writer/</code></p>"},{"location":"rayxCore/CsvWriter_8h/","title":"File CsvWriter.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Writer &gt; CsvWriter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Shader/Ray.h\"</code></li> <li><code>#include \"Tracer/Tracer.h\"</code></li> </ul>"},{"location":"rayxCore/CsvWriter_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Writer/CsvWriter.h</code></p>"},{"location":"rayxCore/CsvWriter_8h_source/","title":"File CsvWriter.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Writer &gt; CsvWriter.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Shader/Ray.h\"\n#include \"Tracer/Tracer.h\"\n\nnamespace rayx {\n\nvoid RAYX_API writeCsv(const std::filesystem::path&amp; filepath, const Rays&amp; rays);\nRays RAYX_API readCsv(const std::filesystem::path&amp; filepath);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/H5Writer_8h/","title":"File H5Writer.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Writer &gt; H5Writer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"Rays.h\"</code></li> </ul>"},{"location":"rayxCore/H5Writer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Writer/H5Writer.h</code></p>"},{"location":"rayxCore/H5Writer_8h_source/","title":"File H5Writer.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Writer &gt; H5Writer.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;filesystem&gt;\n\n#include \"Rays.h\"\n\nnamespace rayx {\n\n#ifndef NO_H5\nRAYX_API Rays readH5Rays(const std::filesystem::path&amp; filepath, const RayAttrMask attr = RayAttrMask::All);\nRAYX_API std::vector&lt;std::string&gt; readH5ObjectNames(const std::filesystem::path&amp; filepath);\n\nRAYX_API void writeH5(const std::filesystem::path&amp; filepath, const std::vector&lt;std::string&gt;&amp; object_names, const Rays&amp; rays,\n                      const RayAttrMask attr = RayAttrMask::All, const bool overwrite = true);\nRAYX_API void appendH5(const std::filesystem::path&amp; filepath, const Rays&amp; rays, const RayAttrMask attr = RayAttrMask::All);\n#endif\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/ObjectMask_8h/","title":"File ObjectMask.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; ObjectMask.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Debug/Debug.h\"</code></li> </ul>"},{"location":"rayxCore/ObjectMask_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/ObjectMask_8h/#classes","title":"Classes","text":"Type Name class ObjectIndexMask class ObjectMask <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/ObjectMask.h</code></p>"},{"location":"rayxCore/ObjectMask_8h_source/","title":"File ObjectMask.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; ObjectMask.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Debug/Debug.h\"\n\nnamespace rayx {\n\nclass RAYX_API ObjectIndexMask {\n    ObjectIndexMask(const std::vector&lt;bool&gt;&amp; sourceMask, const std::vector&lt;bool&gt;&amp; elementMask)\n        : m_sourceMask(sourceMask), m_elementMask(elementMask) {}\n    ObjectIndexMask(std::vector&lt;bool&gt;&amp;&amp; sourceMask, std::vector&lt;bool&gt;&amp;&amp; elementMask)\n        : m_sourceMask(std::move(sourceMask)), m_elementMask(std::move(elementMask)) {}\n\n  public:\n    ObjectIndexMask()                                  = default;\n    ObjectIndexMask(const ObjectIndexMask&amp;)            = default;\n    ObjectIndexMask(ObjectIndexMask&amp;&amp;)                 = default;\n    ObjectIndexMask&amp; operator=(const ObjectIndexMask&amp;) = default;\n    ObjectIndexMask&amp; operator=(ObjectIndexMask&amp;&amp;)      = default;\n\n    static ObjectIndexMask none(const int numSources, const int numElements) {\n        return {\n            std::vector&lt;bool&gt;(numSources, false),\n            std::vector&lt;bool&gt;(numElements, false),\n        };\n    }\n\n    static ObjectIndexMask all(const int numSources, const int numElements) {\n        return {\n            std::vector&lt;bool&gt;(numSources, true),\n            std::vector&lt;bool&gt;(numElements, true),\n        };\n    }\n\n    static ObjectIndexMask allSources(const int numSources, const int numElements) {\n        return {\n            std::vector&lt;bool&gt;(numSources, true),\n            std::vector&lt;bool&gt;(numElements, false),\n        };\n    }\n\n    static ObjectIndexMask allElements(const int numSources, const int numElements) {\n        return {\n            std::vector&lt;bool&gt;(numSources, false),\n            std::vector&lt;bool&gt;(numElements, true),\n        };\n    }\n\n    static ObjectIndexMask byIndices(const int numSources, const int numElements, const std::vector&lt;int&gt;&amp; objectIndices) {\n        auto sourceMask  = std::vector&lt;bool&gt;(numSources, false);\n        auto elementMask = std::vector&lt;bool&gt;(numElements, false);\n\n        for (const auto i : objectIndices) {\n            if (i &lt; numSources)\n                sourceMask.at(i) = true;\n            else\n                elementMask.at(i - numSources) = true;\n        }\n\n        return {\n            sourceMask,\n            elementMask,\n        };\n    }\n\n    int numSources() const { return static_cast&lt;int&gt;(m_sourceMask.size()); }\n    int numElements() const { return static_cast&lt;int&gt;(m_elementMask.size()); }\n    int numObjects() const { return numSources() + numElements(); }\n\n    int numSourcesToRecord() const { return static_cast&lt;int&gt;(std::count(m_sourceMask.begin(), m_sourceMask.end(), true)); }\n    int numElementsToRecord() const { return static_cast&lt;int&gt;(std::count(m_elementMask.begin(), m_elementMask.end(), true)); }\n    int numObjectsToRecord() const { return numSourcesToRecord() + numElementsToRecord(); }\n\n    bool shouldRecordSource(int source_id) const { return m_sourceMask.at(source_id); }\n    void setShouldRecordSource(int source_id, bool value) { m_sourceMask.at(source_id) = value; }\n\n    bool shouldRecordElement(int element_id) const { return m_elementMask.at(element_id); }\n    void setShouldRecordElement(int element_id, bool value) { m_elementMask.at(element_id) = value; }\n\n    bool shouldRecordObject(int object_id) const {\n        const auto numSources = static_cast&lt;int&gt;(m_sourceMask.size());\n        if (object_id &lt; numSources) return m_sourceMask.at(object_id);\n        return m_elementMask.at(object_id - numSources);\n    }\n\n    void setShouldRecordObject(int object_id, bool value) {\n        const auto numSources = static_cast&lt;int&gt;(m_sourceMask.size());\n        if (object_id &lt; numSources) m_sourceMask.at(object_id) = value;\n        m_elementMask.at(object_id - numSources) = value;\n    }\n\n  private:\n    std::vector&lt;bool&gt; m_sourceMask;\n    std::vector&lt;bool&gt; m_elementMask;\n};\n\nclass RAYX_API ObjectMask {\n    struct None {};\n    struct All {};\n    struct AllSources {};\n    struct AllElements {};\n    struct ByIndices {\n        std::vector&lt;int&gt; indices;\n    };\n    using Variant = std::variant&lt;None, All, AllSources, AllElements, ByIndices, ObjectIndexMask&gt;;\n\n    ObjectMask(Variant variant) : m_variant(std::move(variant)) {}\n\n  public:\n    ObjectMask() : m_variant(None{}) {}\n    ObjectMask(const ObjectMask&amp;)            = default;\n    ObjectMask(ObjectMask&amp;&amp;)                 = default;\n    ObjectMask&amp; operator=(const ObjectMask&amp;) = default;\n    ObjectMask&amp; operator=(ObjectMask&amp;&amp;)      = default;\n    ObjectMask(ObjectIndexMask objectIndexMask) : m_variant(std::move(objectIndexMask)) {}\n\n    static ObjectMask none() { return ObjectMask(None{}); }\n    static ObjectMask all() { return ObjectMask(All{}); }\n    static ObjectMask allSources() { return ObjectMask(AllSources{}); }\n    static ObjectMask allElements() { return ObjectMask(AllElements{}); }\n    static ObjectMask byIndices(std::vector&lt;int&gt; indices) { return ObjectMask(ByIndices{.indices = std::move(indices)}); }\n\n    // resolve to a concrete mask\n    ObjectIndexMask toObjectIndexMask(int numSources, int numElements) const {\n        return std::visit(\n            [&amp;]&lt;typename T&gt;(const T&amp; option) -&gt; ObjectIndexMask {\n                if constexpr (std::is_same_v&lt;T, None&gt;) return ObjectIndexMask::none(numSources, numElements);\n                if constexpr (std::is_same_v&lt;T, All&gt;) return ObjectIndexMask::all(numSources, numElements);\n                if constexpr (std::is_same_v&lt;T, AllSources&gt;) return ObjectIndexMask::allSources(numSources, numElements);\n                if constexpr (std::is_same_v&lt;T, AllElements&gt;) return ObjectIndexMask::allElements(numSources, numElements);\n                if constexpr (std::is_same_v&lt;T, ByIndices&gt;) return ObjectIndexMask::byIndices(numSources, numElements, option.indices);\n                if constexpr (std::is_same_v&lt;T, ObjectIndexMask&gt;) return option;\n\n                RAYX_EXIT &lt;&lt; \"error: unknown ObjectMask option: \" &lt;&lt; typeid(T).name();\n                return {};\n            },\n            m_variant);\n    }\n\n  private:\n    Variant m_variant;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Random_8h/","title":"File Random.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Random.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include \"Core.h\"</code></li> </ul>"},{"location":"rayxCore/Random_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Random.h</code></p>"},{"location":"rayxCore/Random_8h_source/","title":"File Random.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Random.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;stdint.h&gt;\n\n#include \"Core.h\"\n\n// All C++ randomness should be using this module.\n// Otherwise set-seeding tests will not work.\n// The seed for the shader should also be generated from this module.\n\n// It is crucial that all of our random implementations yield the same values (with a fixed seed) across all hardware, compilers and platforms!\n\nnamespace rayx {\n\n// fixed-seed tests operate on this seed.\nconst uint32_t FIXED_SEED = 42;\n\n// Sets the current `seed` to `x`.\n// This resets the internal RNG state, so any future values returned by this random generator are deterministic - only based on the seed x.\n// In order to make your function RNG-deterministic, you need to call fixSeed once at the beginning of your function.\n// This function is used for fixed-seed testing.\nvoid RAYX_API fixSeed(uint32_t x);\n\n// sets the seed \"randomly\", depending on system time.\nvoid RAYX_API randomSeed();\n\n// samples an integer from the uniform integer distribution over the interval [0, 2^32[\nuint32_t randomUint();\n\n// samples a double from the uniform distribution over the interval [0, 1]\ndouble RAYX_API randomDouble();\n\n// samples an integer from the uniform distribution over the interval [min(a, b), max(a, b)]\nint randomIntInRange(int a, int b);\n\n// samples a double from the uniform distribution over the interval [min(a, b), max(a, b)]\ndouble RAYX_API randomDoubleInRange(double a, double b);\n\n// samples a value from the given normal distribution.\n// `mean` is evidently the mean of the distribution, while `stddev` is the standard deviation (often written as sigma).\ndouble RAYX_API randomNormal(double mean, double stddev);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/","title":"File RayAttrMask.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; RayAttrMask.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Core.h\"</code></li> <li><code>#include \"Shader/ElectricField.h\"</code></li> <li><code>#include \"Shader/EventType.h\"</code></li> <li><code>#include \"Shader/Rand.h\"</code></li> </ul>"},{"location":"rayxCore/RayAttrMask_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/RayAttrMask_8h/#macros","title":"Macros","text":"Type Name define RAYX_X_MACRO_RAY_ATTR <code>/* multi line expression */</code> define RAYX_X_MACRO_RAY_ATTR_DIRECTION_X <code>X(double, direction\\_x, DirectionX)</code> define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y <code>X(double, direction\\_y, DirectionY)</code> define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z <code>X(double, direction\\_z, DirectionZ)</code> define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X <code>X(complex::Complex, electric\\_field\\_x, ElectricFieldX)</code> define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y <code>X(complex::Complex, electric\\_field\\_y, ElectricFieldY)</code> define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z <code>X(complex::Complex, electric\\_field\\_z, ElectricFieldZ)</code> define RAYX_X_MACRO_RAY_ATTR_ENERGY <code>X(double, energy, Energy)</code> define RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE <code>X(EventType, event\\_type, EventType)</code> define RAYX_X_MACRO_RAY_ATTR_OBJECT_ID <code>X(int32\\_t, object\\_id, ObjectId)</code> define RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH <code>X(double, optical\\_path\\_length, OpticalPathLength)</code> define RAYX_X_MACRO_RAY_ATTR_ORDER <code>X(int32\\_t, order, Order)</code> define RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID <code>X(int32\\_t, path\\_event\\_id, PathEventId)</code> define RAYX_X_MACRO_RAY_ATTR_PATH_ID <code>X(int32\\_t, path\\_id, PathId)</code> define RAYX_X_MACRO_RAY_ATTR_POSITION_X <code>X(double, position\\_x, PositionX)</code> define RAYX_X_MACRO_RAY_ATTR_POSITION_Y <code>X(double, position\\_y, PositionY)</code> define RAYX_X_MACRO_RAY_ATTR_POSITION_Z <code>X(double, position\\_z, PositionZ)</code> define RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER <code>X(RandCounter, rand\\_counter, RandCounter)</code> define RAYX_X_MACRO_RAY_ATTR_SOURCE_ID <code>X(int32\\_t, source\\_id, SourceId)</code> define X (type, name, flag) <code>static\\_assert(std::is\\_nothrow\\_move\\_constructible\\_v&amp;lt;type&amp;gt;);</code>"},{"location":"rayxCore/RayAttrMask_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr","title":"define RAYX_X_MACRO_RAY_ATTR","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR `/* multi line expression */`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_direction_x","title":"define RAYX_X_MACRO_RAY_ATTR_DIRECTION_X","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_X `X(double, direction_x, DirectionX)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_direction_y","title":"define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y `X(double, direction_y, DirectionY)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_direction_z","title":"define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z `X(double, direction_z, DirectionZ)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_electric_field_x","title":"define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X `X(complex::Complex, electric_field_x, ElectricFieldX)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_electric_field_y","title":"define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y `X(complex::Complex, electric_field_y, ElectricFieldY)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_electric_field_z","title":"define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z `X(complex::Complex, electric_field_z, ElectricFieldZ)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_energy","title":"define RAYX_X_MACRO_RAY_ATTR_ENERGY","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_ENERGY `X(double, energy, Energy)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_event_type","title":"define RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE `X(EventType, event_type, EventType)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_object_id","title":"define RAYX_X_MACRO_RAY_ATTR_OBJECT_ID","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_OBJECT_ID `X(int32_t, object_id, ObjectId)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_optical_path_length","title":"define RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH `X(double, optical_path_length, OpticalPathLength)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_order","title":"define RAYX_X_MACRO_RAY_ATTR_ORDER","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_ORDER `X(int32_t, order, Order)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_path_event_id","title":"define RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID `X(int32_t, path_event_id, PathEventId)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_path_id","title":"define RAYX_X_MACRO_RAY_ATTR_PATH_ID","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_PATH_ID `X(int32_t, path_id, PathId)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_position_x","title":"define RAYX_X_MACRO_RAY_ATTR_POSITION_X","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_POSITION_X `X(double, position_x, PositionX)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_position_y","title":"define RAYX_X_MACRO_RAY_ATTR_POSITION_Y","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_POSITION_Y `X(double, position_y, PositionY)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_position_z","title":"define RAYX_X_MACRO_RAY_ATTR_POSITION_Z","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_POSITION_Z `X(double, position_z, PositionZ)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_rand_counter","title":"define RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER `X(RandCounter, rand_counter, RandCounter)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-rayx_x_macro_ray_attr_source_id","title":"define RAYX_X_MACRO_RAY_ATTR_SOURCE_ID","text":"<pre><code>#define RAYX_X_MACRO_RAY_ATTR_SOURCE_ID `X(int32_t, source_id, SourceId)`\n</code></pre>"},{"location":"rayxCore/RayAttrMask_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `static_assert(std::is_nothrow_move_constructible_v&lt;type&gt;);`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/RayAttrMask.h</code></p>"},{"location":"rayxCore/RayAttrMask_8h_source/","title":"File RayAttrMask.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; RayAttrMask.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"Core.h\"\n#include \"Shader/ElectricField.h\"\n#include \"Shader/EventType.h\"\n#include \"Shader/Rand.h\"\n\n// TODO: all this macros should be invisible to the user\n// TODO: implement template based solution instead of macros\n\n#ifdef X\n#error macro 'X' must not be defined at this point\n#endif\n\n#define RAYX_X_MACRO_RAY_ATTR_PATH_ID             X(int32_t, path_id, PathId)\n#define RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID       X(int32_t, path_event_id, PathEventId)\n#define RAYX_X_MACRO_RAY_ATTR_POSITION_X          X(double, position_x, PositionX)\n#define RAYX_X_MACRO_RAY_ATTR_POSITION_Y          X(double, position_y, PositionY)\n#define RAYX_X_MACRO_RAY_ATTR_POSITION_Z          X(double, position_z, PositionZ)\n#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_X         X(double, direction_x, DirectionX)\n#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y         X(double, direction_y, DirectionY)\n#define RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z         X(double, direction_z, DirectionZ)\n#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X    X(complex::Complex, electric_field_x, ElectricFieldX)\n#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y    X(complex::Complex, electric_field_y, ElectricFieldY)\n#define RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z    X(complex::Complex, electric_field_z, ElectricFieldZ)\n#define RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH X(double, optical_path_length, OpticalPathLength)\n#define RAYX_X_MACRO_RAY_ATTR_ENERGY              X(double, energy, Energy)\n#define RAYX_X_MACRO_RAY_ATTR_ORDER               X(int32_t, order, Order)\n#define RAYX_X_MACRO_RAY_ATTR_OBJECT_ID           X(int32_t, object_id, ObjectId)\n#define RAYX_X_MACRO_RAY_ATTR_SOURCE_ID           X(int32_t, source_id, SourceId)\n#define RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE          X(EventType, event_type, EventType)\n#define RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER        X(RandCounter, rand_counter, RandCounter)\n\n#define RAYX_X_MACRO_RAY_ATTR                 \\\n    RAYX_X_MACRO_RAY_ATTR_PATH_ID             \\\n    RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID       \\\n    RAYX_X_MACRO_RAY_ATTR_POSITION_X          \\\n    RAYX_X_MACRO_RAY_ATTR_POSITION_Y          \\\n    RAYX_X_MACRO_RAY_ATTR_POSITION_Z          \\\n    RAYX_X_MACRO_RAY_ATTR_DIRECTION_X         \\\n    RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y         \\\n    RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z         \\\n    RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X    \\\n    RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y    \\\n    RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z    \\\n    RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH \\\n    RAYX_X_MACRO_RAY_ATTR_ENERGY              \\\n    RAYX_X_MACRO_RAY_ATTR_ORDER               \\\n    RAYX_X_MACRO_RAY_ATTR_OBJECT_ID           \\\n    RAYX_X_MACRO_RAY_ATTR_SOURCE_ID           \\\n    RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE          \\\n    RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER\n\nnamespace rayx {\n\n#define X(type, name, flag) static_assert(std::is_nothrow_move_constructible_v&lt;type&gt;);  // ensure efficient moves\nRAYX_X_MACRO_RAY_ATTR\n#undef X\n\nenum class RAYX_API RayAttrMask : uint32_t {\n    PathId            = 1 &lt;&lt; 0,\n    PathEventId       = 1 &lt;&lt; 1,\n    PositionX         = 1 &lt;&lt; 2,\n    PositionY         = 1 &lt;&lt; 3,\n    PositionZ         = 1 &lt;&lt; 4,\n    DirectionX        = 1 &lt;&lt; 5,\n    DirectionY        = 1 &lt;&lt; 6,\n    DirectionZ        = 1 &lt;&lt; 7,\n    ElectricFieldX    = 1 &lt;&lt; 8,\n    ElectricFieldY    = 1 &lt;&lt; 9,\n    ElectricFieldZ    = 1 &lt;&lt; 10,\n    OpticalPathLength = 1 &lt;&lt; 11,\n    Energy            = 1 &lt;&lt; 12,\n    Order             = 1 &lt;&lt; 13,\n    ObjectId          = 1 &lt;&lt; 14,\n    SourceId          = 1 &lt;&lt; 15,\n    EventType         = 1 &lt;&lt; 16,\n    RandCounter       = 1 &lt;&lt; 17,\n    RayAttrMaskCount  = 18,\n\n    Position      = PositionX | PositionY | PositionZ,\n    Direction     = DirectionX | DirectionY | DirectionZ,\n    ElectricField = ElectricFieldX | ElectricFieldY | ElectricFieldZ,\n\n    None = 0,\n    All  = (1 &lt;&lt; RayAttrMaskCount) - 1,\n};\n\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask operator|(const RayAttrMask lhs, const RayAttrMask rhs) {\n    return static_cast&lt;RayAttrMask&gt;(static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(lhs) | static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(rhs));\n}\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask operator&amp;(const RayAttrMask lhs, const RayAttrMask rhs) {\n    return static_cast&lt;RayAttrMask&gt;(static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(lhs) &amp; static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(rhs));\n}\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask operator^(const RayAttrMask lhs, const RayAttrMask rhs) {\n    return static_cast&lt;RayAttrMask&gt;(static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(lhs) ^ static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(rhs));\n}\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask operator~(const RayAttrMask lhs) {\n    return static_cast&lt;RayAttrMask&gt;(~static_cast&lt;std::underlying_type_t&lt;RayAttrMask&gt;&gt;(lhs)) &amp; RayAttrMask::All;\n}\nRAYX_API RAYX_FN_ACC constexpr inline bool operator!(const RayAttrMask lhs) { return lhs == RayAttrMask::None; }\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask&amp; operator|=(RayAttrMask&amp; lhs, const RayAttrMask rhs) { return lhs = lhs | rhs; }\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask&amp; operator&amp;=(RayAttrMask&amp; lhs, const RayAttrMask rhs) { return lhs = lhs &amp; rhs; }\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask&amp; operator^=(RayAttrMask&amp; lhs, const RayAttrMask rhs) { return lhs = lhs ^ rhs; }\n\nRAYX_API RAYX_FN_ACC constexpr inline bool contains(const RayAttrMask haystack, const RayAttrMask needle) { return (haystack &amp; needle) == needle; }\n\nRAYX_API RAYX_FN_ACC constexpr inline RayAttrMask exclude(const RayAttrMask haystack, const RayAttrMask needle) { return haystack &amp; ~needle; }\n\nRAYX_API int countSetBits(const RayAttrMask mask);\n\nRAYX_API bool isFlag(const RayAttrMask attr);\n\nRAYX_API std::string to_string(const RayAttrMask attr);\n\nRAYX_API std::vector&lt;std::string&gt; getRayAttrNames();\n\nRAYX_API RayAttrMask rayAttrStringsToRayAttrMask(const std::vector&lt;std::string&gt;&amp; strings);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Rays_8h/","title":"File Rays.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Rays.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Debug/Instrumentor.h\"</code></li> <li><code>#include \"RayAttrMask.h\"</code></li> </ul>"},{"location":"rayxCore/Rays_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Rays_8h/#classes","title":"Classes","text":"Type Name struct Rays A structure representing a collection of rays and their attributes. Each attribute is stored as a vector, allowing for efficient storage and manipulation of multiple rays. The Rays structure supports move semantics for efficient transfers, but disables copy semantics to prevent accidental costly copies. Use the<code>copy()</code> method to create an explicit copy when needed."},{"location":"rayxCore/Rays_8h/#macros","title":"Macros","text":"Type Name define X (type, name, flag) <code>std::vector&amp;lt;type&amp;gt; name;</code> define X (type, name, flag) <code>std::vector&amp;lt;type&amp;gt; name;</code> define X (type, name, flag) <code>std::vector&amp;lt;type&amp;gt; name;</code>"},{"location":"rayxCore/Rays_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"rayxCore/Rays_8h/#define-x","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `std::vector&lt;type&gt; name;`\n</code></pre>"},{"location":"rayxCore/Rays_8h/#define-x_1","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `std::vector&lt;type&gt; name;`\n</code></pre>"},{"location":"rayxCore/Rays_8h/#define-x_2","title":"define X","text":"<pre><code>#define X (\n    type,\n    name,\n    flag\n) `std::vector&lt;type&gt; name;`\n</code></pre> <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Rays.h</code></p>"},{"location":"rayxCore/Rays_8h_source/","title":"File Rays.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Rays.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\n#include \"Debug/Instrumentor.h\"\n#include \"RayAttrMask.h\"\n\nnamespace rayx {\n\nstruct RAYX_API Rays {\n  protected:\n    Rays(const Rays&amp;) = default;\n    Rays&amp; operator=(const Rays&amp;) = default;\n\n  public:\n    Rays()                  = default;\n    Rays(Rays&amp;&amp;)            = default;\n    Rays&amp; operator=(Rays&amp;&amp;) = default;\n\n#define X(type, name, flag) std::vector&lt;type&gt; name;\n\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n    glm::dvec3 position(const int i) const { return glm::dvec3(position_x[i], position_y[i], position_z[i]); }\n    void position(const int i, const glm::dvec3 position) {\n        position_x[i] = position.x;\n        position_y[i] = position.y;\n        position_z[i] = position.z;\n    }\n\n    glm::dvec3 direction(const int i) const { return glm::dvec3(direction_x[i], direction_y[i], direction_z[i]); }\n    void direction(const int i, const glm::dvec3 direction) {\n        direction_x[i] = direction.x;\n        direction_y[i] = direction.y;\n        direction_z[i] = direction.z;\n    }\n\n    ElectricField electric_field(const int i) const { return ElectricField(electric_field_x[i], electric_field_y[i], electric_field_z[i]); }\n    void electric_field(const int i, const ElectricField electric_field) {\n        electric_field_x[i] = electric_field.x;\n        electric_field_y[i] = electric_field.y;\n        electric_field_z[i] = electric_field.z;\n    }\n\n    [[nodiscard]] Rays copy() const;\n\n    RayAttrMask attrMask() const;\n\n    bool contains(const RayAttrMask attr) const;\n\n    bool empty() const;\n\n    int size() const;\n\n    int numPaths() const;\n\n    Rays&amp; append(const Rays&amp; other);\n\n    [[nodiscard]] static Rays concat(const std::vector&lt;Rays&gt;&amp; rays_list);\n\n    [[nodiscard]] Rays sortByObjectId() const;\n\n    [[nodiscard]] Rays sortByPathIdAndPathEventId() const;\n\n    template &lt;typename Compare&gt;\n    [[nodiscard]] Rays sort(Compare comp) const;\n\n    Rays&amp; filterByAttrMask(const RayAttrMask mask);\n\n    [[nodiscard]] Rays filterByObjectId(const int object_id) const;\n\n    [[nodiscard]] Rays filterByLastEventInPath() const;\n\n    template &lt;typename Pred&gt;\n    [[nodiscard]] Rays filter(Pred pred) const;\n\n    template &lt;typename Pred&gt;\n    int count(Pred pred) const;\n\n    bool isValid() const;\n\n    // TODO: implement helper methods to iterate over attributes, to get rid of most of the X-macros\n};\n\ntemplate &lt;typename Compare&gt;\nRays Rays::sort(Compare comp) const {\n    RAYX_PROFILE_FUNCTION_STDOUT();\n\n    const auto attr = attrMask();\n    const auto n    = size();\n\n    auto indices = std::vector&lt;int&gt;(n);\n    std::iota(indices.begin(), indices.end(), 0);\n    std::sort(indices.begin(), indices.end(), comp);\n\n    Rays result;\n#define X(type, name, flag)                                            \\\n    if (!!(attr &amp; RayAttrMask::flag)) {                                \\\n        result.name.resize(name.size());                               \\\n        for (int i = 0; i &lt; n; ++i) result.name[i] = name[indices[i]]; \\\n    }\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n    return result;\n}\n\ntemplate &lt;typename Pred&gt;\nRays Rays::filter(Pred pred) const {\n    RAYX_PROFILE_FUNCTION_STDOUT();\n\n    const auto attr = attrMask();\n    const auto n    = size();\n\n    auto indices = std::vector&lt;int&gt;{};\n    for (int i = 0; i &lt; n; ++i)\n        if (pred(i)) indices.push_back(i);\n\n    Rays result;\n#define X(type, name, flag)                                                                                           \\\n    if (!!(attr &amp; RayAttrMask::flag)) {                                                                               \\\n        result.name.resize(indices.size());                                                                           \\\n        std::transform(indices.begin(), indices.end(), result.name.begin(), [this](const int i) { return name[i]; }); \\\n    }\n    RAYX_X_MACRO_RAY_ATTR\n#undef X\n\n    return result;\n}\n\ntemplate &lt;typename Pred&gt;\nint Rays::count(Pred pred) const {\n    const int sz = size();\n    int count    = 0;\n    for (int i = 0; i &lt; sz; ++i)\n        if (pred(i)) ++count;\n    return count;\n}\n\nstatic_assert(std::is_nothrow_move_constructible_v&lt;Rays&gt;);  // ensure efficient moves, when used in std::vector&lt;Rays&gt;\n\nbool RAYX_API operator==(const Rays&amp; lhs, const Rays&amp; rhs);\nbool RAYX_API operator!=(const Rays&amp; lhs, const Rays&amp; rhs);\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/Variant_8h/","title":"File Variant.h","text":"<p>FileList &gt; Intern &gt; rayx-core &gt; src &gt; Variant.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Core.h\"</code></li> <li><code>#include &lt;variant&gt;</code></li> </ul>"},{"location":"rayxCore/Variant_8h/#namespaces","title":"Namespaces","text":"Type Name namespace rayx"},{"location":"rayxCore/Variant_8h/#classes","title":"Classes","text":"Type Name class Variant &lt;typename Base, Ts&gt; <p>The documentation for this class was generated from the following file <code>Intern/rayx-core/src/Variant.h</code></p>"},{"location":"rayxCore/Variant_8h_source/","title":"File Variant.h","text":"<p>File List &gt; Intern &gt; rayx-core &gt; src &gt; Variant.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"Core.h\"\n\n#if defined(RAYX_CUDA_ENABLED)\n#include &lt;cuda/std/variant&gt;\n#else\n#include &lt;variant&gt;\n#endif\n\n#if defined(RAYX_CUDA_ENABLED)\nnamespace variant = cuda::std;\n#else\nnamespace variant = std;\n#endif\n\nnamespace rayx {\n\ntemplate &lt;typename Base, typename... Ts&gt;\nclass Variant : public Base {\n  public:\n    Variant() = default;\n\n    Variant(const Variant&amp;) = default;\n    Variant(Variant&amp;&amp;)      = default;\n\n    Variant&amp; operator=(const Variant&amp;) = default;\n    Variant&amp; operator=(Variant&amp;&amp;)      = default;\n\n    template &lt;typename T&gt;\n        requires(std::is_constructible_v&lt;variant::variant&lt;Ts...&gt;, T&gt;)\n    Variant(const T&amp; value) : m_variant(value) {}\n\n    template &lt;typename T&gt;\n        requires(std::is_constructible_v&lt;variant::variant&lt;Ts...&gt;, T&gt;)\n    Variant(T&amp;&amp; value) : m_variant(std::move(value)) {}\n\n    template &lt;typename T&gt;\n        requires(std::is_assignable_v&lt;variant::variant&lt;Ts...&gt;&amp;, const T&amp;&gt;)\n    Variant&amp; operator=(const T&amp; other) {\n        m_variant = other;\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n        requires(std::is_assignable_v&lt;variant::variant&lt;Ts...&gt;&amp;, T&gt;)\n    Variant&amp; operator=(T&amp;&amp; value) {\n        m_variant = std::move(value);\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n    RAYX_FN_ACC bool is() const {\n        return variant::holds_alternative&lt;T&gt;(m_variant);\n    }\n\n    template &lt;typename T&gt;\n    RAYX_FN_ACC T&amp; get() {\n        return variant::get&lt;T&gt;(m_variant);\n    }\n\n    template &lt;typename T&gt;\n    RAYX_FN_ACC const T&amp; get() const {\n        return variant::get&lt;T&gt;(m_variant);\n    }\n\n    template &lt;typename Visitor&gt;\n    RAYX_FN_ACC decltype(auto) visit(const Visitor&amp; visitor) const {\n        return variant::visit(visitor, m_variant);\n    }\n\n    template &lt;typename Visitor&gt;\n    RAYX_FN_ACC decltype(auto) visit(Visitor&amp;&amp; visitor) const {\n        return variant::visit(std::forward&lt;Visitor&gt;(visitor), m_variant);\n    }\n\n  private:\n    variant::variant&lt;Ts...&gt; m_variant;\n};\n\n}  // namespace rayx\n</code></pre>"},{"location":"rayxCore/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace glm </li> <li>namespace rayx <ul> <li>namespace BlockSizeConstraint </li> <li>namespace complex </li> <li>namespace detail </li> <li>namespace xml </li> </ul> </li> <li>namespace rayx </li> <li>namespace rayx </li> </ul>"},{"location":"rayxCore/classes/","title":"Class Index","text":""},{"location":"rayxCore/classes/#a","title":"a","text":"<ul> <li>All</li> <li>AllElements</li> <li>AllSources</li> <li>AtLeast (rayx::BlockSizeConstraint)</li> <li>AtMost (rayx::BlockSizeConstraint)</li> </ul>"},{"location":"rayxCore/classes/#b","title":"b","text":"<ul> <li>BatchConfig (rayx::GenRays)</li> <li>BeamlineConfig (rayx::Resources)</li> <li>BeamlineNode (rayx)</li> <li>BehaviourTypes (rayx::detail)</li> <li>ByIndices</li> </ul>"},{"location":"rayxCore/classes/#c","title":"c","text":"<ul> <li>CircleSource (rayx)</li> <li>CoatingTypes (rayx::detail)</li> <li>CollisionPoint (rayx)</li> <li>CollisionWithElement (rayx)</li> <li>ComplexFresnelCoeffs (rayx)</li> <li>ConstIterator (rayx::DesignMap)</li> <li>ConstState (rayx)</li> <li>Crystal (rayx::detail::BehaviourTypes)</li> <li>Cubic (rayx::detail::SurfaceTypes)</li> <li>CutoutTypes (rayx::detail)</li> </ul>"},{"location":"rayxCore/classes/#d","title":"d","text":"<ul> <li>DatEntry (rayx)</li> <li>DatFile (rayx)</li> <li>Deg (rayx)</li> <li>DesignElement (rayx)</li> <li>DesignMap (rayx)</li> <li>DesignSource (rayx)</li> <li>Device (rayx::DeviceConfig)</li> <li>DeviceConfig (rayx)</li> <li>DeviceTracer (rayx)</li> <li>DipoleSource (rayx)</li> </ul>"},{"location":"rayxCore/classes/#e","title":"e","text":"<ul> <li>Elliptical (rayx::detail::CutoutTypes)</li> <li>EnergyDistributionDataBase (rayx)</li> <li>EnergyDistributionList (rayx)</li> <li>Exact (rayx::BlockSizeConstraint)</li> <li>Exit (rayx)</li> </ul>"},{"location":"rayxCore/classes/#f","title":"f","text":"<ul> <li>Foil (rayx::detail::BehaviourTypes)</li> <li>FresnelCoeffs (rayx)</li> </ul>"},{"location":"rayxCore/classes/#g","title":"g","text":"<ul> <li>GenRays (rayx)</li> <li>Grating (rayx::detail::BehaviourTypes)</li> <li>Group (rayx)</li> </ul>"},{"location":"rayxCore/classes/#h","title":"h","text":"<ul> <li>HardEdge (rayx)</li> </ul>"},{"location":"rayxCore/classes/#i","title":"i","text":"<ul> <li>IgnoreLog (rayx)</li> <li>ImagePlane (rayx::detail::BehaviourTypes)</li> <li>InRange (rayx::BlockSizeConstraint)</li> <li>InstrumentationTimer (rayx)</li> <li>Iterator (rayx::DesignMap)</li> </ul>"},{"location":"rayxCore/classes/#l","title":"l","text":"<ul> <li>LightSourceBase (rayx)</li> <li>Log (rayx)</li> </ul>"},{"location":"rayxCore/classes/#m","title":"m","text":"<ul> <li>MaterialTables (rayx)</li> <li>MatrixSource (rayx)</li> <li>MegaKernelTracer (rayx)</li> <li>Mirror (rayx::detail::BehaviourTypes)</li> <li>MultilayerCoating (rayx::detail::CoatingTypes)</li> <li>MutableState (rayx)</li> </ul>"},{"location":"rayxCore/classes/#n","title":"n","text":"<ul> <li>NffEntry (rayx)</li> <li>NffTable (rayx)</li> <li>None (rayx::BlockSizeConstraint)</li> <li>None</li> </ul>"},{"location":"rayxCore/classes/#o","title":"o","text":"<ul> <li>ObjectIndexMask (rayx)</li> <li>ObjectMask (rayx)</li> <li>ObjectTransform (rayx)</li> <li>OneCoating (rayx::detail::CoatingTypes)</li> <li>OpticalElement (rayx)</li> <li>OpticalElementAndTransform (rayx)</li> </ul>"},{"location":"rayxCore/classes/#p","title":"p","text":"<ul> <li>PalikEntry (rayx)</li> <li>PalikTable (rayx)</li> <li>Parser (rayx::xml)</li> <li>PixelSource (rayx)</li> <li>Plane (rayx::detail::SurfaceTypes)</li> <li>PointSource (rayx)</li> <li>PsiAndStokes (rayx)</li> </ul>"},{"location":"rayxCore/classes/#q","title":"q","text":"<ul> <li>Quadric (rayx::detail::SurfaceTypes)</li> </ul>"},{"location":"rayxCore/classes/#r","title":"r","text":"<ul> <li>Rad (rayx)</li> <li>Rand (rayx)</li> <li>Ray (rayx::detail)</li> <li>RayListSource (rayx)</li> <li>Rays (rayx)</li> <li>RaysBuf (rayx)</li> <li>RaysPtr (rayx)</li> <li>Rect (rayx::detail::CutoutTypes)</li> <li>ResourceHandler (rayx)</li> <li>Resources (rayx)</li> <li>RotationBase (rayx)</li> <li>RZP (rayx::detail::BehaviourTypes)</li> </ul>"},{"location":"rayxCore/classes/#s","title":"s","text":"<ul> <li>SeparateEnergies (rayx)</li> <li>SimpleUndulatorSource (rayx)</li> <li>Slit (rayx::detail::BehaviourTypes)</li> <li>SlopeError (rayx)</li> <li>SoftEdge (rayx)</li> <li>SourceConfig (rayx::GenRays)</li> <li>SourceState</li> <li>SubstrateOnly (rayx::detail::CoatingTypes)</li> <li>SurfaceTypes (rayx::detail)</li> </ul>"},{"location":"rayxCore/classes/#t","title":"t","text":"<ul> <li>Toroid (rayx::detail::SurfaceTypes)</li> <li>Tracer (rayx)</li> <li>Trapezoid (rayx::detail::CutoutTypes)</li> </ul>"},{"location":"rayxCore/classes/#u","title":"u","text":"<ul> <li>Undefined (rayx)</li> <li>Unlimited (rayx::detail::CutoutTypes)</li> </ul>"},{"location":"rayxCore/classes/#v","title":"v","text":"<ul> <li>Variant (rayx)</li> <li>Verb (rayx)</li> </ul>"},{"location":"rayxCore/classes/#w","title":"w","text":"<ul> <li>Warn (rayx)</li> </ul>"},{"location":"rayxCore/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class rayx::BeamlineNode Base class for all nodes in the beamline hierarchy (scene/model graph). <ul> <li>class rayx::DesignElement </li> <li>class rayx::DesignSource </li> <li>class rayx::Group </li> </ul> </li> <li>class rayx::LightSourceBase <ul> <li>class rayx::CircleSource </li> <li>class rayx::DipoleSource </li> <li>class rayx::MatrixSource </li> <li>class rayx::PixelSource </li> <li>class rayx::PointSource </li> <li>class rayx::SimpleUndulatorSource </li> </ul> </li> <li>class rayx::DesignMap </li> <li>class rayx::DesignMap::ConstIterator </li> <li>class rayx::DesignMap::Iterator </li> <li>class rayx::DeviceTracer DeviceTracer is an interface to a tracer implementation we need this interface to remove the actual implementation from the rayx api. <ul> <li>class rayx::MegaKernelTracer </li> </ul> </li> <li>class rayx::InstrumentationTimer </li> <li>class rayx::ObjectIndexMask </li> <li>class rayx::ObjectMask </li> <li>class rayx::ResourceHandler </li> <li>class rayx::Tracer </li> <li>class rayx::Undefined </li> <li>struct rayx::BlockSizeConstraint::AtLeast </li> <li>struct rayx::BlockSizeConstraint::AtMost </li> <li>struct rayx::BlockSizeConstraint::Exact </li> <li>struct rayx::BlockSizeConstraint::InRange </li> <li>struct rayx::BlockSizeConstraint::None </li> <li>struct rayx::CollisionPoint </li> <li>struct rayx::CollisionWithElement </li> <li>struct rayx::ComplexFresnelCoeffs </li> <li>struct rayx::ConstState stores all constant buffers </li> <li>struct rayx::DatEntry </li> <li>struct rayx::DatFile </li> <li>struct rayx::Deg </li> <li>struct rayx::DeviceConfig </li> <li>struct rayx::DeviceConfig::Device </li> <li>struct rayx::EnergyDistributionDataBase </li> <li>struct rayx::EnergyDistributionList </li> <li>struct rayx::Exit </li> <li>struct rayx::FresnelCoeffs </li> <li>struct rayx::GenRays </li> <li>struct rayx::GenRays::BatchConfig holds configuration state of one batch </li> <li>struct rayx::GenRays::SourceConfig holds configuration state of sources </li> <li>struct rayx::HardEdge </li> <li>struct rayx::IgnoreLog </li> <li>struct rayx::Log </li> <li>struct rayx::MaterialTables </li> <li>struct rayx::MutableState stores all mutable buffers </li> <li>struct rayx::NffEntry This struct represents one line of a .nff file. </li> <li>struct rayx::NffTable </li> <li>struct rayx::ObjectTransform </li> <li>struct rayx::OpticalElement Structure to represent an element in the ray tracing simulation. </li> <li>struct rayx::OpticalElementAndTransform </li> <li>struct rayx::PalikEntry This struct represents one line of a .NKP file. </li> <li>struct rayx::PalikTable </li> <li>struct rayx::PsiAndStokes </li> <li>struct rayx::Rad </li> <li>struct rayx::Rand </li> <li>struct rayx::RayListSource </li> <li>struct rayx::Rays A structure representing a collection of rays and their attributes. Each attribute is stored as a vector, allowing for efficient storage and manipulation of multiple rays. The Rays structure supports move semantics for efficient transfers, but disables copy semantics to prevent accidental costly copies. Use the<code>copy()</code> method to create an explicit copy when needed.</li> <li>struct rayx::RaysBuf </li> <li>struct rayx::RaysPtr </li> <li>struct rayx::Resources </li> <li>struct rayx::Resources::BeamlineConfig holds configuration state of allocated resources. required to trace correctly </li> <li>struct rayx::RotationBase </li> <li>struct rayx::SeparateEnergies If there is only one spike (i.e. m_numberOfEnergies = 1), then this spike is at <code>m_centerEnergy</code> .</li> <li>struct rayx::SlopeError Structure to represent slope error parameters. </li> <li>struct rayx::SoftEdge </li> <li>struct rayx::Verb </li> <li>struct rayx::Warn </li> <li>struct rayx::detail::BehaviourTypes <ul> <li>class rayx::Variant </li> </ul> </li> <li>struct rayx::detail::BehaviourTypes::Crystal </li> <li>struct rayx::detail::BehaviourTypes::Foil </li> <li>struct rayx::detail::BehaviourTypes::Grating </li> <li>struct rayx::detail::BehaviourTypes::ImagePlane </li> <li>struct rayx::detail::BehaviourTypes::Mirror </li> <li>struct rayx::detail::BehaviourTypes::RZP </li> <li>struct rayx::detail::BehaviourTypes::Slit </li> <li>struct rayx::detail::CoatingTypes <ul> <li>class rayx::Variant </li> </ul> </li> <li>struct rayx::detail::CoatingTypes::MultilayerCoating </li> <li>struct rayx::detail::CoatingTypes::OneCoating </li> <li>struct rayx::detail::CoatingTypes::SubstrateOnly </li> <li>struct rayx::detail::CutoutTypes <ul> <li>class rayx::Variant </li> </ul> </li> <li>struct rayx::detail::CutoutTypes::Elliptical </li> <li>struct rayx::detail::CutoutTypes::Rect </li> <li>struct rayx::detail::CutoutTypes::Trapezoid </li> <li>struct rayx::detail::CutoutTypes::Unlimited </li> <li>struct rayx::detail::Ray </li> <li>struct rayx::detail::SurfaceTypes <ul> <li>class rayx::Variant </li> </ul> </li> <li>struct rayx::detail::SurfaceTypes::Cubic </li> <li>struct rayx::detail::SurfaceTypes::Plane </li> <li>struct rayx::detail::SurfaceTypes::Quadric </li> <li>struct rayx::detail::SurfaceTypes::Toroid </li> <li>struct rayx::xml::Parser </li> <li>struct rayx::GenRays::SourceState </li> <li>struct rayx::ObjectMask::All </li> <li>struct rayx::ObjectMask::AllElements </li> <li>struct rayx::ObjectMask::AllSources </li> <li>struct rayx::ObjectMask::ByIndices </li> <li>struct rayx::ObjectMask::None </li> <li>class Base <ul> <li>class rayx::Variant </li> </ul> </li> </ul>"},{"location":"rayxCore/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"rayxCore/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"rayxCore/class_members/","title":"Class Members","text":""},{"location":"rayxCore/class_members/#a","title":"a","text":"<ul> <li>asElement (rayx::BeamlineNode)</li> <li>asGroup (rayx::BeamlineNode)</li> <li>asSource (rayx::BeamlineNode)</li> <li>atLeast (rayx::BlockSizeConstraint::InRange)</li> <li>atMost (rayx::BlockSizeConstraint::InRange)</li> <li>attrRecordMask (rayx::ConstState)</li> <li>as_behaviourType (rayx::DesignMap)</li> <li>as_bool (rayx::DesignMap)</li> <li>as_centralBeamStop (rayx::DesignMap)</li> <li>as_crystalType (rayx::DesignMap)</li> <li>as_curvatureType (rayx::DesignMap)</li> <li>as_cutout (rayx::DesignMap)</li> <li>as_cylinderDirection (rayx::DesignMap)</li> <li>as_designPlane (rayx::DesignMap)</li> <li>as_dmat4x4 (rayx::DesignMap)</li> <li>as_double (rayx::DesignMap)</li> <li>as_dvec4 (rayx::DesignMap)</li> <li>as_electronEnergyOrientation (rayx::DesignMap)</li> <li>as_elementType (rayx::DesignMap)</li> <li>as_energyDistType (rayx::DesignMap)</li> <li>as_energyDistributionType (rayx::DesignMap)</li> <li>as_energySpreadType (rayx::DesignMap)</li> <li>as_energySpreadUnit (rayx::DesignMap)</li> <li>as_eventType (rayx::DesignMap)</li> <li>as_figureRotation (rayx::DesignMap)</li> <li>as_gratingMount (rayx::DesignMap)</li> <li>as_int (rayx::DesignMap)</li> <li>as_map (rayx::DesignMap)</li> <li>as_material (rayx::DesignMap)</li> <li>as_openingShape (rayx::DesignMap)</li> <li>as_rad (rayx::DesignMap)</li> <li>as_rayList (rayx::DesignMap)</li> <li>as_sigmaType (rayx::DesignMap)</li> <li>as_sourceDist (rayx::DesignMap)</li> <li>as_string (rayx::DesignMap)</li> <li>as_surface (rayx::DesignMap)</li> <li>as_surfaceCoatingType (rayx::DesignMap)</li> <li>availableDeviceTypes (rayx::DeviceConfig)</li> <li>accumulateLightSourcesWorldPositions (rayx::Group)</li> <li>addChild (rayx::Group)</li> <li>Acc (rayx::MegaKernelTracer)</li> <li>all (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>allElements (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>allSources (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>append (rayx::Rays)</li> <li>attrMask (rayx::Rays)</li> <li>addLookUpPath (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_members/#b","title":"b","text":"<ul> <li>begin (rayx::DesignMap, rayx::Group)</li> <li>byIndices (rayx::ObjectIndexMask, rayx::ObjectMask)</li> </ul>"},{"location":"rayxCore/class_members/#c","title":"c","text":"<ul> <li>clone (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignMap, rayx::DesignSource, rayx::Group)</li> <li>CircleSource (rayx::CircleSource)</li> <li>compile (rayx::DesignElement)</li> <li>ConstIterator (rayx::DesignMap::ConstIterator)</li> <li>continous (rayx::EnergyDistributionList)</li> <li>calcMinimalMaterialTables (rayx::Group)</li> <li>cbegin (rayx::Group)</li> <li>cend (rayx::Group)</li> <li>compileElements (rayx::Group)</li> <li>ctraverse (rayx::Group)</li> <li>compactEvents (rayx::MegaKernelTracer)</li> <li>cos (rayx::Rad)</li> <li>counter (rayx::Rand)</li> <li>concat (rayx::Rays)</li> <li>contains (rayx::Rays)</li> <li>copy (rayx::Rays)</li> <li>count (rayx::Rays)</li> </ul>"},{"location":"rayxCore/class_members/#d","title":"d","text":"<ul> <li>dump (rayx::DatFile)</li> <li>Deg (rayx::Deg)</li> <li>deg (rayx::Deg)</li> <li>DesignElement (rayx::DesignElement)</li> <li>DesignMap (rayx::DesignMap)</li> <li>difference_type (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>DesignSource (rayx::DesignSource)</li> <li>DeviceConfig (rayx::DeviceConfig)</li> <li>devices (rayx::DeviceConfig)</li> <li>disableAllDevices (rayx::DeviceConfig)</li> <li>disableDeviceByIndex (rayx::DeviceConfig)</li> <li>dumpDevices (rayx::DeviceConfig)</li> <li>DipoleSource (rayx::DipoleSource)</li> <li>d_energyDistributionListEnergies (rayx::GenRays)</li> <li>d_energyDistributionListWeights (rayx::GenRays)</li> <li>d_rayListSources (rayx::GenRays)</li> <li>d_rays (rayx::GenRays, rayx::GenRays::BatchConfig)</li> <li>Dim (rayx::MegaKernelTracer, rayx::Resources)</li> <li>direction (rayx::Rays, rayx::RaysPtr, rayx::detail::Ray)</li> <li>d_compactEventsBatch (rayx::Resources)</li> <li>d_elements (rayx::Resources)</li> <li>d_eventStoreFlags (rayx::Resources)</li> <li>d_eventStoreFlagsPrefixSum (rayx::Resources)</li> <li>d_eventsBatch (rayx::Resources)</li> <li>d_materialIndices (rayx::Resources)</li> <li>d_materialTable (rayx::Resources)</li> <li>d_objectRecordMask (rayx::Resources)</li> <li>d_objectTransforms (rayx::Resources)</li> </ul>"},{"location":"rayxCore/class_members/#e","title":"e","text":"<ul> <li>elementIndex (rayx::CollisionWithElement)</li> <li>elements (rayx::ConstState)</li> <li>end (rayx::DesignMap, rayx::Group)</li> <li>enableAllDevices (rayx::DeviceConfig)</li> <li>enableBestDevice (rayx::DeviceConfig)</li> <li>enableDeviceByIndex (rayx::DeviceConfig)</li> <li>enabledDevicesCount (rayx::DeviceConfig)</li> <li>enable (rayx::DeviceConfig::Device)</li> <li>EnergyDistributionList (rayx::EnergyDistributionDataBase)</li> <li>energies (rayx::EnergyDistributionList)</li> <li>Exit (rayx::Exit)</li> <li>events (rayx::MutableState)</li> <li>element (rayx::OpticalElementAndTransform)</li> <li>electric_field (rayx::Rays, rayx::RaysPtr, rayx::detail::Ray)</li> <li>empty (rayx::Rays)</li> <li>energy (rayx::detail::Ray)</li> <li>event_type (rayx::detail::Ray)</li> <li>energyDistribution (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_members/#f","title":"f","text":"<ul> <li>filename (rayx::Exit)</li> <li>findElement (rayx::Group)</li> <li>findElementByName (rayx::Group)</li> <li>findGroup (rayx::Group)</li> <li>findGroupByName (rayx::Group)</li> <li>findNode (rayx::Group)</li> <li>findNodeByName (rayx::Group)</li> <li>findNodeByObjectId (rayx::Group)</li> <li>findObjectIdByNode (rayx::Group)</li> <li>findSource (rayx::Group)</li> <li>findSourceByName (rayx::Group)</li> <li>filter (rayx::Rays)</li> <li>filterByAttrMask (rayx::Rays)</li> <li>filterByLastEventInPath (rayx::Rays)</li> <li>filterByObjectId (rayx::Rays)</li> <li>fileExists (rayx::ResourceHandler)</li> <li>forward (rayx::RotationBase)</li> </ul>"},{"location":"rayxCore/class_members/#g","title":"g","text":"<ul> <li>getName (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getObjectId (rayx::BeamlineNode)</li> <li>getOrientation (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getParent (rayx::BeamlineNode)</li> <li>getPosition (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getRoot (rayx::BeamlineNode)</li> <li>getWorldOrientation (rayx::BeamlineNode)</li> <li>getWorldPosition (rayx::BeamlineNode)</li> <li>genRay (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>getDirection (rayx::CircleSource)</li> <li>getAdditionalOrder (rayx::DesignElement)</li> <li>getArmLength (rayx::DesignElement)</li> <li>getAzimuthalAngle (rayx::DesignElement)</li> <li>getBehaviourType (rayx::DesignElement)</li> <li>getCentralBeamstop (rayx::DesignElement)</li> <li>getCoating (rayx::DesignElement)</li> <li>getCrystalMaterial (rayx::DesignElement)</li> <li>getCrystalType (rayx::DesignElement)</li> <li>getCurvatureType (rayx::DesignElement)</li> <li>getCutout (rayx::DesignElement)</li> <li>getDSpacing2 (rayx::DesignElement)</li> <li>getDesignAlphaAngle (rayx::DesignElement)</li> <li>getDesignBetaAngle (rayx::DesignElement)</li> <li>getDesignEnergy (rayx::DesignElement)</li> <li>getDesignGrazingIncAngle (rayx::DesignElement)</li> <li>getDesignMeridionalEntranceArmLength (rayx::DesignElement)</li> <li>getDesignMeridionalExitArmLength (rayx::DesignElement)</li> <li>getDesignOrderOfDiffraction (rayx::DesignElement)</li> <li>getDesignPlane (rayx::DesignElement)</li> <li>getDesignSagittalEntranceArmLength (rayx::DesignElement)</li> <li>getDesignSagittalExitArmLength (rayx::DesignElement)</li> <li>getDeviationAngle (rayx::DesignElement)</li> <li>getDistancePreceding (rayx::DesignElement)</li> <li>getEntranceArmLength (rayx::DesignElement)</li> <li>getExitArmLength (rayx::DesignElement)</li> <li>getExpertsCubic (rayx::DesignElement)</li> <li>getExpertsOptics (rayx::DesignElement)</li> <li>getFigureRotation (rayx::DesignElement)</li> <li>getFresnelZOffset (rayx::DesignElement)</li> <li>getGlobalCutout (rayx::DesignElement)</li> <li>getGrazingIncAngle (rayx::DesignElement)</li> <li>getImageType (rayx::DesignElement)</li> <li>getLineDensity (rayx::DesignElement)</li> <li>getLongHalfAxisA (rayx::DesignElement)</li> <li>getLongRadius (rayx::DesignElement)</li> <li>getMaterial (rayx::DesignElement)</li> <li>getMaterialCoating (rayx::DesignElement)</li> <li>getOffsetAngle (rayx::DesignElement)</li> <li>getOffsetAngleType (rayx::DesignElement)</li> <li>getOpeningHeight (rayx::DesignElement)</li> <li>getOpeningShape (rayx::DesignElement)</li> <li>getOpeningWidth (rayx::DesignElement)</li> <li>getOrderOfDiffraction (rayx::DesignElement)</li> <li>getParameterA11 (rayx::DesignElement)</li> <li>getParameterP (rayx::DesignElement)</li> <li>getParameterPType (rayx::DesignElement)</li> <li>getProfileFile (rayx::DesignElement)</li> <li>getProfileKind (rayx::DesignElement)</li> <li>getRadius (rayx::DesignElement)</li> <li>getRadiusDirection (rayx::DesignElement)</li> <li>getRoughnessCoating (rayx::DesignElement)</li> <li>getRoughnessSubstrate (rayx::DesignElement)</li> <li>getShortHalfAxisB (rayx::DesignElement)</li> <li>getShortRadius (rayx::DesignElement)</li> <li>getSlopeError (rayx::DesignElement)</li> <li>getStopHeight (rayx::DesignElement)</li> <li>getStopWidth (rayx::DesignElement)</li> <li>getStructureFactorImF0 (rayx::DesignElement)</li> <li>getStructureFactorImFH (rayx::DesignElement)</li> <li>getStructureFactorImFHC (rayx::DesignElement)</li> <li>getStructureFactorReF0 (rayx::DesignElement)</li> <li>getStructureFactorReFH (rayx::DesignElement)</li> <li>getStructureFactorReFHC (rayx::DesignElement)</li> <li>getSurfaceCoatingType (rayx::DesignElement)</li> <li>getThicknessCoating (rayx::DesignElement)</li> <li>getThicknessSubstrate (rayx::DesignElement)</li> <li>getTotalHeight (rayx::DesignElement)</li> <li>getTotalLength (rayx::DesignElement)</li> <li>getTotalWidth (rayx::DesignElement)</li> <li>getType (rayx::DesignElement, rayx::DesignSource)</li> <li>getUnitCellVolume (rayx::DesignElement)</li> <li>getVLSParameters (rayx::DesignElement)</li> <li>getBendingRadius (rayx::DesignSource)</li> <li>getDeltaOpeningAngle (rayx::DesignSource)</li> <li>getElectronEnergy (rayx::DesignSource)</li> <li>getElectronEnergyOrientation (rayx::DesignSource)</li> <li>getElectronSigmaX (rayx::DesignSource)</li> <li>getElectronSigmaXs (rayx::DesignSource)</li> <li>getElectronSigmaY (rayx::DesignSource)</li> <li>getElectronSigmaYs (rayx::DesignSource)</li> <li>getEnergy (rayx::DesignSource, rayx::DipoleSource)</li> <li>getEnergyDistribution (rayx::DesignSource)</li> <li>getEnergyDistributionType (rayx::DesignSource)</li> <li>getEnergySpread (rayx::DesignSource)</li> <li>getEnergySpreadType (rayx::DesignSource)</li> <li>getEnergySpreadUnit (rayx::DesignSource)</li> <li>getHeightDist (rayx::DesignSource)</li> <li>getHorDist (rayx::DesignSource)</li> <li>getHorDivergence (rayx::DesignSource)</li> <li>getMaxOpeningAngle (rayx::DesignSource)</li> <li>getMinOpeningAngle (rayx::DesignSource)</li> <li>getNumOfCircles (rayx::DesignSource)</li> <li>getNumberOfRays (rayx::DesignSource)</li> <li>getNumberOfSeparateEnergies (rayx::DesignSource)</li> <li>getPhotonFlux (rayx::DesignSource)</li> <li>getRayList (rayx::DesignSource)</li> <li>getSigmaType (rayx::DesignSource)</li> <li>getSourceDepth (rayx::DesignSource)</li> <li>getSourceHeight (rayx::DesignSource)</li> <li>getSourceWidth (rayx::DesignSource)</li> <li>getStokes (rayx::DesignSource)</li> <li>getUndulatorLength (rayx::DesignSource)</li> <li>getVerDist (rayx::DesignSource)</li> <li>getVerDivergence (rayx::DesignSource)</li> <li>getVerEBeamDivergence (rayx::DesignSource)</li> <li>getWidthDist (rayx::DesignSource)</li> <li>getNormalFromRange (rayx::DipoleSource)</li> <li>getPsiandStokes (rayx::DipoleSource)</li> <li>getXYZPosition (rayx::DipoleSource)</li> <li>genRaysBatch (rayx::GenRays)</li> <li>Group (rayx::Group)</li> <li>getChildren (rayx::Group)</li> <li>getElementNames (rayx::Group)</li> <li>getElements (rayx::Group)</li> <li>getObjectNames (rayx::Group)</li> <li>getSourceNames (rayx::Group)</li> <li>getSources (rayx::Group)</li> <li>getDirectionFromAngles (rayx::LightSourceBase)</li> <li>GenRaysAcc (rayx::MegaKernelTracer)</li> <li>getExecutablePath (rayx::ResourceHandler)</li> <li>getFontPath (rayx::ResourceHandler)</li> <li>getFullPath (rayx::ResourceHandler)</li> <li>getInstance (rayx::ResourceHandler)</li> <li>getResourcePath (rayx::ResourceHandler)</li> <li>getCoord (rayx::SimpleUndulatorSource)</li> <li>get (rayx::Variant)</li> </ul>"},{"location":"rayxCore/class_members/#h","title":"h","text":"<ul> <li>hasParent (rayx::BeamlineNode)</li> <li>hitpoint (rayx::CollisionPoint)</li> <li>hasKey (rayx::DesignMap)</li> <li>HardEdge (rayx::EnergyDistributionDataBase, rayx::HardEdge)</li> </ul>"},{"location":"rayxCore/class_members/#i","title":"i","text":"<ul> <li>isElement (rayx::BeamlineNode, rayx::DesignElement)</li> <li>isGroup (rayx::BeamlineNode, rayx::Group)</li> <li>isSource (rayx::BeamlineNode, rayx::DesignSource)</li> <li>iterator_category (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>Iterator (rayx::DesignMap::Iterator)</li> <li>Index (rayx::DeviceConfig::Device)</li> <li>index (rayx::DeviceConfig::Device)</li> <li>InstrumentationTimer (rayx::InstrumentationTimer)</li> <li>indices (rayx::MaterialTables, rayx::ObjectMask::ByIndices)</li> <li>Idx (rayx::MegaKernelTracer, rayx::Resources)</li> <li>isValid (rayx::Rays)</li> <li>is (rayx::Variant)</li> </ul>"},{"location":"rayxCore/class_members/#l","title":"l","text":"<ul> <li>load (rayx::DatFile, rayx::NffTable, rayx::PalikTable)</li> <li>line (rayx::Exit)</li> <li>LightSourceBase (rayx::LightSourceBase)</li> <li>Log (rayx::Log)</li> <li>lookUpPaths (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_members/#m","title":"m","text":"<ul> <li>m_parent (rayx::BeamlineNode)</li> <li>m_deltaOpeningAngle (rayx::CircleSource)</li> <li>m_maxOpeningAngle (rayx::CircleSource)</li> <li>m_minOpeningAngle (rayx::CircleSource)</li> <li>m_numOfCircles (rayx::CircleSource)</li> <li>m_pol (rayx::CircleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceDepth (rayx::CircleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceHeight (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceWidth (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>materialIndices (rayx::ConstState)</li> <li>materialTable (rayx::ConstState)</li> <li>maxEvents (rayx::ConstState)</li> <li>m_energy (rayx::DatEntry, rayx::NffEntry, rayx::PalikEntry)</li> <li>m_weight (rayx::DatEntry)</li> <li>m_Lines (rayx::DatFile, rayx::NffTable, rayx::PalikTable)</li> <li>m_continuous (rayx::DatFile)</li> <li>m_end (rayx::DatFile)</li> <li>m_lineCount (rayx::DatFile)</li> <li>m_start (rayx::DatFile)</li> <li>m_step (rayx::DatFile)</li> <li>m_title (rayx::DatFile)</li> <li>m_weightSum (rayx::DatFile)</li> <li>m_elementParameters (rayx::DesignElement, rayx::DesignSource)</li> <li>m_variant (rayx::DesignMap, rayx::ObjectMask, rayx::Variant)</li> <li>m_it (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>m_fetchedDeviceType (rayx::DeviceConfig)</li> <li>m_bendingRadius (rayx::DipoleSource)</li> <li>m_criticalEnergy (rayx::DipoleSource)</li> <li>m_electronEnergy (rayx::DipoleSource)</li> <li>m_electronEnergyOrientation (rayx::DipoleSource)</li> <li>m_energySpread (rayx::DipoleSource, rayx::HardEdge, rayx::SeparateEnergies)</li> <li>m_gamma (rayx::DipoleSource)</li> <li>m_horDivergence (rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_maxFlux (rayx::DipoleSource)</li> <li>m_maxIntensity (rayx::DipoleSource)</li> <li>m_photonEnergy (rayx::DipoleSource, rayx::SimpleUndulatorSource)</li> <li>m_verDivergence (rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_verEbeamDivergence (rayx::DipoleSource)</li> <li>m_numRaysBatchAtMost (rayx::GenRays)</li> <li>m_numRaysTotal (rayx::GenRays)</li> <li>m_seed (rayx::GenRays)</li> <li>m_sourceStates (rayx::GenRays)</li> <li>m_startRayIndex (rayx::GenRays)</li> <li>m_children (rayx::Group)</li> <li>m_name (rayx::Group)</li> <li>m_orientation (rayx::Group)</li> <li>m_position (rayx::Group)</li> <li>m_centerEnergy (rayx::HardEdge, rayx::SeparateEnergies, rayx::SoftEdge)</li> <li>m_Name (rayx::InstrumentationTimer)</li> <li>m_StartTimepoint (rayx::InstrumentationTimer)</li> <li>m_canPrint (rayx::InstrumentationTimer)</li> <li>m_isStopped (rayx::InstrumentationTimer)</li> <li>m_numberOfRays (rayx::LightSourceBase)</li> <li>materials (rayx::MaterialTables)</li> <li>MatrixSource (rayx::MatrixSource)</li> <li>MegaKernelTracer (rayx::MegaKernelTracer)</li> <li>m_deviceIndex (rayx::MegaKernelTracer)</li> <li>m_genRaysResources (rayx::MegaKernelTracer)</li> <li>m_resources (rayx::MegaKernelTracer)</li> <li>m_f1 (rayx::NffEntry)</li> <li>m_f2 (rayx::NffEntry)</li> <li>m_element (rayx::NffTable, rayx::PalikTable)</li> <li>m_elementMask (rayx::ObjectIndexMask)</li> <li>m_sourceMask (rayx::ObjectIndexMask)</li> <li>m_inTrans (rayx::ObjectTransform)</li> <li>m_outTrans (rayx::ObjectTransform)</li> <li>m_azimuthalAngle (rayx::OpticalElement)</li> <li>m_behaviour (rayx::OpticalElement)</li> <li>m_coating (rayx::OpticalElement)</li> <li>m_cutout (rayx::OpticalElement)</li> <li>m_material (rayx::OpticalElement)</li> <li>m_slopeError (rayx::OpticalElement)</li> <li>m_surface (rayx::OpticalElement)</li> <li>m_k (rayx::PalikEntry)</li> <li>m_n (rayx::PalikEntry)</li> <li>m_heightDist (rayx::PointSource)</li> <li>m_horDist (rayx::PointSource)</li> <li>m_verDist (rayx::PointSource)</li> <li>m_widthDist (rayx::PointSource)</li> <li>m_numberOfEnergies (rayx::SeparateEnergies)</li> <li>m_cylindricalBowingAmp (rayx::SlopeError)</li> <li>m_cylindricalBowingRadius (rayx::SlopeError)</li> <li>m_mer (rayx::SlopeError)</li> <li>m_sag (rayx::SlopeError)</li> <li>m_thermalDistortionAmp (rayx::SlopeError)</li> <li>m_thermalDistortionSigmaX (rayx::SlopeError)</li> <li>m_thermalDistortionSigmaZ (rayx::SlopeError)</li> <li>m_sigma (rayx::SoftEdge)</li> <li>m_deviceTracer (rayx::Tracer)</li> <li>m_dSpacing2 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_offsetAngle (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImF0 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImFH (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImFHC (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReF0 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReFH (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReFHC (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_unitCellVolume (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_roughnessSubstrate (rayx::detail::BehaviourTypes::Foil)</li> <li>m_thicknessSubstrate (rayx::detail::BehaviourTypes::Foil)</li> <li>m_lineDensity (rayx::detail::BehaviourTypes::Grating)</li> <li>m_orderOfDiffraction (rayx::detail::BehaviourTypes::Grating, rayx::detail::BehaviourTypes::RZP)</li> <li>m_vls (rayx::detail::BehaviourTypes::Grating)</li> <li>m_additionalOrder (rayx::detail::BehaviourTypes::RZP)</li> <li>m_derivationMethod (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designAlphaAngle (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designBetaAngle (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designMeridionalEntranceArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designMeridionalExitArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designOrderOfDiffraction (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designSagittalEntranceArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designSagittalExitArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designWavelength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_fresnelZOffset (rayx::detail::BehaviourTypes::RZP)</li> <li>m_imageType (rayx::detail::BehaviourTypes::RZP)</li> <li>m_rzpType (rayx::detail::BehaviourTypes::RZP)</li> <li>m_beamstopCutout (rayx::detail::BehaviourTypes::Slit)</li> <li>m_openingCutout (rayx::detail::BehaviourTypes::Slit)</li> <li>material (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> <li>m_diameter_x (rayx::detail::CutoutTypes::Elliptical)</li> <li>m_diameter_z (rayx::detail::CutoutTypes::Elliptical)</li> <li>m_length (rayx::detail::CutoutTypes::Rect, rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_width (rayx::detail::CutoutTypes::Rect)</li> <li>m_widthA (rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_widthB (rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_a11 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a12 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a13 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a14 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a22 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a23 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a24 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a33 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a34 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a44 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_b12 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b13 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b21 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b23 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b31 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b32 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_psi (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_icurv (rayx::detail::SurfaceTypes::Quadric)</li> <li>m_longRadius (rayx::detail::SurfaceTypes::Toroid)</li> <li>m_shortRadius (rayx::detail::SurfaceTypes::Toroid)</li> <li>m_toroidType (rayx::detail::SurfaceTypes::Toroid)</li> </ul>"},{"location":"rayxCore/class_members/#n","title":"n","text":"<ul> <li>normal (rayx::CollisionPoint)</li> <li>numElements (rayx::ConstState, rayx::Group, rayx::ObjectIndexMask, rayx::Resources::BeamlineConfig)</li> <li>numSources (rayx::ConstState, rayx::Group, rayx::ObjectIndexMask, rayx::Resources::BeamlineConfig)</li> <li>name (rayx::DeviceConfig::Device, rayx::xml::Parser, rayx::GenRays::SourceState)</li> <li>numRaysBatch (rayx::GenRays::BatchConfig)</li> <li>numBatches (rayx::GenRays::SourceConfig)</li> <li>numRaysBatchAtMost (rayx::GenRays::SourceConfig)</li> <li>numRaysTotal (rayx::GenRays::SourceConfig)</li> <li>numObjects (rayx::Group, rayx::ObjectIndexMask)</li> <li>numRayPaths (rayx::Group)</li> <li>none (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>numElementsToRecord (rayx::ObjectIndexMask)</li> <li>numObjectsToRecord (rayx::ObjectIndexMask)</li> <li>numSourcesToRecord (rayx::ObjectIndexMask)</li> <li>numPaths (rayx::Rays)</li> <li>numLayers (rayx::detail::CoatingTypes::MultilayerCoating)</li> <li>node (rayx::xml::Parser)</li> <li>numRaysSource (rayx::GenRays::SourceState)</li> <li>numRaysSourceRemaining (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_members/#o","title":"o","text":"<ul> <li>operator[] (rayx::BeamlineNode, rayx::DesignMap, rayx::Group)</li> <li>objectRecordMask (rayx::ConstState)</li> <li>objectTransforms (rayx::ConstState)</li> <li>outputEventsGridStride (rayx::ConstState)</li> <li>operator= (rayx::DesignElement, rayx::DesignMap, rayx::DesignSource, rayx::DeviceConfig, rayx::Group, rayx::MegaKernelTracer, rayx::ObjectIndexMask, rayx::ObjectMask, rayx::Rand, rayx::Rays, rayx::Variant)</li> <li>operator* (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator++ (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator-&gt; (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator&lt;&lt; (rayx::Exit, rayx::IgnoreLog, rayx::Log, rayx::Verb, rayx::Warn)</li> <li>ObjectIndexMask (rayx::ObjectIndexMask)</li> <li>ObjectMask (rayx::ObjectMask)</li> <li>object_id (rayx::detail::Ray)</li> <li>optical_path_length (rayx::detail::Ray)</li> <li>order (rayx::detail::Ray)</li> </ul>"},{"location":"rayxCore/class_members/#p","title":"p","text":"<ul> <li>point (rayx::CollisionWithElement)</li> <li>p (rayx::ComplexFresnelCoeffs, rayx::FresnelCoeffs)</li> <li>pointer (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>prefixWeights (rayx::EnergyDistributionList)</li> <li>PixelSource (rayx::PixelSource)</li> <li>PointSource (rayx::PointSource)</li> <li>psi (rayx::PsiAndStokes)</li> <li>position (rayx::Rays, rayx::RaysPtr, rayx::detail::Ray)</li> <li>path_event_id (rayx::detail::Ray)</li> <li>path_id (rayx::detail::Ray)</li> <li>Parser (rayx::xml::Parser)</li> <li>parseAdditionalOrder (rayx::xml::Parser)</li> <li>parseAlignmentError (rayx::xml::Parser)</li> <li>parseArmLength (rayx::xml::Parser)</li> <li>parseAzimuthalAngle (rayx::xml::Parser)</li> <li>parseBendingRadius (rayx::xml::Parser)</li> <li>parseBendingRadiusDouble (rayx::xml::Parser)</li> <li>parseCentralBeamstop (rayx::xml::Parser)</li> <li>parseCircularPol (rayx::xml::Parser)</li> <li>parseCoating (rayx::xml::Parser)</li> <li>parseCrystalMaterial (rayx::xml::Parser)</li> <li>parseCrystalType (rayx::xml::Parser)</li> <li>parseCubicParameters (rayx::xml::Parser)</li> <li>parseCurvatureType (rayx::xml::Parser)</li> <li>parseCutout (rayx::xml::Parser)</li> <li>parseDSpacing2 (rayx::xml::Parser)</li> <li>parseDeltaOpeningAngle (rayx::xml::Parser)</li> <li>parseDensitySubstrate (rayx::xml::Parser)</li> <li>parseDesignAlphaAngle (rayx::xml::Parser)</li> <li>parseDesignBetaAngle (rayx::xml::Parser)</li> <li>parseDesignEnergy (rayx::xml::Parser)</li> <li>parseDesignEnergyMounting (rayx::xml::Parser)</li> <li>parseDesignGrazingIncAngle (rayx::xml::Parser)</li> <li>parseDesignOrderDiffraction (rayx::xml::Parser)</li> <li>parseDeviationAngle (rayx::xml::Parser)</li> <li>parseDistancePreceding (rayx::xml::Parser)</li> <li>parseDouble (rayx::xml::Parser)</li> <li>parseDvec3 (rayx::xml::Parser)</li> <li>parseElectronEnergy (rayx::xml::Parser)</li> <li>parseElectronEnergyOrientation (rayx::xml::Parser)</li> <li>parseElectronSigmaX (rayx::xml::Parser)</li> <li>parseElectronSigmaXs (rayx::xml::Parser)</li> <li>parseElectronSigmaY (rayx::xml::Parser)</li> <li>parseElectronSigmaYs (rayx::xml::Parser)</li> <li>parseEnergyDistributionFile (rayx::xml::Parser)</li> <li>parseEnergyDistributionType (rayx::xml::Parser)</li> <li>parseEnergySpread (rayx::xml::Parser)</li> <li>parseEnergySpreadType (rayx::xml::Parser)</li> <li>parseEnergySpreadUnit (rayx::xml::Parser)</li> <li>parseEntranceArmLength (rayx::xml::Parser)</li> <li>parseEntranceArmLengthMer (rayx::xml::Parser)</li> <li>parseEntranceArmLengthSag (rayx::xml::Parser)</li> <li>parseExitArmLength (rayx::xml::Parser)</li> <li>parseExitArmLengthMer (rayx::xml::Parser)</li> <li>parseExitArmLengthSag (rayx::xml::Parser)</li> <li>parseFigureRotation (rayx::xml::Parser)</li> <li>parseFresnelZOffset (rayx::xml::Parser)</li> <li>parseGratingMount (rayx::xml::Parser)</li> <li>parseGrazingIncAngle (rayx::xml::Parser)</li> <li>parseHorDiv (rayx::xml::Parser)</li> <li>parseHorDivDistribution (rayx::xml::Parser)</li> <li>parseImageType (rayx::xml::Parser)</li> <li>parseInt (rayx::xml::Parser)</li> <li>parseLineDensity (rayx::xml::Parser)</li> <li>parseLinearPol0 (rayx::xml::Parser)</li> <li>parseLinearPol45 (rayx::xml::Parser)</li> <li>parseLongHalfAxisA (rayx::xml::Parser)</li> <li>parseLongRadius (rayx::xml::Parser)</li> <li>parseMaterial (rayx::xml::Parser)</li> <li>parseMaterialCoating (rayx::xml::Parser)</li> <li>parseMaxOpeningAngle (rayx::xml::Parser)</li> <li>parseMinOpeningAngle (rayx::xml::Parser)</li> <li>parseNumOfEquidistantCircles (rayx::xml::Parser)</li> <li>parseNumberOfSeparateEnergies (rayx::xml::Parser)</li> <li>parseNumberRays (rayx::xml::Parser)</li> <li>parseOffsetAngle (rayx::xml::Parser)</li> <li>parseOffsetAngleType (rayx::xml::Parser)</li> <li>parseOpeningHeight (rayx::xml::Parser)</li> <li>parseOpeningShape (rayx::xml::Parser)</li> <li>parseOpeningWidth (rayx::xml::Parser)</li> <li>parseOrderDiffraction (rayx::xml::Parser)</li> <li>parseOrientation (rayx::xml::Parser)</li> <li>parseParameterA11 (rayx::xml::Parser)</li> <li>parseParameterP (rayx::xml::Parser)</li> <li>parseParameterPType (rayx::xml::Parser)</li> <li>parsePhotonEnergy (rayx::xml::Parser)</li> <li>parsePhotonFlux (rayx::xml::Parser)</li> <li>parsePosition (rayx::xml::Parser)</li> <li>parseProfileKind (rayx::xml::Parser)</li> <li>parseQuadricParameters (rayx::xml::Parser)</li> <li>parseRadius (rayx::xml::Parser)</li> <li>parseRoughnessCoating (rayx::xml::Parser)</li> <li>parseRoughnessSubstrate (rayx::xml::Parser)</li> <li>parseShortHalfAxisB (rayx::xml::Parser)</li> <li>parseShortRadius (rayx::xml::Parser)</li> <li>parseSigmaType (rayx::xml::Parser)</li> <li>parseSlopeError (rayx::xml::Parser)</li> <li>parseSourceDepth (rayx::xml::Parser)</li> <li>parseSourceHeight (rayx::xml::Parser)</li> <li>parseSourceHeightDistribution (rayx::xml::Parser)</li> <li>parseSourcePulseType (rayx::xml::Parser)</li> <li>parseSourceWidth (rayx::xml::Parser)</li> <li>parseSourceWidthDistribution (rayx::xml::Parser)</li> <li>parseStr (rayx::xml::Parser)</li> <li>parseStructureFactorImF0 (rayx::xml::Parser)</li> <li>parseStructureFactorImFH (rayx::xml::Parser)</li> <li>parseStructureFactorImFHC (rayx::xml::Parser)</li> <li>parseStructureFactorReF0 (rayx::xml::Parser)</li> <li>parseStructureFactorReFH (rayx::xml::Parser)</li> <li>parseStructureFactorReFHC (rayx::xml::Parser)</li> <li>parseSurfaceCoatingType (rayx::xml::Parser)</li> <li>parseThicknessCoating (rayx::xml::Parser)</li> <li>parseThicknessSubstrate (rayx::xml::Parser)</li> <li>parseTotalHeight (rayx::xml::Parser)</li> <li>parseTotalHeightStop (rayx::xml::Parser)</li> <li>parseTotalLength (rayx::xml::Parser)</li> <li>parseTotalWidth (rayx::xml::Parser)</li> <li>parseTotalWidthStop (rayx::xml::Parser)</li> <li>parseUndulatorLength (rayx::xml::Parser)</li> <li>parseUnitCellVolume (rayx::xml::Parser)</li> <li>parseVerDiv (rayx::xml::Parser)</li> <li>parseVerDivDistribution (rayx::xml::Parser)</li> <li>parseVerEbeamDivergence (rayx::xml::Parser)</li> <li>parseVls (rayx::xml::Parser)</li> </ul>"},{"location":"rayxCore/class_members/#r","title":"r","text":"<ul> <li>rays (rayx::ConstState, rayx::RayListSource)</li> <li>reference (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>releaseNodeFromChildren (rayx::Group)</li> <li>releaseNodeFromTree (rayx::Group)</li> <li>Rad (rayx::Rad)</li> <li>rad (rayx::Rad)</li> <li>Rand (rayx::Rand)</li> <li>randomDouble (rayx::Rand)</li> <li>randomDoubleInRange (rayx::Rand)</li> <li>randomDoubleNormalDistributed (rayx::Rand)</li> <li>randomInt (rayx::Rand)</li> <li>randomIntInRange (rayx::Rand)</li> <li>Rays (rayx::Rays)</li> <li>ResourceHandler (rayx::ResourceHandler)</li> <li>right (rayx::RotationBase)</li> <li>roughness (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> <li>rand (rayx::detail::Ray)</li> <li>rmlFile (rayx::xml::Parser)</li> </ul>"},{"location":"rayxCore/class_members/#s","title":"s","text":"<ul> <li>setName (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>s (rayx::ComplexFresnelCoeffs, rayx::FresnelCoeffs)</li> <li>sequential (rayx::ConstState)</li> <li>setAdditionalOrder (rayx::DesignElement)</li> <li>setArmLength (rayx::DesignElement)</li> <li>setAzimuthalAngle (rayx::DesignElement)</li> <li>setBehaviourType (rayx::DesignElement)</li> <li>setCalcRadius (rayx::DesignElement)</li> <li>setCalcRadiusDeviationAngle (rayx::DesignElement)</li> <li>setCentralBeamstop (rayx::DesignElement)</li> <li>setCrystalMaterial (rayx::DesignElement)</li> <li>setCrystalType (rayx::DesignElement)</li> <li>setCurvatureType (rayx::DesignElement)</li> <li>setCutout (rayx::DesignElement)</li> <li>setDSpacing2 (rayx::DesignElement)</li> <li>setDesignAlphaAngle (rayx::DesignElement)</li> <li>setDesignBetaAngle (rayx::DesignElement)</li> <li>setDesignEnergy (rayx::DesignElement)</li> <li>setDesignGrazingIncAngle (rayx::DesignElement)</li> <li>setDesignMeridionalEntranceArmLength (rayx::DesignElement)</li> <li>setDesignMeridionalExitArmLength (rayx::DesignElement)</li> <li>setDesignOrderOfDiffraction (rayx::DesignElement)</li> <li>setDesignPlane (rayx::DesignElement)</li> <li>setDesignSagittalEntranceArmLength (rayx::DesignElement)</li> <li>setDesignSagittalExitArmLength (rayx::DesignElement)</li> <li>setDeviationAngle (rayx::DesignElement)</li> <li>setDistancePreceding (rayx::DesignElement)</li> <li>setEntranceArmLength (rayx::DesignElement)</li> <li>setExitArmLength (rayx::DesignElement)</li> <li>setExpertsCubic (rayx::DesignElement)</li> <li>setExpertsOptics (rayx::DesignElement)</li> <li>setFigureRotation (rayx::DesignElement)</li> <li>setFresnelZOffset (rayx::DesignElement)</li> <li>setGrazingIncAngle (rayx::DesignElement)</li> <li>setImageType (rayx::DesignElement)</li> <li>setLineDensity (rayx::DesignElement)</li> <li>setLongHalfAxisA (rayx::DesignElement)</li> <li>setLongRadius (rayx::DesignElement)</li> <li>setMaterial (rayx::DesignElement)</li> <li>setMaterialCoating (rayx::DesignElement)</li> <li>setMultilayerCoating (rayx::DesignElement)</li> <li>setOffsetAngle (rayx::DesignElement)</li> <li>setOffsetAngleType (rayx::DesignElement)</li> <li>setOpeningHeight (rayx::DesignElement)</li> <li>setOpeningShape (rayx::DesignElement)</li> <li>setOpeningWidth (rayx::DesignElement)</li> <li>setOrderOfDiffraction (rayx::DesignElement)</li> <li>setOrientation (rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>setParameterA11 (rayx::DesignElement)</li> <li>setParameterP (rayx::DesignElement)</li> <li>setParameterPType (rayx::DesignElement)</li> <li>setPosition (rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>setProfileFile (rayx::DesignElement)</li> <li>setProfileKind (rayx::DesignElement)</li> <li>setRadius (rayx::DesignElement)</li> <li>setRadiusDirection (rayx::DesignElement)</li> <li>setRoughnessCoating (rayx::DesignElement)</li> <li>setRoughnessSubstrate (rayx::DesignElement)</li> <li>setShortHalfAxisB (rayx::DesignElement)</li> <li>setShortRadius (rayx::DesignElement)</li> <li>setSlopeError (rayx::DesignElement)</li> <li>setStopHeight (rayx::DesignElement)</li> <li>setStopWidth (rayx::DesignElement)</li> <li>setStructureFactorImF0 (rayx::DesignElement)</li> <li>setStructureFactorImFH (rayx::DesignElement)</li> <li>setStructureFactorImFHC (rayx::DesignElement)</li> <li>setStructureFactorReF0 (rayx::DesignElement)</li> <li>setStructureFactorReFH (rayx::DesignElement)</li> <li>setStructureFactorReFHC (rayx::DesignElement)</li> <li>setSurfaceCoatingType (rayx::DesignElement)</li> <li>setThicknessCoating (rayx::DesignElement)</li> <li>setThicknessSubstrate (rayx::DesignElement)</li> <li>setTotalHeight (rayx::DesignElement)</li> <li>setTotalLength (rayx::DesignElement)</li> <li>setTotalWidth (rayx::DesignElement)</li> <li>setType (rayx::DesignElement, rayx::DesignSource)</li> <li>setUnitCellVolume (rayx::DesignElement)</li> <li>setVLSParameters (rayx::DesignElement)</li> <li>setBendingRadius (rayx::DesignSource)</li> <li>setDeltaOpeningAngle (rayx::DesignSource)</li> <li>setElectronEnergy (rayx::DesignSource)</li> <li>setElectronEnergyOrientation (rayx::DesignSource)</li> <li>setElectronSigmaX (rayx::DesignSource)</li> <li>setElectronSigmaXs (rayx::DesignSource)</li> <li>setElectronSigmaY (rayx::DesignSource)</li> <li>setElectronSigmaYs (rayx::DesignSource)</li> <li>setEnergy (rayx::DesignSource)</li> <li>setEnergyDistributionFile (rayx::DesignSource)</li> <li>setEnergyDistributionType (rayx::DesignSource)</li> <li>setEnergySpread (rayx::DesignSource)</li> <li>setEnergySpreadType (rayx::DesignSource)</li> <li>setEnergySpreadUnit (rayx::DesignSource)</li> <li>setHeightDist (rayx::DesignSource)</li> <li>setHorDist (rayx::DesignSource)</li> <li>setHorDivergence (rayx::DesignSource)</li> <li>setMaxOpeningAngle (rayx::DesignSource)</li> <li>setMinOpeningAngle (rayx::DesignSource)</li> <li>setNumOfCircles (rayx::DesignSource)</li> <li>setNumberOfRays (rayx::DesignSource)</li> <li>setNumberOfSeparateEnergies (rayx::DesignSource)</li> <li>setPhotonFlux (rayx::DesignSource)</li> <li>setRayList (rayx::DesignSource)</li> <li>setSigmaType (rayx::DesignSource)</li> <li>setSourceDepth (rayx::DesignSource)</li> <li>setSourceHeight (rayx::DesignSource)</li> <li>setSourceWidth (rayx::DesignSource)</li> <li>setStokescirc (rayx::DesignSource)</li> <li>setStokeslin0 (rayx::DesignSource)</li> <li>setStokeslin45 (rayx::DesignSource)</li> <li>setUndulatorLength (rayx::DesignSource)</li> <li>setVerDist (rayx::DesignSource)</li> <li>setVerDivergence (rayx::DesignSource)</li> <li>setVerEBeamDivergence (rayx::DesignSource)</li> <li>setWidthDist (rayx::DesignSource)</li> <li>Score (rayx::DeviceConfig::Device)</li> <li>score (rayx::DeviceConfig::Device)</li> <li>SeparateEnergies (rayx::EnergyDistributionDataBase, rayx::SeparateEnergies)</li> <li>SoftEdge (rayx::EnergyDistributionDataBase, rayx::SoftEdge)</li> <li>size (rayx::EnergyDistributionList, rayx::Rays)</li> <li>SourceVariant (rayx::GenRays)</li> <li>Stop (rayx::InstrumentationTimer)</li> <li>storedFlags (rayx::MutableState)</li> <li>setShouldRecordElement (rayx::ObjectIndexMask)</li> <li>setShouldRecordObject (rayx::ObjectIndexMask)</li> <li>setShouldRecordSource (rayx::ObjectIndexMask)</li> <li>shouldRecordElement (rayx::ObjectIndexMask)</li> <li>shouldRecordObject (rayx::ObjectIndexMask)</li> <li>shouldRecordSource (rayx::ObjectIndexMask)</li> <li>stokes (rayx::PsiAndStokes)</li> <li>sin (rayx::Rad)</li> <li>sort (rayx::Rays)</li> <li>sortByObjectId (rayx::Rays)</li> <li>sortByPathIdAndPathEventId (rayx::Rays)</li> <li>SimpleUndulatorSource (rayx::SimpleUndulatorSource)</li> <li>source_id (rayx::detail::Ray)</li> <li>source (rayx::GenRays::SourceState)</li> <li>sourceId (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_members/#t","title":"t","text":"<ul> <li>toRad (rayx::Deg)</li> <li>type (rayx::DesignMap, rayx::DeviceConfig::Device, rayx::xml::Parser)</li> <li>trace (rayx::DeviceTracer, rayx::MegaKernelTracer, rayx::Tracer)</li> <li>traverse (rayx::Group)</li> <li>traceBatch (rayx::MegaKernelTracer)</li> <li>transferEventsBatch (rayx::MegaKernelTracer)</li> <li>toObjectIndexMask (rayx::ObjectMask)</li> <li>transform (rayx::OpticalElementAndTransform)</li> <li>tan (rayx::Rad)</li> <li>toDeg (rayx::Rad)</li> <li>Tracer (rayx::Tracer)</li> <li>thickness (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> </ul>"},{"location":"rayxCore/class_members/#u","title":"u","text":"<ul> <li>update (rayx::GenRays, rayx::Resources)</li> <li>up (rayx::RotationBase)</li> </ul>"},{"location":"rayxCore/class_members/#v","title":"v","text":"<ul> <li>value (rayx::BlockSizeConstraint::AtLeast, rayx::BlockSizeConstraint::AtMost, rayx::BlockSizeConstraint::Exact)</li> <li>Variant (rayx::DesignMap, rayx::ObjectMask, rayx::Variant)</li> <li>value_type (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>visit (rayx::Variant)</li> <li>Verb (rayx::Verb)</li> </ul>"},{"location":"rayxCore/class_members/#w","title":"w","text":"<ul> <li>weightSum (rayx::EnergyDistributionList)</li> <li>Warn (rayx::Warn)</li> </ul>"},{"location":"rayxCore/class_members/#_1","title":"~","text":"<ul> <li>~BeamlineNode (rayx::BeamlineNode)</li> <li>~DesignElement (rayx::DesignElement)</li> <li>~DesignSource (rayx::DesignSource)</li> <li>~DeviceTracer (rayx::DeviceTracer)</li> <li>~Exit (rayx::Exit)</li> <li>~Group (rayx::Group)</li> <li>~InstrumentationTimer (rayx::InstrumentationTimer)</li> <li>~Log (rayx::Log)</li> <li>~Verb (rayx::Verb)</li> <li>~Warn (rayx::Warn)</li> </ul>"},{"location":"rayxCore/class_member_functions/","title":"Class Member Functions","text":""},{"location":"rayxCore/class_member_functions/#a","title":"a","text":"<ul> <li>asElement (rayx::BeamlineNode)</li> <li>asGroup (rayx::BeamlineNode)</li> <li>asSource (rayx::BeamlineNode)</li> <li>as_behaviourType (rayx::DesignMap)</li> <li>as_bool (rayx::DesignMap)</li> <li>as_centralBeamStop (rayx::DesignMap)</li> <li>as_crystalType (rayx::DesignMap)</li> <li>as_curvatureType (rayx::DesignMap)</li> <li>as_cutout (rayx::DesignMap)</li> <li>as_cylinderDirection (rayx::DesignMap)</li> <li>as_designPlane (rayx::DesignMap)</li> <li>as_dmat4x4 (rayx::DesignMap)</li> <li>as_double (rayx::DesignMap)</li> <li>as_dvec4 (rayx::DesignMap)</li> <li>as_electronEnergyOrientation (rayx::DesignMap)</li> <li>as_elementType (rayx::DesignMap)</li> <li>as_energyDistType (rayx::DesignMap)</li> <li>as_energyDistributionType (rayx::DesignMap)</li> <li>as_energySpreadType (rayx::DesignMap)</li> <li>as_energySpreadUnit (rayx::DesignMap)</li> <li>as_eventType (rayx::DesignMap)</li> <li>as_figureRotation (rayx::DesignMap)</li> <li>as_gratingMount (rayx::DesignMap)</li> <li>as_int (rayx::DesignMap)</li> <li>as_map (rayx::DesignMap)</li> <li>as_material (rayx::DesignMap)</li> <li>as_openingShape (rayx::DesignMap)</li> <li>as_rad (rayx::DesignMap)</li> <li>as_rayList (rayx::DesignMap)</li> <li>as_sigmaType (rayx::DesignMap)</li> <li>as_sourceDist (rayx::DesignMap)</li> <li>as_string (rayx::DesignMap)</li> <li>as_surface (rayx::DesignMap)</li> <li>as_surfaceCoatingType (rayx::DesignMap)</li> <li>availableDeviceTypes (rayx::DeviceConfig)</li> <li>accumulateLightSourcesWorldPositions (rayx::Group)</li> <li>addChild (rayx::Group)</li> <li>all (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>allElements (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>allSources (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>append (rayx::Rays)</li> <li>attrMask (rayx::Rays)</li> <li>addLookUpPath (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_member_functions/#b","title":"b","text":"<ul> <li>begin (rayx::DesignMap, rayx::Group)</li> <li>byIndices (rayx::ObjectIndexMask, rayx::ObjectMask)</li> </ul>"},{"location":"rayxCore/class_member_functions/#c","title":"c","text":"<ul> <li>clone (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignMap, rayx::DesignSource, rayx::Group)</li> <li>CircleSource (rayx::CircleSource)</li> <li>compile (rayx::DesignElement)</li> <li>ConstIterator (rayx::DesignMap::ConstIterator)</li> <li>calcMinimalMaterialTables (rayx::Group)</li> <li>cbegin (rayx::Group)</li> <li>cend (rayx::Group)</li> <li>compileElements (rayx::Group)</li> <li>ctraverse (rayx::Group)</li> <li>compactEvents (rayx::MegaKernelTracer)</li> <li>cos (rayx::Rad)</li> <li>concat (rayx::Rays)</li> <li>contains (rayx::Rays)</li> <li>copy (rayx::Rays)</li> <li>count (rayx::Rays)</li> </ul>"},{"location":"rayxCore/class_member_functions/#d","title":"d","text":"<ul> <li>dump (rayx::DatFile)</li> <li>Deg (rayx::Deg)</li> <li>DesignElement (rayx::DesignElement)</li> <li>DesignMap (rayx::DesignMap)</li> <li>DesignSource (rayx::DesignSource)</li> <li>DeviceConfig (rayx::DeviceConfig)</li> <li>disableAllDevices (rayx::DeviceConfig)</li> <li>disableDeviceByIndex (rayx::DeviceConfig)</li> <li>dumpDevices (rayx::DeviceConfig)</li> <li>DipoleSource (rayx::DipoleSource)</li> <li>direction (rayx::Rays, rayx::RaysPtr)</li> </ul>"},{"location":"rayxCore/class_member_functions/#e","title":"e","text":"<ul> <li>end (rayx::DesignMap, rayx::Group)</li> <li>enableAllDevices (rayx::DeviceConfig)</li> <li>enableBestDevice (rayx::DeviceConfig)</li> <li>enableDeviceByIndex (rayx::DeviceConfig)</li> <li>enabledDevicesCount (rayx::DeviceConfig)</li> <li>Exit (rayx::Exit)</li> <li>electric_field (rayx::Rays, rayx::RaysPtr)</li> <li>empty (rayx::Rays)</li> </ul>"},{"location":"rayxCore/class_member_functions/#f","title":"f","text":"<ul> <li>findElement (rayx::Group)</li> <li>findElementByName (rayx::Group)</li> <li>findGroup (rayx::Group)</li> <li>findGroupByName (rayx::Group)</li> <li>findNode (rayx::Group)</li> <li>findNodeByName (rayx::Group)</li> <li>findNodeByObjectId (rayx::Group)</li> <li>findObjectIdByNode (rayx::Group)</li> <li>findSource (rayx::Group)</li> <li>findSourceByName (rayx::Group)</li> <li>filter (rayx::Rays)</li> <li>filterByAttrMask (rayx::Rays)</li> <li>filterByLastEventInPath (rayx::Rays)</li> <li>filterByObjectId (rayx::Rays)</li> <li>fileExists (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_member_functions/#g","title":"g","text":"<ul> <li>getName (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getObjectId (rayx::BeamlineNode)</li> <li>getOrientation (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getParent (rayx::BeamlineNode)</li> <li>getPosition (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>getRoot (rayx::BeamlineNode)</li> <li>getWorldOrientation (rayx::BeamlineNode)</li> <li>getWorldPosition (rayx::BeamlineNode)</li> <li>genRay (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>getDirection (rayx::CircleSource)</li> <li>getAdditionalOrder (rayx::DesignElement)</li> <li>getArmLength (rayx::DesignElement)</li> <li>getAzimuthalAngle (rayx::DesignElement)</li> <li>getBehaviourType (rayx::DesignElement)</li> <li>getCentralBeamstop (rayx::DesignElement)</li> <li>getCoating (rayx::DesignElement)</li> <li>getCrystalMaterial (rayx::DesignElement)</li> <li>getCrystalType (rayx::DesignElement)</li> <li>getCurvatureType (rayx::DesignElement)</li> <li>getCutout (rayx::DesignElement)</li> <li>getDSpacing2 (rayx::DesignElement)</li> <li>getDesignAlphaAngle (rayx::DesignElement)</li> <li>getDesignBetaAngle (rayx::DesignElement)</li> <li>getDesignEnergy (rayx::DesignElement)</li> <li>getDesignGrazingIncAngle (rayx::DesignElement)</li> <li>getDesignMeridionalEntranceArmLength (rayx::DesignElement)</li> <li>getDesignMeridionalExitArmLength (rayx::DesignElement)</li> <li>getDesignOrderOfDiffraction (rayx::DesignElement)</li> <li>getDesignPlane (rayx::DesignElement)</li> <li>getDesignSagittalEntranceArmLength (rayx::DesignElement)</li> <li>getDesignSagittalExitArmLength (rayx::DesignElement)</li> <li>getDeviationAngle (rayx::DesignElement)</li> <li>getDistancePreceding (rayx::DesignElement)</li> <li>getEntranceArmLength (rayx::DesignElement)</li> <li>getExitArmLength (rayx::DesignElement)</li> <li>getExpertsCubic (rayx::DesignElement)</li> <li>getExpertsOptics (rayx::DesignElement)</li> <li>getFigureRotation (rayx::DesignElement)</li> <li>getFresnelZOffset (rayx::DesignElement)</li> <li>getGlobalCutout (rayx::DesignElement)</li> <li>getGrazingIncAngle (rayx::DesignElement)</li> <li>getImageType (rayx::DesignElement)</li> <li>getLineDensity (rayx::DesignElement)</li> <li>getLongHalfAxisA (rayx::DesignElement)</li> <li>getLongRadius (rayx::DesignElement)</li> <li>getMaterial (rayx::DesignElement)</li> <li>getMaterialCoating (rayx::DesignElement)</li> <li>getOffsetAngle (rayx::DesignElement)</li> <li>getOffsetAngleType (rayx::DesignElement)</li> <li>getOpeningHeight (rayx::DesignElement)</li> <li>getOpeningShape (rayx::DesignElement)</li> <li>getOpeningWidth (rayx::DesignElement)</li> <li>getOrderOfDiffraction (rayx::DesignElement)</li> <li>getParameterA11 (rayx::DesignElement)</li> <li>getParameterP (rayx::DesignElement)</li> <li>getParameterPType (rayx::DesignElement)</li> <li>getProfileFile (rayx::DesignElement)</li> <li>getProfileKind (rayx::DesignElement)</li> <li>getRadius (rayx::DesignElement)</li> <li>getRadiusDirection (rayx::DesignElement)</li> <li>getRoughnessCoating (rayx::DesignElement)</li> <li>getRoughnessSubstrate (rayx::DesignElement)</li> <li>getShortHalfAxisB (rayx::DesignElement)</li> <li>getShortRadius (rayx::DesignElement)</li> <li>getSlopeError (rayx::DesignElement)</li> <li>getStopHeight (rayx::DesignElement)</li> <li>getStopWidth (rayx::DesignElement)</li> <li>getStructureFactorImF0 (rayx::DesignElement)</li> <li>getStructureFactorImFH (rayx::DesignElement)</li> <li>getStructureFactorImFHC (rayx::DesignElement)</li> <li>getStructureFactorReF0 (rayx::DesignElement)</li> <li>getStructureFactorReFH (rayx::DesignElement)</li> <li>getStructureFactorReFHC (rayx::DesignElement)</li> <li>getSurfaceCoatingType (rayx::DesignElement)</li> <li>getThicknessCoating (rayx::DesignElement)</li> <li>getThicknessSubstrate (rayx::DesignElement)</li> <li>getTotalHeight (rayx::DesignElement)</li> <li>getTotalLength (rayx::DesignElement)</li> <li>getTotalWidth (rayx::DesignElement)</li> <li>getType (rayx::DesignElement, rayx::DesignSource)</li> <li>getUnitCellVolume (rayx::DesignElement)</li> <li>getVLSParameters (rayx::DesignElement)</li> <li>getBendingRadius (rayx::DesignSource)</li> <li>getDeltaOpeningAngle (rayx::DesignSource)</li> <li>getElectronEnergy (rayx::DesignSource)</li> <li>getElectronEnergyOrientation (rayx::DesignSource)</li> <li>getElectronSigmaX (rayx::DesignSource)</li> <li>getElectronSigmaXs (rayx::DesignSource)</li> <li>getElectronSigmaY (rayx::DesignSource)</li> <li>getElectronSigmaYs (rayx::DesignSource)</li> <li>getEnergy (rayx::DesignSource, rayx::DipoleSource)</li> <li>getEnergyDistribution (rayx::DesignSource)</li> <li>getEnergyDistributionType (rayx::DesignSource)</li> <li>getEnergySpread (rayx::DesignSource)</li> <li>getEnergySpreadType (rayx::DesignSource)</li> <li>getEnergySpreadUnit (rayx::DesignSource)</li> <li>getHeightDist (rayx::DesignSource)</li> <li>getHorDist (rayx::DesignSource)</li> <li>getHorDivergence (rayx::DesignSource)</li> <li>getMaxOpeningAngle (rayx::DesignSource)</li> <li>getMinOpeningAngle (rayx::DesignSource)</li> <li>getNumOfCircles (rayx::DesignSource)</li> <li>getNumberOfRays (rayx::DesignSource)</li> <li>getNumberOfSeparateEnergies (rayx::DesignSource)</li> <li>getPhotonFlux (rayx::DesignSource)</li> <li>getRayList (rayx::DesignSource)</li> <li>getSigmaType (rayx::DesignSource)</li> <li>getSourceDepth (rayx::DesignSource)</li> <li>getSourceHeight (rayx::DesignSource)</li> <li>getSourceWidth (rayx::DesignSource)</li> <li>getStokes (rayx::DesignSource)</li> <li>getUndulatorLength (rayx::DesignSource)</li> <li>getVerDist (rayx::DesignSource)</li> <li>getVerDivergence (rayx::DesignSource)</li> <li>getVerEBeamDivergence (rayx::DesignSource)</li> <li>getWidthDist (rayx::DesignSource)</li> <li>getNormalFromRange (rayx::DipoleSource)</li> <li>getPsiandStokes (rayx::DipoleSource)</li> <li>getXYZPosition (rayx::DipoleSource)</li> <li>genRaysBatch (rayx::GenRays)</li> <li>Group (rayx::Group)</li> <li>getChildren (rayx::Group)</li> <li>getElementNames (rayx::Group)</li> <li>getElements (rayx::Group)</li> <li>getObjectNames (rayx::Group)</li> <li>getSourceNames (rayx::Group)</li> <li>getSources (rayx::Group)</li> <li>getDirectionFromAngles (rayx::LightSourceBase)</li> <li>getExecutablePath (rayx::ResourceHandler)</li> <li>getFontPath (rayx::ResourceHandler)</li> <li>getFullPath (rayx::ResourceHandler)</li> <li>getInstance (rayx::ResourceHandler)</li> <li>getResourcePath (rayx::ResourceHandler)</li> <li>getCoord (rayx::SimpleUndulatorSource)</li> <li>get (rayx::Variant)</li> </ul>"},{"location":"rayxCore/class_member_functions/#h","title":"h","text":"<ul> <li>hasParent (rayx::BeamlineNode)</li> <li>hasKey (rayx::DesignMap)</li> <li>HardEdge (rayx::HardEdge)</li> </ul>"},{"location":"rayxCore/class_member_functions/#i","title":"i","text":"<ul> <li>isElement (rayx::BeamlineNode, rayx::DesignElement)</li> <li>isGroup (rayx::BeamlineNode, rayx::Group)</li> <li>isSource (rayx::BeamlineNode, rayx::DesignSource)</li> <li>Iterator (rayx::DesignMap::Iterator)</li> <li>InstrumentationTimer (rayx::InstrumentationTimer)</li> <li>isValid (rayx::Rays)</li> <li>is (rayx::Variant)</li> </ul>"},{"location":"rayxCore/class_member_functions/#l","title":"l","text":"<ul> <li>load (rayx::DatFile, rayx::NffTable, rayx::PalikTable)</li> <li>LightSourceBase (rayx::LightSourceBase)</li> <li>Log (rayx::Log)</li> </ul>"},{"location":"rayxCore/class_member_functions/#m","title":"m","text":"<ul> <li>MatrixSource (rayx::MatrixSource)</li> <li>MegaKernelTracer (rayx::MegaKernelTracer)</li> </ul>"},{"location":"rayxCore/class_member_functions/#n","title":"n","text":"<ul> <li>numElements (rayx::Group, rayx::ObjectIndexMask)</li> <li>numObjects (rayx::Group, rayx::ObjectIndexMask)</li> <li>numRayPaths (rayx::Group)</li> <li>numSources (rayx::Group, rayx::ObjectIndexMask)</li> <li>none (rayx::ObjectIndexMask, rayx::ObjectMask)</li> <li>numElementsToRecord (rayx::ObjectIndexMask)</li> <li>numObjectsToRecord (rayx::ObjectIndexMask)</li> <li>numSourcesToRecord (rayx::ObjectIndexMask)</li> <li>numPaths (rayx::Rays)</li> <li>name (rayx::xml::Parser)</li> </ul>"},{"location":"rayxCore/class_member_functions/#o","title":"o","text":"<ul> <li>operator[] (rayx::BeamlineNode, rayx::DesignMap, rayx::Group)</li> <li>operator= (rayx::DesignElement, rayx::DesignMap, rayx::DesignSource, rayx::DeviceConfig, rayx::Group, rayx::MegaKernelTracer, rayx::ObjectIndexMask, rayx::ObjectMask, rayx::Rand, rayx::Rays, rayx::Variant)</li> <li>operator* (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator++ (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator-&gt; (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>operator&lt;&lt; (rayx::Exit, rayx::IgnoreLog, rayx::Log, rayx::Verb, rayx::Warn)</li> <li>ObjectIndexMask (rayx::ObjectIndexMask)</li> <li>ObjectMask (rayx::ObjectMask)</li> </ul>"},{"location":"rayxCore/class_member_functions/#p","title":"p","text":"<ul> <li>PixelSource (rayx::PixelSource)</li> <li>PointSource (rayx::PointSource)</li> <li>position (rayx::Rays, rayx::RaysPtr)</li> <li>Parser (rayx::xml::Parser)</li> <li>parseAdditionalOrder (rayx::xml::Parser)</li> <li>parseAlignmentError (rayx::xml::Parser)</li> <li>parseArmLength (rayx::xml::Parser)</li> <li>parseAzimuthalAngle (rayx::xml::Parser)</li> <li>parseBendingRadius (rayx::xml::Parser)</li> <li>parseBendingRadiusDouble (rayx::xml::Parser)</li> <li>parseCentralBeamstop (rayx::xml::Parser)</li> <li>parseCircularPol (rayx::xml::Parser)</li> <li>parseCoating (rayx::xml::Parser)</li> <li>parseCrystalMaterial (rayx::xml::Parser)</li> <li>parseCrystalType (rayx::xml::Parser)</li> <li>parseCubicParameters (rayx::xml::Parser)</li> <li>parseCurvatureType (rayx::xml::Parser)</li> <li>parseCutout (rayx::xml::Parser)</li> <li>parseDSpacing2 (rayx::xml::Parser)</li> <li>parseDeltaOpeningAngle (rayx::xml::Parser)</li> <li>parseDensitySubstrate (rayx::xml::Parser)</li> <li>parseDesignAlphaAngle (rayx::xml::Parser)</li> <li>parseDesignBetaAngle (rayx::xml::Parser)</li> <li>parseDesignEnergy (rayx::xml::Parser)</li> <li>parseDesignEnergyMounting (rayx::xml::Parser)</li> <li>parseDesignGrazingIncAngle (rayx::xml::Parser)</li> <li>parseDesignOrderDiffraction (rayx::xml::Parser)</li> <li>parseDeviationAngle (rayx::xml::Parser)</li> <li>parseDistancePreceding (rayx::xml::Parser)</li> <li>parseDouble (rayx::xml::Parser)</li> <li>parseDvec3 (rayx::xml::Parser)</li> <li>parseElectronEnergy (rayx::xml::Parser)</li> <li>parseElectronEnergyOrientation (rayx::xml::Parser)</li> <li>parseElectronSigmaX (rayx::xml::Parser)</li> <li>parseElectronSigmaXs (rayx::xml::Parser)</li> <li>parseElectronSigmaY (rayx::xml::Parser)</li> <li>parseElectronSigmaYs (rayx::xml::Parser)</li> <li>parseEnergyDistributionFile (rayx::xml::Parser)</li> <li>parseEnergyDistributionType (rayx::xml::Parser)</li> <li>parseEnergySpread (rayx::xml::Parser)</li> <li>parseEnergySpreadType (rayx::xml::Parser)</li> <li>parseEnergySpreadUnit (rayx::xml::Parser)</li> <li>parseEntranceArmLength (rayx::xml::Parser)</li> <li>parseEntranceArmLengthMer (rayx::xml::Parser)</li> <li>parseEntranceArmLengthSag (rayx::xml::Parser)</li> <li>parseExitArmLength (rayx::xml::Parser)</li> <li>parseExitArmLengthMer (rayx::xml::Parser)</li> <li>parseExitArmLengthSag (rayx::xml::Parser)</li> <li>parseFigureRotation (rayx::xml::Parser)</li> <li>parseFresnelZOffset (rayx::xml::Parser)</li> <li>parseGratingMount (rayx::xml::Parser)</li> <li>parseGrazingIncAngle (rayx::xml::Parser)</li> <li>parseHorDiv (rayx::xml::Parser)</li> <li>parseHorDivDistribution (rayx::xml::Parser)</li> <li>parseImageType (rayx::xml::Parser)</li> <li>parseInt (rayx::xml::Parser)</li> <li>parseLineDensity (rayx::xml::Parser)</li> <li>parseLinearPol0 (rayx::xml::Parser)</li> <li>parseLinearPol45 (rayx::xml::Parser)</li> <li>parseLongHalfAxisA (rayx::xml::Parser)</li> <li>parseLongRadius (rayx::xml::Parser)</li> <li>parseMaterial (rayx::xml::Parser)</li> <li>parseMaterialCoating (rayx::xml::Parser)</li> <li>parseMaxOpeningAngle (rayx::xml::Parser)</li> <li>parseMinOpeningAngle (rayx::xml::Parser)</li> <li>parseNumOfEquidistantCircles (rayx::xml::Parser)</li> <li>parseNumberOfSeparateEnergies (rayx::xml::Parser)</li> <li>parseNumberRays (rayx::xml::Parser)</li> <li>parseOffsetAngle (rayx::xml::Parser)</li> <li>parseOffsetAngleType (rayx::xml::Parser)</li> <li>parseOpeningHeight (rayx::xml::Parser)</li> <li>parseOpeningShape (rayx::xml::Parser)</li> <li>parseOpeningWidth (rayx::xml::Parser)</li> <li>parseOrderDiffraction (rayx::xml::Parser)</li> <li>parseOrientation (rayx::xml::Parser)</li> <li>parseParameterA11 (rayx::xml::Parser)</li> <li>parseParameterP (rayx::xml::Parser)</li> <li>parseParameterPType (rayx::xml::Parser)</li> <li>parsePhotonEnergy (rayx::xml::Parser)</li> <li>parsePhotonFlux (rayx::xml::Parser)</li> <li>parsePosition (rayx::xml::Parser)</li> <li>parseProfileKind (rayx::xml::Parser)</li> <li>parseQuadricParameters (rayx::xml::Parser)</li> <li>parseRadius (rayx::xml::Parser)</li> <li>parseRoughnessCoating (rayx::xml::Parser)</li> <li>parseRoughnessSubstrate (rayx::xml::Parser)</li> <li>parseShortHalfAxisB (rayx::xml::Parser)</li> <li>parseShortRadius (rayx::xml::Parser)</li> <li>parseSigmaType (rayx::xml::Parser)</li> <li>parseSlopeError (rayx::xml::Parser)</li> <li>parseSourceDepth (rayx::xml::Parser)</li> <li>parseSourceHeight (rayx::xml::Parser)</li> <li>parseSourceHeightDistribution (rayx::xml::Parser)</li> <li>parseSourcePulseType (rayx::xml::Parser)</li> <li>parseSourceWidth (rayx::xml::Parser)</li> <li>parseSourceWidthDistribution (rayx::xml::Parser)</li> <li>parseStr (rayx::xml::Parser)</li> <li>parseStructureFactorImF0 (rayx::xml::Parser)</li> <li>parseStructureFactorImFH (rayx::xml::Parser)</li> <li>parseStructureFactorImFHC (rayx::xml::Parser)</li> <li>parseStructureFactorReF0 (rayx::xml::Parser)</li> <li>parseStructureFactorReFH (rayx::xml::Parser)</li> <li>parseStructureFactorReFHC (rayx::xml::Parser)</li> <li>parseSurfaceCoatingType (rayx::xml::Parser)</li> <li>parseThicknessCoating (rayx::xml::Parser)</li> <li>parseThicknessSubstrate (rayx::xml::Parser)</li> <li>parseTotalHeight (rayx::xml::Parser)</li> <li>parseTotalHeightStop (rayx::xml::Parser)</li> <li>parseTotalLength (rayx::xml::Parser)</li> <li>parseTotalWidth (rayx::xml::Parser)</li> <li>parseTotalWidthStop (rayx::xml::Parser)</li> <li>parseUndulatorLength (rayx::xml::Parser)</li> <li>parseUnitCellVolume (rayx::xml::Parser)</li> <li>parseVerDiv (rayx::xml::Parser)</li> <li>parseVerDivDistribution (rayx::xml::Parser)</li> <li>parseVerEbeamDivergence (rayx::xml::Parser)</li> <li>parseVls (rayx::xml::Parser)</li> </ul>"},{"location":"rayxCore/class_member_functions/#r","title":"r","text":"<ul> <li>releaseNodeFromChildren (rayx::Group)</li> <li>releaseNodeFromTree (rayx::Group)</li> <li>Rad (rayx::Rad)</li> <li>Rand (rayx::Rand)</li> <li>randomDouble (rayx::Rand)</li> <li>randomDoubleInRange (rayx::Rand)</li> <li>randomDoubleNormalDistributed (rayx::Rand)</li> <li>randomInt (rayx::Rand)</li> <li>randomIntInRange (rayx::Rand)</li> <li>Rays (rayx::Rays)</li> <li>ResourceHandler (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_member_functions/#s","title":"s","text":"<ul> <li>setName (rayx::BeamlineNode, rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>setAdditionalOrder (rayx::DesignElement)</li> <li>setArmLength (rayx::DesignElement)</li> <li>setAzimuthalAngle (rayx::DesignElement)</li> <li>setBehaviourType (rayx::DesignElement)</li> <li>setCalcRadius (rayx::DesignElement)</li> <li>setCalcRadiusDeviationAngle (rayx::DesignElement)</li> <li>setCentralBeamstop (rayx::DesignElement)</li> <li>setCrystalMaterial (rayx::DesignElement)</li> <li>setCrystalType (rayx::DesignElement)</li> <li>setCurvatureType (rayx::DesignElement)</li> <li>setCutout (rayx::DesignElement)</li> <li>setDSpacing2 (rayx::DesignElement)</li> <li>setDesignAlphaAngle (rayx::DesignElement)</li> <li>setDesignBetaAngle (rayx::DesignElement)</li> <li>setDesignEnergy (rayx::DesignElement)</li> <li>setDesignGrazingIncAngle (rayx::DesignElement)</li> <li>setDesignMeridionalEntranceArmLength (rayx::DesignElement)</li> <li>setDesignMeridionalExitArmLength (rayx::DesignElement)</li> <li>setDesignOrderOfDiffraction (rayx::DesignElement)</li> <li>setDesignPlane (rayx::DesignElement)</li> <li>setDesignSagittalEntranceArmLength (rayx::DesignElement)</li> <li>setDesignSagittalExitArmLength (rayx::DesignElement)</li> <li>setDeviationAngle (rayx::DesignElement)</li> <li>setDistancePreceding (rayx::DesignElement)</li> <li>setEntranceArmLength (rayx::DesignElement)</li> <li>setExitArmLength (rayx::DesignElement)</li> <li>setExpertsCubic (rayx::DesignElement)</li> <li>setExpertsOptics (rayx::DesignElement)</li> <li>setFigureRotation (rayx::DesignElement)</li> <li>setFresnelZOffset (rayx::DesignElement)</li> <li>setGrazingIncAngle (rayx::DesignElement)</li> <li>setImageType (rayx::DesignElement)</li> <li>setLineDensity (rayx::DesignElement)</li> <li>setLongHalfAxisA (rayx::DesignElement)</li> <li>setLongRadius (rayx::DesignElement)</li> <li>setMaterial (rayx::DesignElement)</li> <li>setMaterialCoating (rayx::DesignElement)</li> <li>setMultilayerCoating (rayx::DesignElement)</li> <li>setOffsetAngle (rayx::DesignElement)</li> <li>setOffsetAngleType (rayx::DesignElement)</li> <li>setOpeningHeight (rayx::DesignElement)</li> <li>setOpeningShape (rayx::DesignElement)</li> <li>setOpeningWidth (rayx::DesignElement)</li> <li>setOrderOfDiffraction (rayx::DesignElement)</li> <li>setOrientation (rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>setParameterA11 (rayx::DesignElement)</li> <li>setParameterP (rayx::DesignElement)</li> <li>setParameterPType (rayx::DesignElement)</li> <li>setPosition (rayx::DesignElement, rayx::DesignSource, rayx::Group)</li> <li>setProfileFile (rayx::DesignElement)</li> <li>setProfileKind (rayx::DesignElement)</li> <li>setRadius (rayx::DesignElement)</li> <li>setRadiusDirection (rayx::DesignElement)</li> <li>setRoughnessCoating (rayx::DesignElement)</li> <li>setRoughnessSubstrate (rayx::DesignElement)</li> <li>setShortHalfAxisB (rayx::DesignElement)</li> <li>setShortRadius (rayx::DesignElement)</li> <li>setSlopeError (rayx::DesignElement)</li> <li>setStopHeight (rayx::DesignElement)</li> <li>setStopWidth (rayx::DesignElement)</li> <li>setStructureFactorImF0 (rayx::DesignElement)</li> <li>setStructureFactorImFH (rayx::DesignElement)</li> <li>setStructureFactorImFHC (rayx::DesignElement)</li> <li>setStructureFactorReF0 (rayx::DesignElement)</li> <li>setStructureFactorReFH (rayx::DesignElement)</li> <li>setStructureFactorReFHC (rayx::DesignElement)</li> <li>setSurfaceCoatingType (rayx::DesignElement)</li> <li>setThicknessCoating (rayx::DesignElement)</li> <li>setThicknessSubstrate (rayx::DesignElement)</li> <li>setTotalHeight (rayx::DesignElement)</li> <li>setTotalLength (rayx::DesignElement)</li> <li>setTotalWidth (rayx::DesignElement)</li> <li>setType (rayx::DesignElement, rayx::DesignSource)</li> <li>setUnitCellVolume (rayx::DesignElement)</li> <li>setVLSParameters (rayx::DesignElement)</li> <li>setBendingRadius (rayx::DesignSource)</li> <li>setDeltaOpeningAngle (rayx::DesignSource)</li> <li>setElectronEnergy (rayx::DesignSource)</li> <li>setElectronEnergyOrientation (rayx::DesignSource)</li> <li>setElectronSigmaX (rayx::DesignSource)</li> <li>setElectronSigmaXs (rayx::DesignSource)</li> <li>setElectronSigmaY (rayx::DesignSource)</li> <li>setElectronSigmaYs (rayx::DesignSource)</li> <li>setEnergy (rayx::DesignSource)</li> <li>setEnergyDistributionFile (rayx::DesignSource)</li> <li>setEnergyDistributionType (rayx::DesignSource)</li> <li>setEnergySpread (rayx::DesignSource)</li> <li>setEnergySpreadType (rayx::DesignSource)</li> <li>setEnergySpreadUnit (rayx::DesignSource)</li> <li>setHeightDist (rayx::DesignSource)</li> <li>setHorDist (rayx::DesignSource)</li> <li>setHorDivergence (rayx::DesignSource)</li> <li>setMaxOpeningAngle (rayx::DesignSource)</li> <li>setMinOpeningAngle (rayx::DesignSource)</li> <li>setNumOfCircles (rayx::DesignSource)</li> <li>setNumberOfRays (rayx::DesignSource)</li> <li>setNumberOfSeparateEnergies (rayx::DesignSource)</li> <li>setPhotonFlux (rayx::DesignSource)</li> <li>setRayList (rayx::DesignSource)</li> <li>setSigmaType (rayx::DesignSource)</li> <li>setSourceDepth (rayx::DesignSource)</li> <li>setSourceHeight (rayx::DesignSource)</li> <li>setSourceWidth (rayx::DesignSource)</li> <li>setStokescirc (rayx::DesignSource)</li> <li>setStokeslin0 (rayx::DesignSource)</li> <li>setStokeslin45 (rayx::DesignSource)</li> <li>setUndulatorLength (rayx::DesignSource)</li> <li>setVerDist (rayx::DesignSource)</li> <li>setVerDivergence (rayx::DesignSource)</li> <li>setVerEBeamDivergence (rayx::DesignSource)</li> <li>setWidthDist (rayx::DesignSource)</li> <li>Stop (rayx::InstrumentationTimer)</li> <li>setShouldRecordElement (rayx::ObjectIndexMask)</li> <li>setShouldRecordObject (rayx::ObjectIndexMask)</li> <li>setShouldRecordSource (rayx::ObjectIndexMask)</li> <li>shouldRecordElement (rayx::ObjectIndexMask)</li> <li>shouldRecordObject (rayx::ObjectIndexMask)</li> <li>shouldRecordSource (rayx::ObjectIndexMask)</li> <li>sin (rayx::Rad)</li> <li>size (rayx::Rays)</li> <li>sort (rayx::Rays)</li> <li>sortByObjectId (rayx::Rays)</li> <li>sortByPathIdAndPathEventId (rayx::Rays)</li> <li>SeparateEnergies (rayx::SeparateEnergies)</li> <li>SimpleUndulatorSource (rayx::SimpleUndulatorSource)</li> <li>SoftEdge (rayx::SoftEdge)</li> </ul>"},{"location":"rayxCore/class_member_functions/#t","title":"t","text":"<ul> <li>toRad (rayx::Deg)</li> <li>type (rayx::DesignMap, rayx::xml::Parser)</li> <li>trace (rayx::DeviceTracer, rayx::MegaKernelTracer, rayx::Tracer)</li> <li>traverse (rayx::Group)</li> <li>traceBatch (rayx::MegaKernelTracer)</li> <li>transferEventsBatch (rayx::MegaKernelTracer)</li> <li>toObjectIndexMask (rayx::ObjectMask)</li> <li>tan (rayx::Rad)</li> <li>toDeg (rayx::Rad)</li> <li>Tracer (rayx::Tracer)</li> </ul>"},{"location":"rayxCore/class_member_functions/#u","title":"u","text":"<ul> <li>update (rayx::GenRays, rayx::Resources)</li> </ul>"},{"location":"rayxCore/class_member_functions/#v","title":"v","text":"<ul> <li>Variant (rayx::Variant)</li> <li>visit (rayx::Variant)</li> <li>Verb (rayx::Verb)</li> </ul>"},{"location":"rayxCore/class_member_functions/#w","title":"w","text":"<ul> <li>Warn (rayx::Warn)</li> </ul>"},{"location":"rayxCore/class_member_functions/#_1","title":"~","text":"<ul> <li>~BeamlineNode (rayx::BeamlineNode)</li> <li>~DesignElement (rayx::DesignElement)</li> <li>~DesignSource (rayx::DesignSource)</li> <li>~DeviceTracer (rayx::DeviceTracer)</li> <li>~Exit (rayx::Exit)</li> <li>~Group (rayx::Group)</li> <li>~InstrumentationTimer (rayx::InstrumentationTimer)</li> <li>~Log (rayx::Log)</li> <li>~Verb (rayx::Verb)</li> <li>~Warn (rayx::Warn)</li> </ul>"},{"location":"rayxCore/class_member_variables/","title":"Class Member Variables","text":""},{"location":"rayxCore/class_member_variables/#a","title":"a","text":"<ul> <li>atLeast (rayx::BlockSizeConstraint::InRange)</li> <li>atMost (rayx::BlockSizeConstraint::InRange)</li> <li>attrRecordMask (rayx::ConstState)</li> </ul>"},{"location":"rayxCore/class_member_variables/#c","title":"c","text":"<ul> <li>continous (rayx::EnergyDistributionList)</li> <li>counter (rayx::Rand)</li> </ul>"},{"location":"rayxCore/class_member_variables/#d","title":"d","text":"<ul> <li>deg (rayx::Deg)</li> <li>devices (rayx::DeviceConfig)</li> <li>d_energyDistributionListEnergies (rayx::GenRays)</li> <li>d_energyDistributionListWeights (rayx::GenRays)</li> <li>d_rayListSources (rayx::GenRays)</li> <li>d_rays (rayx::GenRays, rayx::GenRays::BatchConfig)</li> <li>d_compactEventsBatch (rayx::Resources)</li> <li>d_elements (rayx::Resources)</li> <li>d_eventStoreFlags (rayx::Resources)</li> <li>d_eventStoreFlagsPrefixSum (rayx::Resources)</li> <li>d_eventsBatch (rayx::Resources)</li> <li>d_materialIndices (rayx::Resources)</li> <li>d_materialTable (rayx::Resources)</li> <li>d_objectRecordMask (rayx::Resources)</li> <li>d_objectTransforms (rayx::Resources)</li> <li>direction (rayx::detail::Ray)</li> </ul>"},{"location":"rayxCore/class_member_variables/#e","title":"e","text":"<ul> <li>elementIndex (rayx::CollisionWithElement)</li> <li>elements (rayx::ConstState)</li> <li>enable (rayx::DeviceConfig::Device)</li> <li>energies (rayx::EnergyDistributionList)</li> <li>events (rayx::MutableState)</li> <li>element (rayx::OpticalElementAndTransform)</li> <li>electric_field (rayx::detail::Ray)</li> <li>energy (rayx::detail::Ray)</li> <li>event_type (rayx::detail::Ray)</li> <li>energyDistribution (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_member_variables/#f","title":"f","text":"<ul> <li>filename (rayx::Exit)</li> <li>forward (rayx::RotationBase)</li> </ul>"},{"location":"rayxCore/class_member_variables/#h","title":"h","text":"<ul> <li>hitpoint (rayx::CollisionPoint)</li> </ul>"},{"location":"rayxCore/class_member_variables/#i","title":"i","text":"<ul> <li>index (rayx::DeviceConfig::Device)</li> <li>indices (rayx::MaterialTables, rayx::ObjectMask::ByIndices)</li> </ul>"},{"location":"rayxCore/class_member_variables/#l","title":"l","text":"<ul> <li>line (rayx::Exit)</li> <li>lookUpPaths (rayx::ResourceHandler)</li> </ul>"},{"location":"rayxCore/class_member_variables/#m","title":"m","text":"<ul> <li>m_parent (rayx::BeamlineNode)</li> <li>m_deltaOpeningAngle (rayx::CircleSource)</li> <li>m_maxOpeningAngle (rayx::CircleSource)</li> <li>m_minOpeningAngle (rayx::CircleSource)</li> <li>m_numOfCircles (rayx::CircleSource)</li> <li>m_pol (rayx::CircleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceDepth (rayx::CircleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceHeight (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_sourceWidth (rayx::CircleSource, rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>materialIndices (rayx::ConstState)</li> <li>materialTable (rayx::ConstState)</li> <li>maxEvents (rayx::ConstState)</li> <li>m_energy (rayx::DatEntry, rayx::NffEntry, rayx::PalikEntry)</li> <li>m_weight (rayx::DatEntry)</li> <li>m_Lines (rayx::DatFile, rayx::NffTable, rayx::PalikTable)</li> <li>m_continuous (rayx::DatFile)</li> <li>m_end (rayx::DatFile)</li> <li>m_lineCount (rayx::DatFile)</li> <li>m_start (rayx::DatFile)</li> <li>m_step (rayx::DatFile)</li> <li>m_title (rayx::DatFile)</li> <li>m_weightSum (rayx::DatFile)</li> <li>m_elementParameters (rayx::DesignElement, rayx::DesignSource)</li> <li>m_variant (rayx::DesignMap, rayx::ObjectMask, rayx::Variant)</li> <li>m_it (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>m_fetchedDeviceType (rayx::DeviceConfig)</li> <li>m_bendingRadius (rayx::DipoleSource)</li> <li>m_criticalEnergy (rayx::DipoleSource)</li> <li>m_electronEnergy (rayx::DipoleSource)</li> <li>m_electronEnergyOrientation (rayx::DipoleSource)</li> <li>m_energySpread (rayx::DipoleSource, rayx::HardEdge, rayx::SeparateEnergies)</li> <li>m_gamma (rayx::DipoleSource)</li> <li>m_horDivergence (rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_maxFlux (rayx::DipoleSource)</li> <li>m_maxIntensity (rayx::DipoleSource)</li> <li>m_photonEnergy (rayx::DipoleSource, rayx::SimpleUndulatorSource)</li> <li>m_verDivergence (rayx::DipoleSource, rayx::MatrixSource, rayx::PixelSource, rayx::PointSource, rayx::SimpleUndulatorSource)</li> <li>m_verEbeamDivergence (rayx::DipoleSource)</li> <li>m_numRaysBatchAtMost (rayx::GenRays)</li> <li>m_numRaysTotal (rayx::GenRays)</li> <li>m_seed (rayx::GenRays)</li> <li>m_sourceStates (rayx::GenRays)</li> <li>m_startRayIndex (rayx::GenRays)</li> <li>m_children (rayx::Group)</li> <li>m_name (rayx::Group)</li> <li>m_orientation (rayx::Group)</li> <li>m_position (rayx::Group)</li> <li>m_centerEnergy (rayx::HardEdge, rayx::SeparateEnergies, rayx::SoftEdge)</li> <li>m_Name (rayx::InstrumentationTimer)</li> <li>m_StartTimepoint (rayx::InstrumentationTimer)</li> <li>m_canPrint (rayx::InstrumentationTimer)</li> <li>m_isStopped (rayx::InstrumentationTimer)</li> <li>m_numberOfRays (rayx::LightSourceBase)</li> <li>materials (rayx::MaterialTables)</li> <li>m_deviceIndex (rayx::MegaKernelTracer)</li> <li>m_genRaysResources (rayx::MegaKernelTracer)</li> <li>m_resources (rayx::MegaKernelTracer)</li> <li>m_f1 (rayx::NffEntry)</li> <li>m_f2 (rayx::NffEntry)</li> <li>m_element (rayx::NffTable, rayx::PalikTable)</li> <li>m_elementMask (rayx::ObjectIndexMask)</li> <li>m_sourceMask (rayx::ObjectIndexMask)</li> <li>m_inTrans (rayx::ObjectTransform)</li> <li>m_outTrans (rayx::ObjectTransform)</li> <li>m_azimuthalAngle (rayx::OpticalElement)</li> <li>m_behaviour (rayx::OpticalElement)</li> <li>m_coating (rayx::OpticalElement)</li> <li>m_cutout (rayx::OpticalElement)</li> <li>m_material (rayx::OpticalElement)</li> <li>m_slopeError (rayx::OpticalElement)</li> <li>m_surface (rayx::OpticalElement)</li> <li>m_k (rayx::PalikEntry)</li> <li>m_n (rayx::PalikEntry)</li> <li>m_heightDist (rayx::PointSource)</li> <li>m_horDist (rayx::PointSource)</li> <li>m_verDist (rayx::PointSource)</li> <li>m_widthDist (rayx::PointSource)</li> <li>m_numberOfEnergies (rayx::SeparateEnergies)</li> <li>m_cylindricalBowingAmp (rayx::SlopeError)</li> <li>m_cylindricalBowingRadius (rayx::SlopeError)</li> <li>m_mer (rayx::SlopeError)</li> <li>m_sag (rayx::SlopeError)</li> <li>m_thermalDistortionAmp (rayx::SlopeError)</li> <li>m_thermalDistortionSigmaX (rayx::SlopeError)</li> <li>m_thermalDistortionSigmaZ (rayx::SlopeError)</li> <li>m_sigma (rayx::SoftEdge)</li> <li>m_deviceTracer (rayx::Tracer)</li> <li>m_dSpacing2 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_offsetAngle (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImF0 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImFH (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorImFHC (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReF0 (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReFH (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_structureFactorReFHC (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_unitCellVolume (rayx::detail::BehaviourTypes::Crystal)</li> <li>m_roughnessSubstrate (rayx::detail::BehaviourTypes::Foil)</li> <li>m_thicknessSubstrate (rayx::detail::BehaviourTypes::Foil)</li> <li>m_lineDensity (rayx::detail::BehaviourTypes::Grating)</li> <li>m_orderOfDiffraction (rayx::detail::BehaviourTypes::Grating, rayx::detail::BehaviourTypes::RZP)</li> <li>m_vls (rayx::detail::BehaviourTypes::Grating)</li> <li>m_additionalOrder (rayx::detail::BehaviourTypes::RZP)</li> <li>m_derivationMethod (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designAlphaAngle (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designBetaAngle (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designMeridionalEntranceArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designMeridionalExitArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designOrderOfDiffraction (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designSagittalEntranceArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designSagittalExitArmLength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_designWavelength (rayx::detail::BehaviourTypes::RZP)</li> <li>m_fresnelZOffset (rayx::detail::BehaviourTypes::RZP)</li> <li>m_imageType (rayx::detail::BehaviourTypes::RZP)</li> <li>m_rzpType (rayx::detail::BehaviourTypes::RZP)</li> <li>m_beamstopCutout (rayx::detail::BehaviourTypes::Slit)</li> <li>m_openingCutout (rayx::detail::BehaviourTypes::Slit)</li> <li>material (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> <li>m_diameter_x (rayx::detail::CutoutTypes::Elliptical)</li> <li>m_diameter_z (rayx::detail::CutoutTypes::Elliptical)</li> <li>m_length (rayx::detail::CutoutTypes::Rect, rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_width (rayx::detail::CutoutTypes::Rect)</li> <li>m_widthA (rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_widthB (rayx::detail::CutoutTypes::Trapezoid)</li> <li>m_a11 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a12 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a13 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a14 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a22 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a23 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a24 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a33 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a34 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_a44 (rayx::detail::SurfaceTypes::Cubic, rayx::detail::SurfaceTypes::Quadric)</li> <li>m_b12 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b13 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b21 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b23 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b31 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_b32 (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_psi (rayx::detail::SurfaceTypes::Cubic)</li> <li>m_icurv (rayx::detail::SurfaceTypes::Quadric)</li> <li>m_longRadius (rayx::detail::SurfaceTypes::Toroid)</li> <li>m_shortRadius (rayx::detail::SurfaceTypes::Toroid)</li> <li>m_toroidType (rayx::detail::SurfaceTypes::Toroid)</li> </ul>"},{"location":"rayxCore/class_member_variables/#n","title":"n","text":"<ul> <li>normal (rayx::CollisionPoint)</li> <li>numElements (rayx::ConstState, rayx::Resources::BeamlineConfig)</li> <li>numSources (rayx::ConstState, rayx::Resources::BeamlineConfig)</li> <li>name (rayx::DeviceConfig::Device, rayx::GenRays::SourceState)</li> <li>numRaysBatch (rayx::GenRays::BatchConfig)</li> <li>numBatches (rayx::GenRays::SourceConfig)</li> <li>numRaysBatchAtMost (rayx::GenRays::SourceConfig)</li> <li>numRaysTotal (rayx::GenRays::SourceConfig)</li> <li>numLayers (rayx::detail::CoatingTypes::MultilayerCoating)</li> <li>node (rayx::xml::Parser)</li> <li>numRaysSource (rayx::GenRays::SourceState)</li> <li>numRaysSourceRemaining (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_member_variables/#o","title":"o","text":"<ul> <li>objectRecordMask (rayx::ConstState)</li> <li>objectTransforms (rayx::ConstState)</li> <li>outputEventsGridStride (rayx::ConstState)</li> <li>object_id (rayx::detail::Ray)</li> <li>optical_path_length (rayx::detail::Ray)</li> <li>order (rayx::detail::Ray)</li> </ul>"},{"location":"rayxCore/class_member_variables/#p","title":"p","text":"<ul> <li>point (rayx::CollisionWithElement)</li> <li>p (rayx::ComplexFresnelCoeffs, rayx::FresnelCoeffs)</li> <li>prefixWeights (rayx::EnergyDistributionList)</li> <li>psi (rayx::PsiAndStokes)</li> <li>path_event_id (rayx::detail::Ray)</li> <li>path_id (rayx::detail::Ray)</li> <li>position (rayx::detail::Ray)</li> </ul>"},{"location":"rayxCore/class_member_variables/#r","title":"r","text":"<ul> <li>rays (rayx::ConstState, rayx::RayListSource)</li> <li>rad (rayx::Rad)</li> <li>right (rayx::RotationBase)</li> <li>roughness (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> <li>rand (rayx::detail::Ray)</li> <li>rmlFile (rayx::xml::Parser)</li> </ul>"},{"location":"rayxCore/class_member_variables/#s","title":"s","text":"<ul> <li>s (rayx::ComplexFresnelCoeffs, rayx::FresnelCoeffs)</li> <li>sequential (rayx::ConstState)</li> <li>score (rayx::DeviceConfig::Device)</li> <li>size (rayx::EnergyDistributionList)</li> <li>storedFlags (rayx::MutableState)</li> <li>stokes (rayx::PsiAndStokes)</li> <li>source_id (rayx::detail::Ray)</li> <li>source (rayx::GenRays::SourceState)</li> <li>sourceId (rayx::GenRays::SourceState)</li> </ul>"},{"location":"rayxCore/class_member_variables/#t","title":"t","text":"<ul> <li>type (rayx::DeviceConfig::Device)</li> <li>transform (rayx::OpticalElementAndTransform)</li> <li>thickness (rayx::detail::CoatingTypes::MultilayerCoating, rayx::detail::CoatingTypes::OneCoating)</li> </ul>"},{"location":"rayxCore/class_member_variables/#u","title":"u","text":"<ul> <li>up (rayx::RotationBase)</li> </ul>"},{"location":"rayxCore/class_member_variables/#v","title":"v","text":"<ul> <li>value (rayx::BlockSizeConstraint::AtLeast, rayx::BlockSizeConstraint::AtMost, rayx::BlockSizeConstraint::Exact)</li> </ul>"},{"location":"rayxCore/class_member_variables/#w","title":"w","text":"<ul> <li>weightSum (rayx::EnergyDistributionList)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"rayxCore/class_member_typedefs/#a","title":"a","text":"<ul> <li>Acc (rayx::MegaKernelTracer)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#d","title":"d","text":"<ul> <li>difference_type (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>Dim (rayx::MegaKernelTracer, rayx::Resources)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#e","title":"e","text":"<ul> <li>EnergyDistributionList (rayx::EnergyDistributionDataBase)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#g","title":"g","text":"<ul> <li>GenRaysAcc (rayx::MegaKernelTracer)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#h","title":"h","text":"<ul> <li>HardEdge (rayx::EnergyDistributionDataBase)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#i","title":"i","text":"<ul> <li>iterator_category (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> <li>Index (rayx::DeviceConfig::Device)</li> <li>Idx (rayx::MegaKernelTracer, rayx::Resources)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#p","title":"p","text":"<ul> <li>pointer (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#r","title":"r","text":"<ul> <li>reference (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#s","title":"s","text":"<ul> <li>Score (rayx::DeviceConfig::Device)</li> <li>SeparateEnergies (rayx::EnergyDistributionDataBase)</li> <li>SoftEdge (rayx::EnergyDistributionDataBase)</li> <li>SourceVariant (rayx::GenRays)</li> </ul>"},{"location":"rayxCore/class_member_typedefs/#v","title":"v","text":"<ul> <li>Variant (rayx::DesignMap, rayx::ObjectMask)</li> <li>value_type (rayx::DesignMap::ConstIterator, rayx::DesignMap::Iterator)</li> </ul>"},{"location":"rayxCore/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"rayxCore/namespace_members/","title":"Namespace Members","text":""},{"location":"rayxCore/namespace_members/#a","title":"a","text":"<ul> <li>All (rayx)</li> <li>advanceElectricField (rayx)</li> <li>allocBuf (rayx)</li> <li>allocRaysBuf (rayx)</li> <li>angleBetweenUnitVectors (rayx)</li> <li>appendH5 (rayx)</li> <li>applySlopeError (rayx)</li> <li>assertCutoutSubset (rayx)</li> <li>abs (rayx::complex)</li> <li>arg (rayx::complex)</li> </ul>"},{"location":"rayxCore/namespace_members/#b","title":"b","text":"<ul> <li>BENCH_FLAG (rayx)</li> <li>Beamline (rayx)</li> <li>BehaveType (rayx)</li> <li>Behaviour (rayx)</li> <li>BehaviourType (rayx)</li> <li>BehaviourTypeToString (rayx)</li> <li>behave (rayx)</li> <li>behaveCrystal (rayx)</li> <li>behaveFoil (rayx)</li> <li>behaveGrating (rayx)</li> <li>behaveImagePlane (rayx)</li> <li>behaveMirror (rayx)</li> <li>behaveRZP (rayx)</li> <li>behaveSlit (rayx)</li> <li>bessel1 (rayx)</li> <li>bessel_diff (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#c","title":"c","text":"<ul> <li>CentralBeamstop (rayx)</li> <li>CentralBeamstopToString (rayx)</li> <li>Coating (rayx)</li> <li>CurvatureType (rayx)</li> <li>CurvatureTypeToString (rayx)</li> <li>Cutout (rayx)</li> <li>CutoutType (rayx)</li> <li>CutoutTypeToString (rayx)</li> <li>CylinderDirection (rayx)</li> <li>calcBrewstersAngle (rayx)</li> <li>calcCriticalAngle (rayx)</li> <li>calcDipoleFold (rayx)</li> <li>calcGamma (rayx)</li> <li>calcJonesMatrix (rayx)</li> <li>calcMaxFlux (rayx)</li> <li>calcMaxIntensity (rayx)</li> <li>calcPolaririzationMatrix (rayx)</li> <li>calcPolaririzationMatrixFoil (rayx)</li> <li>calcReflectAmplitude (rayx)</li> <li>calcReflectIntensity (rayx)</li> <li>calcReflectPolarizationMatrixAtNormalIncidence (rayx)</li> <li>calcRefractAmplitude (rayx)</li> <li>calcRefractAngle (rayx)</li> <li>calcRefractIntensity (rayx)</li> <li>calcTransformationMatrices (rayx)</li> <li>calcVerDivergence (rayx)</li> <li>canonicalizeRepositoryPath (rayx)</li> <li>canonicalizeUserPath (rayx)</li> <li>ceilIntDivision (rayx)</li> <li>cmat3 (rayx)</li> <li>computeEta (rayx)</li> <li>computeMultilayerReflectance (rayx)</li> <li>computeR (rayx)</li> <li>computeSingleCoatingReflectance (rayx)</li> <li>computeTransmittance (rayx)</li> <li>contains (rayx)</li> <li>countSetBits (rayx)</li> <li>cubicDirection (rayx)</li> <li>cubicPosition (rayx)</li> <li>cutoutBoundingBox (rayx)</li> <li>cvec2 (rayx)</li> <li>cvec3 (rayx)</li> <li>Complex (rayx::complex)</li> </ul>"},{"location":"rayxCore/namespace_members/#d","title":"d","text":"<ul> <li>DEFAULT_BATCH_SIZE (rayx)</li> <li>DesignObject (rayx)</li> <li>DesignPlane (rayx)</li> <li>Direction (rayx)</li> <li>DirectionX (rayx)</li> <li>DirectionY (rayx)</li> <li>DirectionZ (rayx)</li> <li>dbg (rayx)</li> <li>defaultMaxEvents (rayx)</li> <li>degreeOfPolarization (rayx)</li> <li>dipoleBessel (rayx)</li> <li>directionToSphericalCoords (rayx)</li> <li>dpow (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#e","title":"e","text":"<ul> <li>ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT (rayx)</li> <li>ELECTRIC_PERMITTIVITY (rayx)</li> <li>ELECTRON_MASS (rayx)</li> <li>ELECTRON_RADIUS (rayx)</li> <li>ELECTRON_VOLT (rayx)</li> <li>ELEMENTARY_CHARGE (rayx)</li> <li>ElectricField (rayx)</li> <li>ElectricFieldX (rayx)</li> <li>ElectricFieldY (rayx)</li> <li>ElectricFieldZ (rayx)</li> <li>ElectronEnergyOrientation (rayx)</li> <li>ElectronEnergyOrientationToString (rayx)</li> <li>ElementType (rayx)</li> <li>ElementTypeToString (rayx)</li> <li>Energy (rayx)</li> <li>EnergyDistributionDataVariant (rayx)</li> <li>EnergyDistributionType (rayx)</li> <li>EnergyDistributionTypeToString (rayx)</li> <li>EnergyDistributionVariant (rayx)</li> <li>EnergySpreadUnit (rayx)</li> <li>EnergySpreadUnitToString (rayx)</li> <li>EventType (rayx)</li> <li>EventTypeMask (rayx)</li> <li>EventTypeToString (rayx)</li> <li>electricFieldToStokes (rayx)</li> <li>electricFieldToStokesWithBaseConvention (rayx)</li> <li>energyToWaveLength (rayx)</li> <li>error_fn (rayx)</li> <li>eventTypeToMask (rayx)</li> <li>exclude (rayx)</li> <li>execWithValidWorkDiv (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#f","title":"f","text":"<ul> <li>FACTOR_ELECTRON_ENERGY_SC (rayx)</li> <li>FACTOR_SCHWINGER_RAY (rayx)</li> <li>FINE_STRUCTURE_CONSTANT (rayx)</li> <li>FIXED_SEED (rayx)</li> <li>FigureRotation (rayx)</li> <li>FigureRotationToString (rayx)</li> <li>fact (rayx)</li> <li>findCollisionInElementCoords (rayx)</li> <li>findCollisionInElementCoordsWithoutSlopeError (rayx)</li> <li>findCollisionWithElements (rayx)</li> <li>fixSeed (rayx)</li> <li>formatAsVec (rayx)</li> <li>formatAsVec&lt; double &gt; (rayx)</li> <li>forwardVectorToBaseConvention (rayx)</li> <li>fraun_diff (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#g","title":"g","text":"<ul> <li>GratingMount (rayx)</li> <li>GratingMountToString (rayx)</li> <li>getAsymmetryFactor (rayx)</li> <li>getAtomicMassAndRho (rayx)</li> <li>getBlockSize (rayx)</li> <li>getBraggAngle (rayx)</li> <li>getCone (rayx)</li> <li>getCrystal (rayx)</li> <li>getCubicCollision (rayx)</li> <li>getCylinder (rayx)</li> <li>getDebugVerbose (rayx)</li> <li>getDiffractionPrefactor (rayx)</li> <li>getDipoleInterpolation (rayx)</li> <li>getEllipsoid (rayx)</li> <li>getExpertsCubic (rayx)</li> <li>getExpertsOptics (rayx)</li> <li>getFoil (rayx)</li> <li>getGrating (rayx)</li> <li>getImageplane (rayx)</li> <li>getNffEntry (rayx)</li> <li>getNffEntryCount (rayx)</li> <li>getPalikEntry (rayx)</li> <li>getPalikEntryCount (rayx)</li> <li>getParaboloid (rayx)</li> <li>getPlaneGrating (rayx)</li> <li>getPlaneMirror (rayx)</li> <li>getQuadricCollision (rayx)</li> <li>getRZP (rayx)</li> <li>getRayAttrNames (rayx)</li> <li>getRecordIndex (rayx)</li> <li>getRefractiveIndex (rayx)</li> <li>getSlit (rayx)</li> <li>getSphereGrating (rayx)</li> <li>getSphereMirror (rayx)</li> <li>getStokesSyn (rayx)</li> <li>getSurfaceCoating (rayx)</li> <li>getTheta (rayx)</li> <li>getToroidCollision (rayx)</li> <li>getToroidMirror (rayx)</li> <li>getToroidalGrating (rayx)</li> <li>getWorkDivForAcc (rayx)</li> <li>get_factorCriticalEnergy (rayx)</li> <li>get_factorElectronEnergy (rayx)</li> <li>get_factorOmega (rayx)</li> <li>globalToLocalElectricField (rayx)</li> <li>globalToLocalElectricFieldWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#i","title":"i","text":"<ul> <li>INV_NM_TO_EVOLT (rayx)</li> <li>IT_ASTIGMATIC2ASTIGMATIC (rayx)</li> <li>IT_POINT2HORIZONTAL_DIVERGENT_LINE (rayx)</li> <li>IT_POINT2HORIZONTAL_LINE (rayx)</li> <li>IT_POINT2POINT (rayx)</li> <li>importBeamline (rayx)</li> <li>inCutout (rayx)</li> <li>intensity (rayx)</li> <li>interceptFoil (rayx)</li> <li>interceptReflect (rayx)</li> <li>interceptReflectCrystal (rayx)</li> <li>isFlag (rayx)</li> <li>isRayTerminated (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#k","title":"k","text":"<ul> <li>keyCutoutPoints (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#l","title":"l","text":"<ul> <li>LocalElectricField (rayx)</li> <li>loadMaterialTables (rayx)</li> <li>loadRay (rayx)</li> <li>localElectricFieldToStokes (rayx)</li> <li>localToGlobalElectricField (rayx)</li> <li>localToGlobalElectricFieldWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#m","title":"m","text":"<ul> <li>Map (rayx)</li> <li>Material (rayx)</li> <li>MaterialToString (rayx)</li> <li>makeBehaviour (rayx)</li> <li>makeCone (rayx)</li> <li>makeCrystal (rayx)</li> <li>makeCubic (rayx)</li> <li>makeCylinder (rayx)</li> <li>makeElement (rayx)</li> <li>makeEllipsoid (rayx)</li> <li>makeFoil (rayx)</li> <li>makeGrating (rayx)</li> <li>makeParaboloid (rayx)</li> <li>makePlane (rayx)</li> <li>makeQuadric (rayx)</li> <li>makeRZPBehaviour (rayx)</li> <li>makeSlit (rayx)</li> <li>makeSphere (rayx)</li> <li>makeSurface (rayx)</li> <li>makeToroid (rayx)</li> <li>materialFromString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#n","title":"n","text":"<ul> <li>None (rayx)</li> <li>nextMultiple (rayx)</li> <li>nextPowerOfTwo (rayx)</li> <li>normalCartesian (rayx)</li> <li>normalCylindrical (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#o","title":"o","text":"<ul> <li>operator* (glm)</li> <li>ObjectId (rayx)</li> <li>OptBuf (rayx)</li> <li>OptCollisionPoint (rayx)</li> <li>OptCollisionWithElement (rayx)</li> <li>OpticalPathLength (rayx)</li> <li>Order (rayx)</li> <li>operator! (rayx)</li> <li>operator!= (rayx)</li> <li>operator&amp; (rayx)</li> <li>operator&amp;= (rayx)</li> <li>operator&lt;&lt; (rayx)</li> <li>operator== (rayx)</li> <li>operator^ (rayx)</li> <li>operator^= (rayx)</li> <li>operator| (rayx)</li> <li>operator|= (rayx)</li> <li>operator~ (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#p","title":"p","text":"<ul> <li>PI (rayx)</li> <li>PLANCK (rayx)</li> <li>PLANCK_BAR (rayx)</li> <li>ParaboloidType (rayx)</li> <li>ParaboloidTypeToString (rayx)</li> <li>PathEventId (rayx)</li> <li>Position (rayx)</li> <li>PositionX (rayx)</li> <li>PositionY (rayx)</li> <li>PositionZ (rayx)</li> <li>polar (rayx::complex)</li> <li>param (rayx::xml)</li> <li>paramDouble (rayx::xml)</li> <li>paramDvec3 (rayx::xml)</li> <li>paramElectronEnergyOrientation (rayx::xml)</li> <li>paramEnergyDistribution (rayx::xml)</li> <li>paramInt (rayx::xml)</li> <li>paramMaterial (rayx::xml)</li> <li>paramMultilayer (rayx::xml)</li> <li>paramOrientation (rayx::xml)</li> <li>paramPosition (rayx::xml)</li> <li>paramSlopeError (rayx::xml)</li> <li>paramSourcePulseType (rayx::xml)</li> <li>paramStr (rayx::xml)</li> <li>paramVls (rayx::xml)</li> <li>parseGroup (rayx::xml)</li> </ul>"},{"location":"rayxCore/namespace_members/#r","title":"r","text":"<ul> <li>RZPLineDensity (rayx)</li> <li>RZPType (rayx)</li> <li>RZPTypeToString (rayx)</li> <li>RandCounter (rayx)</li> <li>RayAttrMask (rayx)</li> <li>RayAttrMaskCount (rayx)</li> <li>randomDouble (rayx)</li> <li>randomDoubleInRange (rayx)</li> <li>randomIntInRange (rayx)</li> <li>randomNormal (rayx)</li> <li>randomSeed (rayx)</li> <li>randomUint (rayx)</li> <li>rayAttrStringsToRayAttrMask (rayx)</li> <li>rayMatrixMult (rayx)</li> <li>raysBufToRaysPtr (rayx)</li> <li>readCsv (rayx)</li> <li>readFile (rayx)</li> <li>readFileAlign32 (rayx)</li> <li>readH5ObjectNames (rayx)</li> <li>readH5Rays (rayx)</li> <li>refrac2D (rayx)</li> <li>refract_dvec3 (rayx)</li> <li>rotationMatrix (rayx)</li> <li>rotationMatrixWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#s","title":"s","text":"<ul> <li>SPEED_OF_LIGHT (rayx)</li> <li>Sequential (rayx)</li> <li>SigmaType (rayx)</li> <li>SigmaTypeToString (rayx)</li> <li>SourceDist (rayx)</li> <li>SourceDistToString (rayx)</li> <li>SourceId (rayx)</li> <li>SourcePulseType (rayx)</li> <li>SpreadType (rayx)</li> <li>SpreadTypeToString (rayx)</li> <li>Stokes (rayx)</li> <li>StringToBehaviourType (rayx)</li> <li>StringToCentralBeamstop (rayx)</li> <li>StringToCurvatureType (rayx)</li> <li>StringToCutoutType (rayx)</li> <li>StringToElectronEnergyOrientation (rayx)</li> <li>StringToElementType (rayx)</li> <li>StringToEnergyDistributionType (rayx)</li> <li>StringToEnergySpreadUnit (rayx)</li> <li>StringToEventType (rayx)</li> <li>StringToFigureRotation (rayx)</li> <li>StringToGratingMount (rayx)</li> <li>StringToMaterial (rayx)</li> <li>StringToParaboloidType (rayx)</li> <li>StringToRZPType (rayx)</li> <li>StringToSigmaType (rayx)</li> <li>StringToSourceDist (rayx)</li> <li>StringToSpreadType (rayx)</li> <li>Surface (rayx)</li> <li>SurfaceCoatingType (rayx)</li> <li>schwinger (rayx)</li> <li>selectEnergy (rayx)</li> <li>setAllMandatory (rayx)</li> <li>setCircleSource (rayx)</li> <li>setDebugVerbose (rayx)</li> <li>setDefaultEnergy (rayx)</li> <li>setDefaultOrientation (rayx)</li> <li>setDefaultPosition (rayx)</li> <li>setDipoleSource (rayx)</li> <li>setMatrixSource (rayx)</li> <li>setPixelSource (rayx)</li> <li>setPointSource (rayx)</li> <li>setSimpleUndulatorSource (rayx)</li> <li>setStokes (rayx)</li> <li>sphericalCoordsToDirection (rayx)</li> <li>squares64 (rayx)</li> <li>squaresDoubleRNG (rayx)</li> <li>squaresNormalRNG (rayx)</li> <li>stokesToElectricField (rayx)</li> <li>stokesToElectricFieldWithBaseConvention (rayx)</li> <li>stokesToLocalElectricField (rayx)</li> <li>storeRay (rayx)</li> <li>streamEnum (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#t","title":"t","text":"<ul> <li>ToroidType (rayx)</li> <li>tcomplex (rayx::complex)</li> <li>terminateRay (rayx)</li> <li>to_string (rayx)</li> <li>traceNonSequential (rayx)</li> <li>traceSequential (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#v","title":"v","text":"<ul> <li>ValueType (rayx)</li> <li>Variant (rayx::BlockSizeConstraint)</li> <li>vlsGrating (rayx)</li> </ul>"},{"location":"rayxCore/namespace_members/#w","title":"w","text":"<ul> <li>waveLengthToEnergy (rayx)</li> <li>writeCsv (rayx)</li> <li>writeFile (rayx)</li> <li>writeH5 (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"rayxCore/namespace_member_functions/#a","title":"a","text":"<ul> <li>advanceElectricField (rayx)</li> <li>allocBuf (rayx)</li> <li>allocRaysBuf (rayx)</li> <li>angleBetweenUnitVectors (rayx)</li> <li>appendH5 (rayx)</li> <li>applySlopeError (rayx)</li> <li>assertCutoutSubset (rayx)</li> <li>abs (rayx::complex)</li> <li>arg (rayx::complex)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#b","title":"b","text":"<ul> <li>behave (rayx)</li> <li>behaveCrystal (rayx)</li> <li>behaveFoil (rayx)</li> <li>behaveGrating (rayx)</li> <li>behaveImagePlane (rayx)</li> <li>behaveMirror (rayx)</li> <li>behaveRZP (rayx)</li> <li>behaveSlit (rayx)</li> <li>bessel1 (rayx)</li> <li>bessel_diff (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#c","title":"c","text":"<ul> <li>calcBrewstersAngle (rayx)</li> <li>calcCriticalAngle (rayx)</li> <li>calcDipoleFold (rayx)</li> <li>calcGamma (rayx)</li> <li>calcJonesMatrix (rayx)</li> <li>calcMaxFlux (rayx)</li> <li>calcMaxIntensity (rayx)</li> <li>calcPolaririzationMatrix (rayx)</li> <li>calcPolaririzationMatrixFoil (rayx)</li> <li>calcReflectAmplitude (rayx)</li> <li>calcReflectIntensity (rayx)</li> <li>calcReflectPolarizationMatrixAtNormalIncidence (rayx)</li> <li>calcRefractAmplitude (rayx)</li> <li>calcRefractAngle (rayx)</li> <li>calcRefractIntensity (rayx)</li> <li>calcTransformationMatrices (rayx)</li> <li>calcVerDivergence (rayx)</li> <li>canonicalizeRepositoryPath (rayx)</li> <li>canonicalizeUserPath (rayx)</li> <li>ceilIntDivision (rayx)</li> <li>computeEta (rayx)</li> <li>computeMultilayerReflectance (rayx)</li> <li>computeR (rayx)</li> <li>computeSingleCoatingReflectance (rayx)</li> <li>computeTransmittance (rayx)</li> <li>contains (rayx)</li> <li>countSetBits (rayx)</li> <li>cubicDirection (rayx)</li> <li>cubicPosition (rayx)</li> <li>cutoutBoundingBox (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#d","title":"d","text":"<ul> <li>dbg (rayx)</li> <li>defaultMaxEvents (rayx)</li> <li>degreeOfPolarization (rayx)</li> <li>dipoleBessel (rayx)</li> <li>directionToSphericalCoords (rayx)</li> <li>dpow (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#e","title":"e","text":"<ul> <li>electricFieldToStokes (rayx)</li> <li>electricFieldToStokesWithBaseConvention (rayx)</li> <li>energyToWaveLength (rayx)</li> <li>eventTypeToMask (rayx)</li> <li>exclude (rayx)</li> <li>execWithValidWorkDiv (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#f","title":"f","text":"<ul> <li>fact (rayx)</li> <li>findCollisionInElementCoords (rayx)</li> <li>findCollisionInElementCoordsWithoutSlopeError (rayx)</li> <li>findCollisionWithElements (rayx)</li> <li>fixSeed (rayx)</li> <li>formatAsVec (rayx)</li> <li>formatAsVec&lt; double &gt; (rayx)</li> <li>forwardVectorToBaseConvention (rayx)</li> <li>fraun_diff (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#g","title":"g","text":"<ul> <li>getAsymmetryFactor (rayx)</li> <li>getAtomicMassAndRho (rayx)</li> <li>getBlockSize (rayx)</li> <li>getBraggAngle (rayx)</li> <li>getCone (rayx)</li> <li>getCrystal (rayx)</li> <li>getCubicCollision (rayx)</li> <li>getCylinder (rayx)</li> <li>getDebugVerbose (rayx)</li> <li>getDiffractionPrefactor (rayx)</li> <li>getDipoleInterpolation (rayx)</li> <li>getEllipsoid (rayx)</li> <li>getExpertsCubic (rayx)</li> <li>getExpertsOptics (rayx)</li> <li>getFoil (rayx)</li> <li>getGrating (rayx)</li> <li>getImageplane (rayx)</li> <li>getNffEntry (rayx)</li> <li>getNffEntryCount (rayx)</li> <li>getPalikEntry (rayx)</li> <li>getPalikEntryCount (rayx)</li> <li>getParaboloid (rayx)</li> <li>getPlaneGrating (rayx)</li> <li>getPlaneMirror (rayx)</li> <li>getQuadricCollision (rayx)</li> <li>getRZP (rayx)</li> <li>getRayAttrNames (rayx)</li> <li>getRecordIndex (rayx)</li> <li>getRefractiveIndex (rayx)</li> <li>getSlit (rayx)</li> <li>getSphereGrating (rayx)</li> <li>getSphereMirror (rayx)</li> <li>getStokesSyn (rayx)</li> <li>getSurfaceCoating (rayx)</li> <li>getTheta (rayx)</li> <li>getToroidCollision (rayx)</li> <li>getToroidMirror (rayx)</li> <li>getToroidalGrating (rayx)</li> <li>getWorkDivForAcc (rayx)</li> <li>get_factorCriticalEnergy (rayx)</li> <li>get_factorElectronEnergy (rayx)</li> <li>get_factorOmega (rayx)</li> <li>globalToLocalElectricField (rayx)</li> <li>globalToLocalElectricFieldWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#i","title":"i","text":"<ul> <li>importBeamline (rayx)</li> <li>inCutout (rayx)</li> <li>intensity (rayx)</li> <li>interceptFoil (rayx)</li> <li>interceptReflect (rayx)</li> <li>interceptReflectCrystal (rayx)</li> <li>isFlag (rayx)</li> <li>isRayTerminated (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#k","title":"k","text":"<ul> <li>keyCutoutPoints (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#l","title":"l","text":"<ul> <li>loadMaterialTables (rayx)</li> <li>loadRay (rayx)</li> <li>localElectricFieldToStokes (rayx)</li> <li>localToGlobalElectricField (rayx)</li> <li>localToGlobalElectricFieldWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#m","title":"m","text":"<ul> <li>makeBehaviour (rayx)</li> <li>makeCone (rayx)</li> <li>makeCrystal (rayx)</li> <li>makeCubic (rayx)</li> <li>makeCylinder (rayx)</li> <li>makeElement (rayx)</li> <li>makeEllipsoid (rayx)</li> <li>makeFoil (rayx)</li> <li>makeGrating (rayx)</li> <li>makeParaboloid (rayx)</li> <li>makePlane (rayx)</li> <li>makeQuadric (rayx)</li> <li>makeRZPBehaviour (rayx)</li> <li>makeSlit (rayx)</li> <li>makeSphere (rayx)</li> <li>makeSurface (rayx)</li> <li>makeToroid (rayx)</li> <li>materialFromString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#n","title":"n","text":"<ul> <li>nextMultiple (rayx)</li> <li>nextPowerOfTwo (rayx)</li> <li>normalCartesian (rayx)</li> <li>normalCylindrical (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator* (glm)</li> <li>operator! (rayx)</li> <li>operator!= (rayx)</li> <li>operator&amp; (rayx)</li> <li>operator&amp;= (rayx)</li> <li>operator&lt;&lt; (rayx)</li> <li>operator== (rayx)</li> <li>operator^ (rayx)</li> <li>operator^= (rayx)</li> <li>operator| (rayx)</li> <li>operator|= (rayx)</li> <li>operator~ (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#p","title":"p","text":"<ul> <li>polar (rayx::complex)</li> <li>param (rayx::xml)</li> <li>paramDouble (rayx::xml)</li> <li>paramDvec3 (rayx::xml)</li> <li>paramElectronEnergyOrientation (rayx::xml)</li> <li>paramEnergyDistribution (rayx::xml)</li> <li>paramInt (rayx::xml)</li> <li>paramMaterial (rayx::xml)</li> <li>paramMultilayer (rayx::xml)</li> <li>paramOrientation (rayx::xml)</li> <li>paramPosition (rayx::xml)</li> <li>paramSlopeError (rayx::xml)</li> <li>paramSourcePulseType (rayx::xml)</li> <li>paramStr (rayx::xml)</li> <li>paramVls (rayx::xml)</li> <li>parseGroup (rayx::xml)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#r","title":"r","text":"<ul> <li>RZPLineDensity (rayx)</li> <li>randomDouble (rayx)</li> <li>randomDoubleInRange (rayx)</li> <li>randomIntInRange (rayx)</li> <li>randomNormal (rayx)</li> <li>randomSeed (rayx)</li> <li>randomUint (rayx)</li> <li>rayAttrStringsToRayAttrMask (rayx)</li> <li>rayMatrixMult (rayx)</li> <li>raysBufToRaysPtr (rayx)</li> <li>readCsv (rayx)</li> <li>readFile (rayx)</li> <li>readFileAlign32 (rayx)</li> <li>readH5ObjectNames (rayx)</li> <li>readH5Rays (rayx)</li> <li>refrac2D (rayx)</li> <li>refract_dvec3 (rayx)</li> <li>rotationMatrix (rayx)</li> <li>rotationMatrixWithBaseConvention (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#s","title":"s","text":"<ul> <li>schwinger (rayx)</li> <li>selectEnergy (rayx)</li> <li>setAllMandatory (rayx)</li> <li>setCircleSource (rayx)</li> <li>setDebugVerbose (rayx)</li> <li>setDefaultEnergy (rayx)</li> <li>setDefaultOrientation (rayx)</li> <li>setDefaultPosition (rayx)</li> <li>setDipoleSource (rayx)</li> <li>setMatrixSource (rayx)</li> <li>setPixelSource (rayx)</li> <li>setPointSource (rayx)</li> <li>setSimpleUndulatorSource (rayx)</li> <li>setStokes (rayx)</li> <li>sphericalCoordsToDirection (rayx)</li> <li>squares64 (rayx)</li> <li>squaresDoubleRNG (rayx)</li> <li>squaresNormalRNG (rayx)</li> <li>stokesToElectricField (rayx)</li> <li>stokesToElectricFieldWithBaseConvention (rayx)</li> <li>stokesToLocalElectricField (rayx)</li> <li>storeRay (rayx)</li> <li>streamEnum (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#t","title":"t","text":"<ul> <li>terminateRay (rayx)</li> <li>to_string (rayx)</li> <li>traceNonSequential (rayx)</li> <li>traceSequential (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#v","title":"v","text":"<ul> <li>vlsGrating (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_functions/#w","title":"w","text":"<ul> <li>waveLengthToEnergy (rayx)</li> <li>writeCsv (rayx)</li> <li>writeFile (rayx)</li> <li>writeH5 (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"rayxCore/namespace_member_variables/#a","title":"a","text":"<ul> <li>All (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#b","title":"b","text":"<ul> <li>BENCH_FLAG (rayx)</li> <li>BehaviourTypeToString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#c","title":"c","text":"<ul> <li>CentralBeamstopToString (rayx)</li> <li>CurvatureTypeToString (rayx)</li> <li>CutoutTypeToString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#d","title":"d","text":"<ul> <li>DEFAULT_BATCH_SIZE (rayx)</li> <li>Direction (rayx)</li> <li>DirectionX (rayx)</li> <li>DirectionY (rayx)</li> <li>DirectionZ (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#e","title":"e","text":"<ul> <li>ELECTRIC_PERMITIVITY_MULTIPLIES_SPEED_OF_LIGHT (rayx)</li> <li>ELECTRIC_PERMITTIVITY (rayx)</li> <li>ELECTRON_MASS (rayx)</li> <li>ELECTRON_RADIUS (rayx)</li> <li>ELECTRON_VOLT (rayx)</li> <li>ELEMENTARY_CHARGE (rayx)</li> <li>ElectricFieldX (rayx)</li> <li>ElectricFieldY (rayx)</li> <li>ElectricFieldZ (rayx)</li> <li>ElectronEnergyOrientationToString (rayx)</li> <li>ElementTypeToString (rayx)</li> <li>Energy (rayx)</li> <li>EnergyDistributionTypeToString (rayx)</li> <li>EnergySpreadUnitToString (rayx)</li> <li>EventType (rayx)</li> <li>EventTypeToString (rayx)</li> <li>error_fn (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#f","title":"f","text":"<ul> <li>FACTOR_ELECTRON_ENERGY_SC (rayx)</li> <li>FACTOR_SCHWINGER_RAY (rayx)</li> <li>FINE_STRUCTURE_CONSTANT (rayx)</li> <li>FIXED_SEED (rayx)</li> <li>FigureRotationToString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#g","title":"g","text":"<ul> <li>GratingMountToString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#i","title":"i","text":"<ul> <li>INV_NM_TO_EVOLT (rayx)</li> <li>IT_ASTIGMATIC2ASTIGMATIC (rayx)</li> <li>IT_POINT2HORIZONTAL_DIVERGENT_LINE (rayx)</li> <li>IT_POINT2HORIZONTAL_LINE (rayx)</li> <li>IT_POINT2POINT (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#m","title":"m","text":"<ul> <li>MaterialToString (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#n","title":"n","text":"<ul> <li>None (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#o","title":"o","text":"<ul> <li>ObjectId (rayx)</li> <li>OpticalPathLength (rayx)</li> <li>Order (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#p","title":"p","text":"<ul> <li>PI (rayx)</li> <li>PLANCK (rayx)</li> <li>PLANCK_BAR (rayx)</li> <li>ParaboloidTypeToString (rayx)</li> <li>PathEventId (rayx)</li> <li>Position (rayx)</li> <li>PositionX (rayx)</li> <li>PositionY (rayx)</li> <li>PositionZ (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#r","title":"r","text":"<ul> <li>RZPTypeToString (rayx)</li> <li>RayAttrMask (rayx)</li> <li>RayAttrMaskCount (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_variables/#s","title":"s","text":"<ul> <li>SPEED_OF_LIGHT (rayx)</li> <li>SigmaTypeToString (rayx)</li> <li>SourceDistToString (rayx)</li> <li>SourceId (rayx)</li> <li>SpreadTypeToString (rayx)</li> <li>StringToBehaviourType (rayx)</li> <li>StringToCentralBeamstop (rayx)</li> <li>StringToCurvatureType (rayx)</li> <li>StringToCutoutType (rayx)</li> <li>StringToElectronEnergyOrientation (rayx)</li> <li>StringToElementType (rayx)</li> <li>StringToEnergyDistributionType (rayx)</li> <li>StringToEnergySpreadUnit (rayx)</li> <li>StringToEventType (rayx)</li> <li>StringToFigureRotation (rayx)</li> <li>StringToGratingMount (rayx)</li> <li>StringToMaterial (rayx)</li> <li>StringToParaboloidType (rayx)</li> <li>StringToRZPType (rayx)</li> <li>StringToSigmaType (rayx)</li> <li>StringToSourceDist (rayx)</li> <li>StringToSpreadType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"rayxCore/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>Beamline (rayx)</li> <li>Behaviour (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>Coating (rayx)</li> <li>Cutout (rayx)</li> <li>cmat3 (rayx)</li> <li>cvec2 (rayx)</li> <li>cvec3 (rayx)</li> <li>Complex (rayx::complex)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>DesignObject (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>ElectricField (rayx)</li> <li>EnergyDistributionDataVariant (rayx)</li> <li>EnergyDistributionVariant (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#l","title":"l","text":"<ul> <li>LocalElectricField (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>Map (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#o","title":"o","text":"<ul> <li>OptBuf (rayx)</li> <li>OptCollisionPoint (rayx)</li> <li>OptCollisionWithElement (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>RandCounter (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>Stokes (rayx)</li> <li>Surface (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>tcomplex (rayx::complex)</li> </ul>"},{"location":"rayxCore/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>Variant (rayx::BlockSizeConstraint)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"rayxCore/namespace_member_enums/#b","title":"b","text":"<ul> <li>BehaveType (rayx)</li> <li>BehaviourType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#c","title":"c","text":"<ul> <li>CentralBeamstop (rayx)</li> <li>CurvatureType (rayx)</li> <li>CutoutType (rayx)</li> <li>CylinderDirection (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#d","title":"d","text":"<ul> <li>DesignPlane (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#e","title":"e","text":"<ul> <li>ElectronEnergyOrientation (rayx)</li> <li>ElementType (rayx)</li> <li>EnergyDistributionType (rayx)</li> <li>EnergySpreadUnit (rayx)</li> <li>EventType (rayx)</li> <li>EventTypeMask (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#f","title":"f","text":"<ul> <li>FigureRotation (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#g","title":"g","text":"<ul> <li>GratingMount (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#m","title":"m","text":"<ul> <li>Material (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#p","title":"p","text":"<ul> <li>ParaboloidType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#r","title":"r","text":"<ul> <li>RZPType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#s","title":"s","text":"<ul> <li>Sequential (rayx)</li> <li>SigmaType (rayx)</li> <li>SourceDist (rayx)</li> <li>SourcePulseType (rayx)</li> <li>SpreadType (rayx)</li> <li>SurfaceCoatingType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#t","title":"t","text":"<ul> <li>ToroidType (rayx)</li> </ul>"},{"location":"rayxCore/namespace_member_enums/#v","title":"v","text":"<ul> <li>ValueType (rayx)</li> </ul>"},{"location":"rayxCore/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"rayxCore/macros/","title":"Macros","text":""},{"location":"rayxCore/macros/#r","title":"r","text":"<ul> <li>RAYX_API (Core.h)</li> <li>RAYX_CONSTEXPR_ACC (Core.h)</li> <li>RAYX_FN_ACC (Core.h)</li> <li>RAYX_DBG (Debug.h)</li> <li>RAYX_DEBUG (Debug.h)</li> <li>RAYX_D_ERR (Debug.h)</li> <li>RAYX_D_LOG (Debug.h)</li> <li>RAYX_D_VERB (Debug.h)</li> <li>RAYX_D_WARN (Debug.h)</li> <li>RAYX_EXIT (Debug.h)</li> <li>RAYX_LOG (Debug.h)</li> <li>RAYX_VERB (Debug.h)</li> <li>RAYX_WARN (Debug.h)</li> <li>RAYX_PROFILE_FUNCTION (Instrumentor.h)</li> <li>RAYX_PROFILE_FUNCTION_STDOUT (Instrumentor.h)</li> <li>RAYX_PROFILE_SCOPE (Instrumentor.h)</li> <li>RAYX_PROFILE_SCOPE_STDOUT (Instrumentor.h)</li> <li>RAYX_X_MACRO_RAY_ATTR (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_DIRECTION_X (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_DIRECTION_Y (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_DIRECTION_Z (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_X (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Y (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_ELECTRIC_FIELD_Z (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_ENERGY (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_EVENT_TYPE (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_OBJECT_ID (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_OPTICAL_PATH_LENGTH (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_ORDER (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_PATH_EVENT_ID (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_PATH_ID (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_POSITION_X (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_POSITION_Y (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_POSITION_Z (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_RAND_COUNTER (RayAttrMask.h)</li> <li>RAYX_X_MACRO_RAY_ATTR_SOURCE_ID (RayAttrMask.h)</li> </ul>"},{"location":"rayxCore/macros/#s","title":"s","text":"<ul> <li>STRING (Debug.h)</li> </ul>"},{"location":"rayxCore/macros/#x","title":"x","text":"<ul> <li>X (StringConversion.h, Debug.h, Material.h, RaysPtr.h, GenRays.h, MegaKernelTracer.h, Util.h, RayAttrMask.h, Rays.h)</li> </ul>"},{"location":"rayxCore/macros/#_","title":"_","text":"<ul> <li>__PRETTY_FUNCTION__ (Instrumentor.h)</li> <li>_assert (Throw.h)</li> <li>_debug_assert (Throw.h)</li> <li>_debug_throw (Throw.h)</li> <li>_debug_warn (Throw.h)</li> <li>_throw (Throw.h)</li> <li>_warn (Throw.h)</li> </ul>"},{"location":"rayxCore/variables/","title":"Variables","text":""},{"location":"rayxCore/variables/#a","title":"a","text":"<ul> <li>All (DeviceConfig.h)</li> </ul>"},{"location":"rayxCore/variables/#c","title":"c","text":"<ul> <li>Cpu (DeviceConfig.h)</li> <li>CpuParallel (DeviceConfig.h)</li> <li>CpuSerial (DeviceConfig.h)</li> </ul>"},{"location":"rayxCore/variables/#g","title":"g","text":"<ul> <li>Gpu (DeviceConfig.h)</li> <li>GpuCuda (DeviceConfig.h)</li> </ul>"},{"location":"rayxCore/variables/#n","title":"n","text":"<ul> <li>None (DeviceConfig.h)</li> </ul>"},{"location":"rayxCore/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}