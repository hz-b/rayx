#define WORKGROUP_SIZE 32

#ifdef CPP
    #define INOUT(x) x&
    #define OUT(x) x&
    #define ALLOW_UNUSED [[maybe_unused]]
#else
    #define INOUT(x) inout x
    #define OUT(x) out x
    #define ALLOW_UNUSED

    #extension GL_EXT_debug_printf : enable
	#extension GL_ARB_separate_shader_objects : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	#extension GL_GOOGLE_include_directive : enable

	layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
#endif

const double PI       = 3.14159265358979323846264338327950;
const uint64_t rngKey = 13; // TODO(rudi) this was the old key, it generated a warning: (0xc8e4fd15 << 32) | 0x4ce32f6d;
const double inm2eV   = 1.239852e3;

/* STRUCTS */
// for CPP, the according things are mostly defined in CpuTracer.h
#ifdef CPP
int gl_GlobalInvocationID;

ShaderArray<Ray> rayData;
ShaderArray<Ray> outputData;
double numberOfBeamlines;
double numberOfElementsPerBeamline;
double numberOfRays;
double numberOfRaysPerBeamLine;
ShaderArray<Element> quadricData;
ShaderArray<dvec4> xyznull;
ShaderArray<int> matIdx;
ShaderArray<double> mat;

#else
struct Ray {
    dvec3 m_position;
    double m_weight;  // status of the ray (e.g if element missed -> 0)
    dvec3 m_direction;
    double m_energy;
    dvec4 m_stokes;
    double m_pathLength;
    double m_order;
    double m_lastElement;
    double m_extraParam;
};
struct Element {
    dmat4 surfaceParams;
    dmat4 inTrans;
    dmat4 outTrans;
    dmat4 objectParameters;
    dmat4 elementParameters;
};

#ifdef RAYX_DEBUG_MODE
	struct _debug_struct {
		dmat4 _dMat; // Can also be used as vectors or scalar
	};
#endif 
/* LAYOUTS */
	layout(std140, binding = 0) buffer ibuf { Ray rayData[]; }; // in global coordinates

	layout(std140, binding = 1) buffer obuf { Ray outputData[]; }; // in element coordinates, i.e. relative to the last element the ray has collided with.

	layout(std140, binding = 2) buffer qbuf {
		double numberOfBeamlines;
		double numberOfElementsPerBeamline;
		double numberOfRays;
		double numberOfRaysPerBeamLine;
		Element quadricData[];
	};

	layout(std140, binding = 3) buffer xyzbuf { dvec4 xyznull[]; };

	layout(binding = 4) buffer materialIndexBuf {
		int matIdx[]; // matIdx[0..91] contains the indices of the Palik Table, whereas matIdx[92..92+91] contains the indices of the NffTable.
					  // generally, an entry of matIdx tells you the index you need to look up in the 'mat'-table below.
	};

	layout(binding = 5) buffer materialBuf {
		double mat[];  // contains: (Palik tables of all materials concatenated together) concatenated with (Nff tables of all materials concatenated together)
					   // use the matIdx-table to determine the relevant indices for when which table starts and stops.
	};

	#ifdef RAYX_DEBUG_MODE
		layout(binding = 6) buffer debugBuf {
			_debug_struct d_struct[];  // contains nff table of all materials concatenated together
		};
	#endif
#endif

// Order in #include is IMPROTANT, do not change.
// clang-format off
#include "approx.comp"
#include "complex.comp"
#include "random.comp"
#include "utils.comp"
#include "intersection.comp"
#include "trace.comp"
// clang-format on

// @brief: Dynamic ray tracing: check which ray hits which element first
// in this function we need to make sure that rayData ALWAYS remains in GLOBAL coordinates (it can be changed in a function but needs to be changed
// back before the function returns to this function)
void dynamicElements() {
    const int numberOfElements = quadricData.length();
    // placeholder, info should later be transfered to shader
    const int maxBounces  = numberOfElements;
    Ray ray               = rayData[uint(gl_GlobalInvocationID)];
    uint beamlineIndex    = uint(double(gl_GlobalInvocationID) / numberOfRaysPerBeamLine);

    // ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random number
    uint64_t workerCounterNum = (~(uint64_t(0)) / int(numberOfRays));
    uint64_t ctr              = uint(gl_GlobalInvocationID) * workerCounterNum;
    int type                  = -1;

    int closestElementIndex = -1;
    int lastClosestElementIndex;
    dvec4 closestHitpoint = dvec4(1.0 / 0.0, 1.0 / 0.0, 1.0 / 0.0, 0.0);
    dvec4 closestGlobalHitpoint;
    
    #ifdef RAYX_DEBUG_MODE // Debug Matrix only works in GPU Mode and on DEBUG Build Type
    #ifndef CPP  
    // Set Debug Struct of current Ray to identity
    d_struct[uint(gl_GlobalInvocationID)]._dMat = dmat4(1);
    #endif
    #endif

    Element nextElement;
    // at the end of this function we apply inTrans, if no collision happened (i.e. nextElement undefined), we want this to do nothing.
    nextElement.inTrans = dmat4(1);
    nextElement.outTrans = dmat4(1);

    double bounce = 1;

    // Printing Example over vkconfig Validation Layers
    if (uint(gl_GlobalInvocationID) == 2 ){
    #ifndef CPP
        debugPrintfEXT("Hello from GPU. \n"); 
    #else
        RAYX_D_LOG << "Tracing on CPU..." ; 
    #endif
    }
    // Iterate through all bounces
    for (int i = 0; i < maxBounces; i++) {
        ray = rayData[uint(gl_GlobalInvocationID)];

        lastClosestElementIndex = closestElementIndex;

        // index of element with current closest intersection with ray, initialized with -1
        closestElementIndex = -1;

        // global coordinates of first intersection point of ray among all elements in beamline
        closestHitpoint       = dvec4(1.0 / 0.0, 1.0 / 0.0, 1.0 / 0.0, 0);
        closestGlobalHitpoint = dvec4(1.0 / 0.0, 1.0 / 0.0, 1.0 / 0.0, 0);

        // Find intersection points through all elements
        for (int elementIndex = int(beamlineIndex) * int(numberOfElementsPerBeamline);
             elementIndex < (beamlineIndex + 1) * numberOfElementsPerBeamline; elementIndex++) {
            if (elementIndex == lastClosestElementIndex) {
                // TODO: self-intersection
                // rayData[uint(gl_GlobalInvocationID)].m_weight = 11;
                continue;
            }

            dvec4 currentIntersection = getOpticalElementIntersection(ray, elementIndex);
            dvec3 currentIntersection_xyz = dvec3(currentIntersection.x, currentIntersection.y, currentIntersection.z);

            // Intersection coordinates in GLOBAL coordinates
            dvec4 currentGlobalIntersection;
            dvec3 tmp = dvec3(quadricData[elementIndex].outTrans * dvec4(currentIntersection_xyz, 1));
            currentGlobalIntersection = dvec4(tmp, currentGlobalIntersection.w);
            dvec3 currentGlobalIntersection_xyz = dvec3(currentGlobalIntersection.x, currentGlobalIntersection.y, currentGlobalIntersection.z);

            dvec3 closestGlobalHitpoint_xyz = dvec3(closestGlobalHitpoint.x, closestGlobalHitpoint.y, closestGlobalHitpoint.z);
            // check if current intersection is closer than the closest previous Hitpoint
            // If yes then update. Since the old intersection is occluded by the old Intersection/Hit point
            if (length(ray.m_position - closestGlobalHitpoint_xyz) > length(ray.m_position - currentGlobalIntersection_xyz) &&
                currentIntersection.w != 0) {
                closestHitpoint       = currentIntersection;
                closestGlobalHitpoint = currentGlobalIntersection;
                closestElementIndex   = elementIndex;
            }
        }

        if (closestElementIndex == -1) {  // no element was hit. Ray is considered to move forward to inf. (With weight == 0)
            break;
        }

        // transform ray and intersection point in ELEMENT coordiantes
        nextElement                          = quadricData[closestElementIndex];
        rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], nextElement.inTrans);

        // Calculate interaction(reflection,material, absorption etc.) of ray with detected next element
        type = int(nextElement.surfaceParams[3][0]);
        if (type == 0) {  // plane + sphere mirror
            rayData[uint(gl_GlobalInvocationID)] = traceMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 1) {  // plane grating
            rayData[uint(gl_GlobalInvocationID)] = tracePlaneGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 2) {  // general grating
            rayData[uint(gl_GlobalInvocationID)] =
                traceGeneralGrating(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 3) {  // Slit
            rayData[uint(gl_GlobalInvocationID)] = traceSlit(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 4) {  // rzp
            rayData[uint(gl_GlobalInvocationID)] = traceRZP(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 5) {  // image plane
            rayData[uint(gl_GlobalInvocationID)].m_extraParam += (closestElementIndex + 1) * bounce;
            rayData[uint(gl_GlobalInvocationID)].m_lastElement = closestElementIndex + 1;
            outputData[uint(gl_GlobalInvocationID)] = traceImagePlane(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, closestHitpoint);
            return;

        } else if (type == 6) {  // toroid mirror
            rayData[uint(gl_GlobalInvocationID)] = traceToroid(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);

        } else if (type == 7) {  // ellipsoid mirror
            rayData[uint(gl_GlobalInvocationID)] =
                traceEllipsoidMirror(rayData[uint(gl_GlobalInvocationID)], closestElementIndex, ctr, closestHitpoint);
        }

        // use extraParameter to store the order in which the ray has hit which optical element (e.g extraParameter = 412 -> first hit element 2, then
        // 1, then 4)
        rayData[uint(gl_GlobalInvocationID)].m_extraParam +=
            ((closestElementIndex + 1) * bounce) * int(rayData[uint(gl_GlobalInvocationID)].m_lastElement == closestElementIndex + 1);
        bounce *= pow(10, int(rayData[uint(gl_GlobalInvocationID)].m_lastElement == closestElementIndex + 1));

        // transform back to WORLD coordinates
        rayData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], nextElement.outTrans);
    }

    // outputData should be in element coordinates.
    outputData[uint(gl_GlobalInvocationID)] = rayMatrixMult(rayData[uint(gl_GlobalInvocationID)], nextElement.inTrans);
}

void main() {
	dynamicElements();

    // output = input:
    // outputData[uint(gl_GlobalInvocationID)] = rayData[uint(gl_GlobalInvocationID)];
}
