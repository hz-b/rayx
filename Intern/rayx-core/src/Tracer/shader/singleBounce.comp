/**************************************************************
 *                    MAIN
 **************************************************************/

// @brief: Dynamic ray tracing: check which ray hits which element first. **This happens for only bounce**
// in this function we need to make sure that rayData ALWAYS remains in GLOBAL coordinates (it can be changed in a function but needs to be changed
// back before the function returns to this function)
#ifdef GLSL
void main() {
#else
void singleBounce_main() { // CPU Callback
#endif
    _ray.m_eventType = ETYPE_UNINIT;
    _ray.m_padding = 0.0;

    if (_rayMeta.finalized) {
        return;  // Ray is done, no need to trace
    }

    // Transform Ray back into world coordinates if coming from previous intersection
    if (_rayMeta.nextElementId != -1) {
        rayMatrixMult_InP(_ray, _ray, elements[_rayMeta.nextElementId].m_outTrans);
    }

    Collision col = findCollision();

    if (!col.found) {
        // no element was hit.
        // Ray is considered to move forward to inf.
        // This is the only constellation in which a snapshot is in world coordinates.
        recordFinalEvent(_ray, ETYPE_FLY_OFF);
        // Store collision ID as None (-1)
        _rayMeta.nextElementId = -1;
        return;
    } else {
        // Store collision ID
        _rayMeta.nextElementId = col.elementIndex;
    }

    // transform ray and intersection point in ELEMENT coordiantes
    Element nextElement = elements[col.elementIndex];
    Ray elem_ray = rayMatrixMult(_ray, nextElement.m_inTrans);

    // Calculate interaction(reflection, material, absorption etc.) of ray with detected next element
    int btype = int(nextElement.m_behaviour.m_type);
    uint64_t ctr = _rayMeta.ctr;

    elem_ray.m_pathLength += length(elem_ray.m_position - col.hitpoint);
    elem_ray.m_position = col.hitpoint;
    elem_ray.m_lastElement = col.elementIndex;  // TODO remove this "+1", element ids should consistently start at 0.

    switch (btype) {
        case (BTYPE_MIRROR):
            elem_ray = behaveMirror(elem_ray, col.elementIndex, ctr, col);
            break;
        case (BTYPE_GRATING):
            elem_ray = behaveGrating(elem_ray, col.elementIndex, ctr, col);
            break;
        case (BTYPE_SLIT):
            elem_ray = behaveSlit(elem_ray, col.elementIndex, ctr, col);
            break;
        case (BTYPE_RZP):
            elem_ray = behaveRZP(elem_ray, col.elementIndex, ctr, col);
            break;
        case (BTYPE_IMAGE_PLANE):
            elem_ray = behaveImagePlane(elem_ray, col.elementIndex, col);
            break;
    }

    // the ray might finalize due to being absorbed, or because an error occured while tracing!
    if (_rayMeta.finalized) {
        return;
    }

    recordEvent(elem_ray, ETYPE_JUST_HIT_ELEM);
}