/* COMPLEX NUMBERS */
// make a struct for complex numbers or just use vec2?

// Complex Number math by julesb (but adapted for float precision)
// https://github.com/julesb/glsl-util

#define cx_mul(a, b) vec2(a.x* b.x - a.y * b.y, a.x * b.y + a.y * b.x)
#define cx_div(a, b) vec2(((a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y)), ((a.y * b.x - a.x * b.y) / (b.x * b.x + b.y * b.y)))
#define cx_modulus(a) length(a)
#define cx_conj(a) vec2(a.x, -a.y)
#define cx_arg(a) atan(float(a.y, a.x))
#define cx_sin(a) vec2(sin(float(a.x)) * cosh(float(a.y)), cos(float(a.x)) * sinh(float(a.y)))
#define cx_cos(a) vec2(cos(float((a.x))) * cosh(float(a.y)), -sin(float(a.x)) * sinh(float(a.y)))

vec2 cx_sqrt(vec2 a) {
    float r = length(a);
    float rpart = sqrt(0.5 * (r + a.x));
    float ipart = sqrt(0.5 * (r - a.x));
    if (a.y < 0.0) ipart = -ipart;
    return vec2(rpart, ipart);
}

vec2 cx_tan(vec2 a) { return cx_div(cx_sin(a), cx_cos(a)); }

vec2 cx_log(vec2 a) {
    float rpart = sqrt((a.x * a.x) + (a.y * a.y));
    float ipart = r8_atan2(a.y, a.x);
    if (ipart > PI) ipart = ipart - (2.0 * PI);
    return vec2(log(float(rpart)), ipart);
}

vec2 cx_mobius(vec2 a) {
    vec2 c1 = a - vec2(1.0, 0.0);
    vec2 c2 = a + vec2(1.0, 0.0);
    return cx_div(c1, c2);
}

vec2 cx_z_plus_one_over_z(vec2 a) { return a + cx_div(vec2(1.0, 0.0), a); }

vec2 cx_z_squared_plus_c(vec2 z, vec2 c) { return cx_mul(z, z) + c; }

vec2 cx_sin_of_one_over_z(vec2 z) { return cx_sin(cx_div(vec2(1.0, 0.0), z)); }

// Additions by Johan Karlsson (DonKarlssonSan) https://gist.github.com/DonKarlssonSan
// https://gist.github.com/DonKarlssonSan/f87ba5e4e5f1093cb83e39024a6a5e72
#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)
#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)
#define cx_abs(a) length(a)
vec2 cx_to_polar(vec2 a) {
    float phi = atan(float(a.y / a.x));
    float r = length(a);
    return vec2(r, phi);
}

// Complex power
vec2 cx_pow(vec2 a, int n) {
    float angle = r8_atan2(a.y, a.x);
    float r = length(a);
    float real = pow(float(r), float(n)) * cos(float(n * angle));
    float im = pow(float(r), float(n)) * sin(float(n * angle));
    return vec2(real, im);
}
