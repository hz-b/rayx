#define WORKGROUP_SIZE 8
/**************************************************************
 *                    Header & #define
 **************************************************************/
#ifdef GLSL
    #extension GL_EXT_debug_printf : enable
	#extension GL_ARB_separate_shader_objects : enable
	#extension GL_ARB_gpu_shader_int64 : enable
	#extension GL_GOOGLE_include_directive : enable
	layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
#endif

// Every shader execution calculates the route for a single ray.
// `_ray` is that ray, it's always in world coordinates (!).
#define _ray (rayData[uint(gl_GlobalInvocationID)])

#include "../../Shared/adapt.h"
#include "../../Shared/Constants.h"
#include "../../Shared/Ray.h"
#include "../../Shared/Element.h"

/**************************************************************
 *                    SHADER ARRAYS
 **************************************************************/

// don't use this directly. Use `_ray` instead.
SHADER_ARRAY(Ray, rayData, 0, ibuf);

// don't use this directly. Use `recordEvent` instead.
SHADER_ARRAY(Ray, outputData, 1, obuf);

// std430 is required so that Element is layouted like in C++.
// see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL) for more details on layouting.
SHADER_ARRAY(Element, elements, 2, qbuf);

// TODO unused!
SHADER_ARRAY(dvec4, xyznull, 3, xyzbuf);

// matIdx[0..91] contains the indices of the Palik Table, whereas matIdx[92..92+91] contains the indices of the NffTable.
// generally, an entry of matIdx tells you the index you need to look up in the 'mat'-table below.
SHADER_ARRAY(int, matIdx, 4, materialIndexBuf);

// contains: (Palik tables of all materials concatenated together) concatenated with (Nff tables of all materials concatenated together)
// use the matIdx-table to determine the relevant indices for when which table starts and stops.
SHADER_ARRAY(double, mat, 5, materialBuf);


#ifdef RAYX_DEBUG_MODE
struct _debug_struct {
    dmat4 _dMat; // Can also be used as vectors or scalar
};

SHADER_ARRAY(_debug_struct, d_struct, 6, debugBuf);
#endif

#ifndef GLSL
int gl_GlobalInvocationID;
#endif

/**************************************************************
 *                    PushConstants
 **************************************************************/
#ifndef GLSL
    PushConstants pushConstants;
#else 
    layout( push_constant ) uniform constants
    {   
        double rayIdStart;
        double numRays;
        double randomSeed;
        double maxEvents;
        double sequential; // sequential tracing only.
    } pushConstants;
#endif

/**************************************************************
 *                    Functions && vars
 **************************************************************/

uint64_t rayId() {
    return uint64_t(pushConstants.rayIdStart) + uint64_t(gl_GlobalInvocationID);
}

bool finalized;

// the random number state.
uint64_t ctr;

// `i in [0, maxEvents]`.
// Will return the index in outputData to access the `i'th` output ray belonging to this shader call.
// Typically used as `outputData[output_index(i)]`.
uint output_index(uint i) {
    return uint(gl_GlobalInvocationID) * uint(pushConstants.maxEvents) + i;
}

// sets all output rays controlled by this shader call to ETYPE_UNINIT.
void uninitOutRays() {
    for (uint i = 0; i < pushConstants.maxEvents; i++) {
        outputData[output_index(i)].m_eventType = ETYPE_UNINIT;
    }
}

// record an event and store it in the next free spot in outputData.
// `r` will typically be _ray, or some related ray.
void recordEvent(Ray r, double w) {
    if (finalized) { return; }

    if (w == ETYPE_UNINIT) {
        #ifndef GLSL
        RAYX_ERR << "recordEvent failed: no free spots!";
        #endif
    }

    for (uint i = 0; i < pushConstants.maxEvents; i++) {
        uint idx = output_index(i);
        if (outputData[idx].m_eventType == ETYPE_UNINIT) { // checks whether this spot is free
            outputData[idx] = r;
            outputData[idx].m_eventType = w;
            return;
        }
    }

    // no spots were found.
    // this shouldn't be using `throw`, as otherwise we might end up in infinite recursion.
    #ifndef GLSL
    RAYX_WARN << "recordEvent failed: no free spots!";
    #endif
}

// Like `recordEvent` above, but it will prevent recording more events after this.
// Is used for events terminating the path of the ray.
void recordFinalEvent(Ray r, double w) {
    recordEvent(r, w);
    finalized = true;
}

// throws an error, and termiantes the program
#ifdef GLSL
#define throw(string) recordFinalEvent(_ray, ETYPE_FATAL_ERROR)
#else
#define throw(string) RAYX_ERR << string
#endif

/**************************************************************
 *                    Shader INCLUDEs
 **************************************************************/

// Order in #include is IMPROTANT, do not change.
// clang-format off
#include "approx.comp"
#include "complex.comp"
#include "random.comp"
#include "utils.comp"
#include "collision.comp"
#include "behave.comp"
#include "dynamic_elements.comp"
// clang-format on

/**************************************************************
 *                    MAIN
 **************************************************************/
void main() {
    finalized = false;
    uninitOutRays();

    // ray specific "seed" for random numbers -> every ray has a different starting value for the counter that creates the random number
    const uint64_t MAX_UINT64 = ~(uint64_t(0));
    uint64_t workerCounterNum = MAX_UINT64 / uint64_t(pushConstants.numRays);
    ctr = rayId() * workerCounterNum + uint64_t(pushConstants.randomSeed * MAX_UINT64);
    
    // ~~~~~~~~~~~~~~ PRINT EXAMPLE ~~~~~~~~~~~~~~
    // Printing ~DEBUG~ Example over vkconfig Validation Layers
    // if (uint(gl_GlobalInvocationID) == 2 ){
    // #ifdef GLSL
    //     // debugPrintfEXT("Hello from GPU. \n");
    // #else
    //     // RAYX_D_LOG << "Tracing on CPU..." ;
    //     // RAYX_D_LOG << pushConstants.pushMatrix[0][0];
    // #endif
    // }
    // ~~~~~~~~~~~~~~ PRINT EXAMPLE ~~~~~~~~~~~~~~
	dynamicElements();
}
