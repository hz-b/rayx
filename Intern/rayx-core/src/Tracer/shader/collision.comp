#define COLLISION_EPSILON 1e-10

// A "ray-element" collision.

/**************************************************************
 *                    Cllision Struct
 **************************************************************/
struct Collision {
    // The point where `_ray` hits the element, in element-coordinates.
    vec3 hitpoint;

    // The normal of the surface at the hitpoint in element-coordinates.
    vec3 normal;

    // The index of the element with which `_ray` collides.
    int elementIndex;

    // whether a collision has been found.
    bool found;
};

/**************************************************************
 *                    Quadric collision
 **************************************************************/
Collision getQuadricCollision(Ray r, uint id) {
    Collision col;
    col.found = true;
    col.elementIndex = int(id);
    col.hitpoint = vec3(0, 0, 0);
    col.normal = vec3(0, 0, 0);

    QuadricSurface q = deserializeQuadric(elements[id].m_surface);
    int cs     = 1;
    int d_sign = q.m_icurv;
    if (abs(r.m_direction[1]) >= abs(r.m_direction[0]) && abs(r.m_direction[1]) >= abs(r.m_direction[2])) {
        cs = 2;
    } else if (abs(r.m_direction[2]) >= abs(r.m_direction[0]) && abs(r.m_direction[2]) >= abs(r.m_direction[1])) {
        cs = 3;
    }

    float x = 0;
    float y = 0;
    float z = 0;
    float a = 0;
    float b = 0;
    float c = 0;

    if (cs == 1) {
        float aml = r.m_direction[1] / r.m_direction[0];
        float anl = r.m_direction[2] / r.m_direction[0];
        y          = r.m_position[1] - aml * r.m_position[0];
        z          = r.m_position[2] - anl * r.m_position[0];
        d_sign     = int(sign(r.m_direction[0]) * q.m_icurv);

        a = q.m_a11 + 2 * q.m_a12 * aml + q.m_a22 * aml * aml + 2 * q.m_a13 * anl + 2 * q.m_a23 * aml * anl + q.m_a33 * anl * anl;
        b = q.m_a14 + q.m_a24 * aml + q.m_a34 * anl + (q.m_a12 + q.m_a22 * aml + q.m_a23 * anl) * y + (q.m_a13 + q.m_a23 * aml + q.m_a33 * anl) * z;
        c = q.m_a44 + q.m_a22 * y * y + 2 * q.m_a34 * z + q.m_a33 * z * z + 2 * y * (q.m_a24 + q.m_a23 * z);

        float bbac = b * b - a * c;
        if (bbac < 0) {
            col.found = false;
        } else {
            if (abs(a) > abs(c) * 1e-10) {
                x = (-b + d_sign * sqrt(bbac)) / a;
            } else {
                x = (-c / 2) / b;
            }
        }
        y = y + aml * x;
        z = z + anl * x;
    } else if (cs == 2) {
        float alm = r.m_direction[0] / r.m_direction[1];
        float anm = r.m_direction[2] / r.m_direction[1];
        x          = r.m_position[0] - alm * r.m_position[1];
        z          = r.m_position[2] - anm * r.m_position[1];
        d_sign     = int(sign(r.m_direction[1]) * q.m_icurv);

        a = q.m_a22 + 2 * q.m_a12 * alm + q.m_a11 * alm * alm + 2 * q.m_a23 * anm + 2 * q.m_a13 * alm * anm + q.m_a33 * anm * anm;
        b = q.m_a24 + q.m_a14 * alm + q.m_a34 * anm + (q.m_a12 + q.m_a11 * alm + q.m_a13 * anm) * x + (q.m_a23 + q.m_a13 * alm + q.m_a33 * anm) * z;
        c = q.m_a44 + q.m_a11 * x * x + 2 * q.m_a34 * z + q.m_a33 * z * z + 2 * x * (q.m_a14 + q.m_a13 * z);

        float bbac = b * b - a * c;
        if (bbac < 0) {
            col.found = false;
        } else {
            if (abs(a) > abs(c) * 1e-10) {
                y = (-b + d_sign * sqrt(bbac)) / a;
            } else {
                y = (-c / 2) / b;
            }
        }
        x = x + alm * y;
        z = z + anm * y;

    } else {
        float aln = r.m_direction[0] / r.m_direction[2];
        float amn = r.m_direction[1] / r.m_direction[2];
        // firstParam = aln;
        // secondParam = amn;
        x      = r.m_position[0] - aln * r.m_position[2];
        y      = r.m_position[1] - amn * r.m_position[2];
        d_sign = int(sign(r.m_direction[2]) * q.m_icurv);

        a = q.m_a33 + 2 * q.m_a13 * aln + q.m_a11 * aln * aln + 2 * q.m_a23 * amn + 2 * q.m_a12 * aln * amn + q.m_a22 * amn * amn;
        b = q.m_a34 + q.m_a14 * aln + q.m_a24 * amn + (q.m_a13 + q.m_a11 * aln + q.m_a12 * amn) * x + (q.m_a23 + q.m_a12 * aln + q.m_a22 * amn) * y;
        c = q.m_a44 + q.m_a11 * x * x + 2 * q.m_a24 * y + q.m_a22 * y * y + 2 * x * (q.m_a14 + q.m_a12 * y);

        float bbac = b * b - a * c;
        if (bbac < 0) {
            col.found = false;
        } else {
            if (abs(a) > abs(c) * 1e-10) {  // pow(10, float(-10))) {
                z = (-b + d_sign * sqrt(bbac)) / a;
            } else {
                z = (-c / 2) / b;
            }
        }
        x = x + aln * z;
        y = y + amn * z;
        // r.m_position = vec3(a, b, c);
    }

    // intersection point is in the negative direction (behind the position when the direction is followed forwards), set weight to 0
    if ((x - r.m_position.x) / r.m_direction.x < 0 || (y - r.m_position.y) / r.m_direction.y < 0 || (z - r.m_position.z) / r.m_direction.z < 0) {
        col.found = false;
    }

    col.hitpoint = vec3(x, y, z);

    float fx = 2 * q.m_a14 + 2 * q.m_a11 * x + 2 * q.m_a12 * y + 2 * q.m_a13 * z;
    float fy = 2 * q.m_a24 + 2 * q.m_a12 * x + 2 * q.m_a22 * y + 2 * q.m_a23 * z;
    float fz = 2 * q.m_a34 + 2 * q.m_a13 * x + 2 * q.m_a23 * y + 2 * q.m_a33 * z;
    col.normal = normalize(vec3(fx, fy, fz));
    return col;
}

/**************************************************************
 *                    Toroid Collision
 **************************************************************/
// this uses newton to approximate a solution.
Collision getToroidCollision(Ray r, uint id) {
    ToroidSurface toroid = deserializeToroid(elements[id].m_surface);
    float longRad = toroid.m_longRadius;
    float shortRad = toroid.m_shortRadius;

    if (toroid.m_toroidType == TOROID_TYPE_CONVEX) {
        shortRad *= -1.0;
    }

    Collision col;
    col.found = true;
    col.elementIndex = int(id);
    col.hitpoint = vec3(0, 0, 0);
    col.normal = vec3(0, 0, 0);

    float isigro = sign(shortRad);
    // sign radius: +1 = concave, -1 = convex

    int n = 0;
    // float aln = r.m_direction.x / r.m_direction.z;
    // float amn = r.m_direction.y / r.m_direction.z;

    vec4 normal = vec4(0, 0, 0, 0);
    float xx = 0.0;
    float zz = 0.0;
    float yy = 0.0;
    float dz = 0.0;
    vec3 normalized_dir = vec3(r.m_direction) / r.m_direction.z;

    // while not converted
    do {
        zz = zz + dz;
        xx = r.m_position.x + normalized_dir.x * (zz - r.m_position.z);
        if (xx * xx > shortRad * shortRad) {
            xx = xx / abs(xx) * 0.95 * shortRad;
        }
        yy        = r.m_position.y + normalized_dir.y * (zz - r.m_position.z);
        float sq = sqrt(shortRad * shortRad - xx * xx);
        float rx = (longRad - shortRad + isigro * sq);

        normal.x = (-2 * xx * isigro / sq) * rx;
        normal.y = -2 * (yy - longRad);
        normal.z = -2 * zz;

        float func = -rx * rx + (yy - longRad) * (yy - longRad) + zz * zz;
        float df   = normalized_dir.x * normal.x + normalized_dir.y * normal.y + normal.z;  // dot(normalized_dir, vec3(normal));
        dz          = func / df;
        n += 1;
        if (n >= 50) {
            col.found = false;
            return col;
        }
    } while (abs(dz) > 0.0001);

    col.normal = normalize(vec3(normal));
    col.hitpoint = vec3(xx, yy, zz);

    vec3 rayToHitpoint = col.hitpoint - r.m_position;

    // edit: if ray points away from the hitpoint, no collision can be found.
    // Note that multiplying the rays direction with -1 SHOULD totally have an effect on the collision detection - in most cases this 180Â° rotation will make the ray point away from the toroid, and hence preventing a Collision completely.
    // The above code however, is unaffected when multiplying the ray direction with -1.
    // Due to it having no effect on `vec3 normalized_dir = vec3(r.m_direction) / r.m_direction.z;`
    if (dot(rayToHitpoint, r.m_direction) > 0.0) {
        col.found = false;
    }

    return col;
}

/**************************************************************
 *                    Collision Finder
 **************************************************************/

// Most surfaceTypes lie in the XZ plane, but some of them lie in the XY plane.
// This function projects a point into the corresponding plane.
//
// The cutout is applied in the primary plane.
vec2 projectToPlane(PlaneDir plane, vec3 point) {
    if (plane == PLANE_XY) {
        return vec2(point.x, point.y);
    } else if (plane == PLANE_XZ) {
        return vec2(point.x, point.z);
    } else {
        throw("invalid PlaneDir!");
        return vec2(0.0, 0.0);
    }
}

// checks whether `r` collides with the element of the given `id`,
// and returns a Collision accordingly.
Collision findCollisionWith(Ray r, uint id) {
    float sty = elements[id].m_surface.m_type;

    // misalignment
    r = rayMatrixMult(r, elements[id].m_inTrans);  // image plane is the x-y plane of the coordinate system

    Collision col;
    if (sty == STYPE_PLANE_XY) {
        col.found = false;
        col.elementIndex = int(id);
        col.normal = vec3(0, 0, -1);
        float offset = abs(r.m_position.z / r.m_direction.z);

        // scale x-slope of ray (l/n) by z-length between origin and image plane
        col.hitpoint.x = r.m_position.x + r.m_direction.x * offset;
        col.hitpoint.y = r.m_position.y + r.m_direction.y * offset;
        col.hitpoint.z = 0;
        // the ray should not face away from the image plane. If that is the case, set the weight of the intersection to 0 so that it is not
        // considered in the tracing process also the image plane detects only rays from one side

        col.found = r.m_direction.z > 0 && r.m_position.z < 0;
        // backward hits are excluded? i.e. if a ray with negative direction and positive z coordinate hits the plane?
    } else if (sty == STYPE_TOROID) {
        col = getToroidCollision(r, id);
    } else if (sty == STYPE_QUADRIC) {
        col = getQuadricCollision(r, id);
    } else {
        col.found = false;
        col.elementIndex = int(id);

        throw("invalid surfaceType!");
        return col; // has found = false
    }

    vec2 x1x2 = projectToPlane(getPlaneDir(sty), col.hitpoint);

    float x1 = x1x2.x;
    float x2 = x1x2.y;

    if (!inCutout(elements[id].m_cutout, x1, x2)) {
        col.found = false;
    }

    // Both r.m_direction and col.normal are in element-coordinates.
    // The collision normal should point "out of the surface", i.e. in the direction that the ray came from.
    // In other words we want `dot(r.m_direction, col.normal) <= 0`.
    // Later on, we'd like to remove this hotfix, and each individual get*Collision function should already satisfy this constraint.
    if (dot(r.m_direction, col.normal) > 0.0) {
        col.normal = col.normal * -1.0;
    }

    return col;
}

// Returns the next collision for the ray `_ray`.
Collision findCollision() {
    if (pushConstants.sequential == 1.0) {
        if (_ray.m_lastElement >= elements.length()-1) {
            Collision col;
            col.found = false;
            return col;
        }
        return findCollisionWith(_ray, uint(_ray.m_lastElement+1));
    }

    // global coordinates of first intersection point of ray among all elements in beamline
    Collision best_col;
    best_col.found = false;

    // the distance the ray has to travel to reach `best_col`.
    float best_dist = infinity();

    // move ray slightly forward.
    // -> prevents hitting an element very close to the previous collision.
    // -> prevents self-intersection.
    Ray r = _ray;
    r.m_position += r.m_direction * COLLISION_EPSILON;

    // Find intersection points through all elements
    for (uint elementIndex = 0; elementIndex < uint(elements.length()); elementIndex++) {
        Collision current_col = findCollisionWith(r, elementIndex);
        if (!current_col.found) {
            continue;
        }

        vec3 global_hitpoint = vec3(elements[elementIndex].m_outTrans * vec4(current_col.hitpoint, 1));
        float current_dist = length(global_hitpoint - _ray.m_position);

        if (current_dist < best_dist) {
            best_col = current_col;
            best_dist = current_dist;
        }
    }

    return best_col;
}
