#pragma once

#include <cmath>
#include <cstring>

#include "Beamline/Beamline.h"
#include "DeviceTracer.h"
#include "Gather.h"
#include "Material/Material.h"
#include "RAY-Core.h"
#include "Random.h"
#include "Scan.h"
#include "Shader/DynamicElements.h"
#include "Util.h"

namespace RAYX {

namespace MegaKernelTracer {

// resources per program execution. constant per program execution. required for tracing
template <typename Acc>
struct ConstantResources {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;

    alpaka::Buf<Acc, int, Dim, Idx> d_materialIndices;
    alpaka::Buf<Acc, double, Dim, Idx> d_materialTable;
};

template <typename Acc, typename Queue>
BeamlineResources<Acc> createConstantResources(Queue q, const Group& group) {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;
    using Vec = alpaka::Vec<Dim, Idx>;

    const auto materialTables = group.calcMinimalMaterialTables();
    const auto& materialIndices = materialTables.indexTable;
    const auto& materialTable = materialTables.materialTable;

    auto d_materialIndices = alpaka::allocAsyncBufIfSupported<int, Idx>(q, Vec{materialIndices.size()});
    auto d_materialTable = alpaka::allocAsyncBufIfSupported<double, Idx>(q, Vec{materialTable.size()});

    const auto hostPlatform = alpaka::PlatformCpu{};
    const auto host = alpaka::getDevByIdx(hostPlatform, 0);

    alpaka::memcpy(q, d_materialIndices, alpaka::createView(host, materialIndices, Vec{materialIndices.size()}));
    alpaka::memcpy(q, d_materialTable, alpaka::createView(host, materialTable, Vec{materialTable.size()}));

    return {
        .d_materialIndices = d_materialIndices,
        .d_materialTable = d_materialTable,
    };
}

// resources per beamline. constant per beamline. required for tracing
template <typename Acc>
struct BeamlineResources {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;

    // beamline elements
    alpaka::Buf<Acc, OpticalElement, Dim, Idx> d_elements;
};

template <typename Acc, typename Queue>
BeamlineResources<Acc> createBeamlineResources(Queue q, const Group& group) {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;
    using Vec = alpaka::Vec<Dim, Idx>;

    const auto elements = group.compileElements();

    auto d_elements = alpaka::allocAsyncBufIfSupported<OpticalElement, Idx>(q, Vec{elements.size()});

    const auto hostPlatform = alpaka::PlatformCpu{};
    const auto host = alpaka::getDevByIdx(hostPlatform, 0);

    alpaka::memcpy(q, d_elements, alpaka::createView(host, elements, Vec{elements.size()}));

    return {
        .d_elements = d_elements,
    };
}

// resources per batch. constant per batch. required for tracing
template <typename Acc>
struct BatchInputResources {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;

    // input ray data. generated by light sources
    alpaka::Buf<Acc, Ray, Dim, Idx> d_rays;
};

template <typename Acc, typename Queue>
BeamlineResources<Acc> createBatchInputResources(Queue q, const Group& group) {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;
    using Vec = alpaka::Vec<Dim, Idx>;

    const auto elements = group.compileElements();

    auto d_elements = alpaka::allocAsyncBufIfSupported<OpticalElement, Idx>(q, Vec{elements.size()});

    const auto hostPlatform = alpaka::PlatformCpu{};
    const auto host = alpaka::getDevByIdx(hostPlatform, 0);

    alpaka::memcpy(q, d_elements, alpaka::createView(host, elements, Vec{elements.size()}));

    return {
        .d_elements = d_elements,
    };
}

// output events per tracing. required if 'events' is enabled in output config
template <typename Acc>
struct OutputEventsResources {
    using Dim = alpaka::Dim<Acc>;
    using Idx = alpaka::Idx<Acc>;

    // device side events buffer for compaction
    alpaka::Buf<Acc, Ray, Dim, Idx> d_rays;
};

template <typename Acc>
struct Resources {
    ConstantResources<Acc> constant;
    BeamlineResources<Acc> beamline;
    BatchInputResources<Acc> batchInput;
    BatchOutputEventsResources<Acc> batchOutputEvents;
};

struct TraceConfig {
    int maxEvents;
    Sequential sequential;
};

struct TraceOutputConfig {
    bool events;
};

struct TraceOutput {
    std::optional<BundleHistory> outputEvents;
}

// this class interfaces the mega kernel tracer implementation
// it takes care of creating, destroying and updating device resources
class MegaKernelTracer : public DeviceTracer {
public:

    virtual TraceOutput trace(
        const Beamline& beamline,
        const TraceConfig traceConfig,
        const TraceOutputConfig traceOutputConfig
    ) override {
        
    }

private:
    std::optional<Resources> m_resources;
};

template <typename Acc>
TraceOutput trace(Resources<Acc>& resources, int maxEvents, Sequential sequential, bool outputEvents) {

}

}  // namespace MegaKernelTracer

}  // namespace RAYX
