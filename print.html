<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RAYX Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">README</a></li><li class="chapter-item "><a href="Introduction/01-Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Introduction/02-How-to-build.html"><strong aria-hidden="true">1.1.</strong> How to Build</a></li><li class="chapter-item "><a href="Introduction/02-How-to-install.html"><strong aria-hidden="true">1.2.</strong> How to Install</a></li><li class="chapter-item "><a href="Introduction/03-Getting-Started.html"><strong aria-hidden="true">1.3.</strong> Getting Started</a></li><li class="chapter-item "><a href="Introduction/04-How-to-use-rayx-ui.html"><strong aria-hidden="true">1.4.</strong> How to use RAYX-UI</a></li><li class="chapter-item "><a href="Introduction/05-How-to-use-rayx.html"><strong aria-hidden="true">1.5.</strong> RAYX Commands</a></li><li class="chapter-item "><a href="Introduction/06-Literature.html"><strong aria-hidden="true">1.6.</strong> Literature</a></li><li class="chapter-item "><a href="Introduction/07-Style-Guide.html"><strong aria-hidden="true">1.7.</strong> Style Guide</a></li></ol></li><li class="chapter-item "><a href="Model/Model.html"><strong aria-hidden="true">2.</strong> Model</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Model/BeamlineObjects/BeamlineObjects.html"><strong aria-hidden="true">2.1.</strong> Beamline Objects</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/OpticalElements.html"><strong aria-hidden="true">2.1.1.</strong> Optical Elements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Cone-Mirror.html"><strong aria-hidden="true">2.1.1.1.</strong> Cone Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Crystal.html"><strong aria-hidden="true">2.1.1.2.</strong> Crystal</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Cylinder-Mirror.html"><strong aria-hidden="true">2.1.1.3.</strong> Cylinder Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Ellipsoid-Mirror.html"><strong aria-hidden="true">2.1.1.4.</strong> Ellipsoid Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Foil.html"><strong aria-hidden="true">2.1.1.5.</strong> Foil</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Image-Plane.html"><strong aria-hidden="true">2.1.1.6.</strong> Image Plane</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Paraboloid-Mirror.html"><strong aria-hidden="true">2.1.1.7.</strong> Paraboloid Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Plane-Mirror.html"><strong aria-hidden="true">2.1.1.8.</strong> Plane Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Plane-Grating.html"><strong aria-hidden="true">2.1.1.9.</strong> Plane Grating</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Sphere-Mirror.html"><strong aria-hidden="true">2.1.1.10.</strong> Sphere Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Sphere-Grating.html"><strong aria-hidden="true">2.1.1.11.</strong> Sphere Grating</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Slit.html"><strong aria-hidden="true">2.1.1.12.</strong> Slit</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Toroid-Mirror.html"><strong aria-hidden="true">2.1.1.13.</strong> Toroid Mirror</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/Toroid-Grating.html"><strong aria-hidden="true">2.1.1.14.</strong> Toroid Grating</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/OpticalElements/RZP.html"><strong aria-hidden="true">2.1.1.15.</strong> Reflection Zone Plate (RZP)</a></li></ol></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/LightSources.html"><strong aria-hidden="true">2.1.2.</strong> Light Sources</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/Circle-Source.html"><strong aria-hidden="true">2.1.2.1.</strong> Circle Source</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/DipoleSource.html"><strong aria-hidden="true">2.1.2.2.</strong> Dipole Source</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/Matrix-Source.html"><strong aria-hidden="true">2.1.2.3.</strong> Matrix Source</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/Pixel-Source.html"><strong aria-hidden="true">2.1.2.4.</strong> Pixel Source</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/Point-Source.html"><strong aria-hidden="true">2.1.2.5.</strong> Point Source</a></li><li class="chapter-item "><a href="Model/BeamlineObjects/LightSources/SimpleUndulatorSource.html"><strong aria-hidden="true">2.1.2.6.</strong> Simple Undulator Source</a></li></ol></li><li class="chapter-item "><a href="Model/BeamlineObjects/BeamlineParameter/Beamline-Parameter.html"><strong aria-hidden="true">2.1.3.</strong> Beamline Parameter</a></li></ol></li><li class="chapter-item "><a href="Model/User-vs-Model-Parameter.html"><strong aria-hidden="true">2.2.</strong> User vs Model Parameter</a></li><li class="chapter-item "><a href="Model/Ray-generation.html"><strong aria-hidden="true">2.3.</strong> Ray generation</a></li><li class="chapter-item "><a href="Model/PRNGs-on-the-GPU.html"><strong aria-hidden="true">2.4.</strong> PRNGs on the GPU</a></li><li class="chapter-item "><a href="Model/Transformation-between-coordinate-systems.html"><strong aria-hidden="true">2.5.</strong> Transformation between coordinate systems</a></li><li class="chapter-item "><a href="Model/Quad(ric)-function.html"><strong aria-hidden="true">2.6.</strong> Quad(ric) Function</a></li><li class="chapter-item "><a href="Model/Efficiency.html"><strong aria-hidden="true">2.7.</strong> Efficiency calculations</a></li><li class="chapter-item "><a href="Model/Events.html"><strong aria-hidden="true">2.8.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="Tools/Tools.html"><strong aria-hidden="true">3.</strong> Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Tools/Code-Coverage.html"><strong aria-hidden="true">3.1.</strong> Code Coverage</a></li><li class="chapter-item "><a href="Tools/Debugging.html"><strong aria-hidden="true">3.2.</strong> Debugging</a></li><li class="chapter-item "><a href="Tools/How-to-use-Doxygen.html"><strong aria-hidden="true">3.3.</strong> How to use Doxygen</a></li><li class="chapter-item "><a href="Tools/How-to-use-our-formatter.html"><strong aria-hidden="true">3.4.</strong> How to use our Formatter</a></li><li class="chapter-item "><a href="Tools/Testing.html"><strong aria-hidden="true">3.5.</strong> Testing</a></li><li class="chapter-item "><a href="Tools/RAYX-Profiling.html"><strong aria-hidden="true">3.6.</strong> RAYX Profiling</a></li></ol></li><li class="chapter-item "><a href="Vulkan/Vulkan.html"><strong aria-hidden="true">4.</strong> Vulkan</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Vulkan/VulkanTracer.html"><strong aria-hidden="true">4.1.</strong> Vulkan Tracer (rayx)</a></li><li class="chapter-item "><a href="Vulkan/Vulkan-Shader-Split.html"><strong aria-hidden="true">4.2.</strong> Vulkan Shader Split</a></li><li class="chapter-item "><a href="Vulkan/Vulkan-Beyond.html"><strong aria-hidden="true">4.3.</strong> Vulkan Beyond</a></li></ol></li><li class="chapter-item "><a href="RAYX-UI/RAYX-UI.html"><strong aria-hidden="true">5.</strong> RAYX-UI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="RAYX-UI/Triangulation.html"><strong aria-hidden="true">5.1.</strong> Triangulation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RAYX Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rayx"><a class="header" href="#rayx">RAYX</a></h1>
<table>
  <tr>
    <td>
      <img src="https://github.com/user-attachments/assets/d12229b0-7820-475f-8f02-6b2f253c5081" alt="RAYX Logo" width="600">
    </td>
    <td>
      <strong>RAYX</strong> is a powerful, multi-component simulation platform designed to streamline the design and optimization of beamlines in synchrotron light source facilities. At the core of the platform is <i>rayx-core</i>, a high-performance library that delivers precise light tracing capabilities on both CPUs and GPUs. This core library ensures that users can achieve detailed and accurate simulations at high speeds, making it an ideal solution for complex beamline designs.
    </td>
  </tr>
</table>
<p>To simplify the usage of <em>rayx-core</em>, the platform includes rayx, a command-line interface (CLI) tool designed for fast, one-shot tracing of beamlines. It provides comprehensive data on every ray-element intersection, making it especially valuable for generating large datasets efficiently. With its focus on ease of use, <em>rayx</em> empowers users to quickly run simulations and retrieve detailed ray-tracing results.</p>
<p>For users who prefer a more visual approach, <em>rayx-ui</em> offers a graphical user interface (GUI) that includes a 3D viewport of the beamline, enabling interactive design and exploration. This GUI provides an intuitive interface to construct and modify beamlines, allowing users to visualize their designs in real-time. <em>rayx-ui</em> not only enhances the design process but also allows users to iteratively optimize configurations based on immediate visual feedback.</p>
<h2 id="rayx-vs-ray-ui"><a class="header" href="#rayx-vs-ray-ui">RAYX vs RAY-UI</a></h2>
<p>RAYX offers several advanced features, including:</p>
<ul>
<li>Global (not sequential) tracing of beamlines</li>
<li>GPU utilization for accelerated tracing performance</li>
<li>A dedicated mode for tracing multiple beamlines with ease</li>
<li>Objects in RAYX can be grouped for simplified group transformations</li>
<li>A GUI for intuitive beamline design</li>
</ul>
<h2 id="installing-or-building-rayx"><a class="header" href="#installing-or-building-rayx">Installing or Building RAYX</a></h2>
<p><a href="https://github.com/hz-b/rayx/actions/workflows/testUbuntu.yml"><img src="https://github.com/hz-b/rayx/actions/workflows/testUbuntu.yml/badge.svg?branch=master" alt="testUbuntu" /></a> <a href="https://github.com/hz-b/rayx/actions/workflows/testWindows.yml"><img src="https://github.com/hz-b/rayx/actions/workflows/testWindows.yml/badge.svg?branch=master" alt="testWindows" /></a> <a href="https://github.com/hz-b/rayx/actions/workflows/testUbuntuClang.yml"><img src="https://github.com/hz-b/rayx/actions/workflows/testUbuntuClang.yml/badge.svg?branch=master" alt="testUbuntuClang" /></a> <a href="https://github.com/hz-b/rayx/actions/workflows/mdBookDeploy.yml"><img src="https://github.com/hz-b/rayx/actions/workflows/mdBookDeploy.yml/badge.svg" alt="MDBookDeploy" /></a></p>
<p>For additional information, please visit our <a href="https://hz-b.github.io/rayx/">Wiki</a> and read our latest <a href="https://pubs.aip.org/aip/rsi/article/96/6/061302/3348292/RAYX-An-optics-simulation-software-for-synchrotron">paper</a>, that introduces RAYX to the scientific community. We are committed to delivering stable releases, which can be found <a href="https://github.com/hz-b/rayx/releases">here</a>. Please note that the <code>master</code> branch and other branches might be unstable, and building RAYX from the source could lead to unstable software. We recommend this only for developers and experienced users. If you experience issues with our distributed binaries or API, do not hesitate to <a href="https://github.com/hz-b/rayx/issues/new/choose">open an issue</a>. We are keen to provide assistance and develop features as the need arises.</p>
<h2 id="relevant-publications"><a class="header" href="#relevant-publications">Relevant Publications</a></h2>
<p>If you use <strong>RAYX</strong> in your scientific work, please consider citing our paper:</p>
<p><strong>RAYX – An optics simulation software for synchrotron applications</strong>
Sven Erdem, Peter Feuer-Forson, Jannis Maier, Felix Möller, Enrico Philip Ahlers, Valentin Stöcker, Fanny Zotter, Peter Baumgärtel, Jens Viefhaus
<a href="https://pubs.aip.org/aip/rsi/article/96/6/061302/3348292/RAYX-An-optics-simulation-software-for-synchrotron">Review of Scientific Instruments, Vol. 96, Issue 6 (2025)</a>
DOI: <a href="https://doi.org/10.1063/5.0253857">10.1063/5.0253857</a></p>
<blockquote>
<p>We present RAYX, an advanced optics simulation software for synchrotron applications and the successor to RAY/RAY-UI [Schäfers, in <em>Modern Developments in X-Ray and Neutron Optics</em>, Springer, 2008]. RAYX offers a modern, versatile platform designed to accelerate beamline design, optimization, and data analysis, including machine learning workflows. It supports accurate and efficient simulations across a wide spectral range and optical elements, tailored for current and next-generation synchrotron facilities.</p>
</blockquote>
<p>This publication provides an overview of the software's architecture and capabilities, including GPU acceleration, Python bindings, and GUI support.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>RAYX is a command-line tool developed to work in conjunction with RAYX-CORE for the purpose of accurately and efficiently tracing beamlines, as described by .rml files. RAYX-CORE is a specialized library with capabilities for simulating a variety of optical phenomena. The library adopts a modular architecture for the construction of optical elements, comprising three key components: Surface, Cutout, and Behavior. These components are responsible for calculating ray-object collisions and determining the subsequent interactions of the ray, such as reflection or absorption. The primary application of RAYX-CORE is to enable the precise tracing of synchrotron radiation in beamlines associated with electron storage rings.</p>
<p>In terms of computational resources, RAYX utilizes the parallel processing capabilities of GPUs, facilitated through the Vulkan API. This approach allows for efficient and accurate ray tracing. For systems without GPU support, RAYX provides an alternative CPU-based tracing option to maintain compatibility across diverse hardware configurations.</p>
<p>Further enhancing the project's capabilities, RAYX-UI has been introduced as a real-time rendering interface built upon RAYX-CORE. This interface provides immediate visual feedback on the interactions between rays and optical elements, serving as a valuable tool for adjusting element positions. While initially conceived as a debugging utility, the long-term objective for RAYX-UI is its development into a full-fledged 3D design tool for beamline construction and customization.</p>
<div style="break-before: page; page-break-before: always;"></div><p>#How to Build</p>
<p>For building and running the project, we recommend using <a href="https://code.visualstudio.com/">Visual Studio Code</a> (VSCode) as your IDE, along with the C/C++ and CMake Tools extensions. These extensions significantly simplify the building process. However, you are free to use any IDE of your choice. If you are on a UNIX-like system, the <code>compile.sh</code> script can be used for compilation (see <a href="Introduction/02-How-to-build.html#using-compile.sh">using compile.sh</a>).</p>
<h2 id="cmake-options"><a class="header" href="#cmake-options">CMake Options:</a></h2>
<div class="table-wrapper"><table><thead><tr><th>CMake Option</th><th>Default value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RAYX_ENABLE_OPENMP:BOOL</code></td><td><code>ON</code></td><td>enable search for OpenMP on your system. If found, build with OpenMP for tracing on CPU</td></tr>
<tr><td><code>RAYX_REQUIRES_OPENMP:BOOL</code></td><td><code>OFF</code></td><td>require OpenMP to be found on your system. Otherwise throw an error</td></tr>
<tr><td><code>RAYX_ENABLE_CUDA:BOOL</code></td><td><code>ON</code></td><td>enable search for Cuda on your system. If found, build with Cuda for tracing on GPU</td></tr>
<tr><td><code>RAYX_REQUIRES_CUDA:BOOL</code></td><td><code>OFF</code></td><td>require Cuda to be found on your system. Otherwise throw an error</td></tr>
<tr><td><code>RAYX_ENABLE_H5:BOOL</code></td><td><code>ON</code></td><td>enable search for HDF5 on your system. If found, build with HDF5 for H5 file format support</td></tr>
<tr><td><code>RAYX_REQUIRES_H5:BOOL</code></td><td><code>OFF</code></td><td>require HDF5 to be found on your system. Otherwise throw an error</td></tr>
<tr><td><code>RAYX_STATIC_LIB:BOOL</code></td><td><code>OFF</code></td><td>this option builds 'rayx-core' as a static library</td></tr>
<tr><td><code>CMAKE_CUDA_ARCHITECTURES:STRING</code></td><td><code>all-major</code></td><td>set the cuda device architectures to build for. by default, build for all major architectures</td></tr>
</tbody></table>
</div>
<h2 id="cloning-the-repository"><a class="header" href="#cloning-the-repository">Cloning the Repository</a></h2>
<p>Clone the git repository by running one of the following commands:</p>
<ul>
<li>Using SSH:</li>
</ul>
<p><code>git clone --recurse-submodules git@github.com:hz-b/rayx.git</code></p>
<ul>
<li>Using HTTPS:</li>
</ul>
<p><code>git clone --recurse-submodules https://github.com/hz-b/rayx.git</code></p>
<h2 id="on-windows"><a class="header" href="#on-windows">On Windows</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Install <a href="https://cmake.org/download/">CMake</a>.</li>
<li>Install the <a href="https://vulkan.lunarg.com/sdk/home#windows">Vulkan SDK</a> for Windows (at least version 1.3 or newer).</li>
<li>Install the <a href="https://www.hdfgroup.org/downloads/hdf5/">HDF5</a> library.</li>
<li>Install Python3, python3-dev, and python3-matplotlib.</li>
<li>We recommend using the MSVC compiler for Windows, available through <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio</a> (2019 or newer).</li>
<li>Optional (required for Tracing on the GPU):
<ul>
<li>Install <a href="https://developer.nvidia.com/Cuda-downloads?target_os=Windows">Cuda</a>.
Tested with Cuda version 12.5.1</li>
<li>Add Cuda to your PATH.</li>
</ul>
</li>
</ul>
<h3 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h3>
<ul>
<li>Installing the VulkanSDK at the root directory of your drive may cause issues. If you encounter problems with the VulkanSDK, consider installing it in a different directory.</li>
</ul>
<h3 id="building-with-vscode"><a class="header" href="#building-with-vscode">Building with VSCode</a></h3>
<ul>
<li>Open the project in VSCode. You will be prompted to select a build kit (e.g., gcc).</li>
<li>Allow the CMake Extension to configure the project.</li>
<li>You can then build the project using the build button in the bottom panel.</li>
</ul>
<p>To use a custom generator for CMake, such as Ninja for faster builds, you can set it in the <code>.vscode/settings.json</code> file. The following is an example configuration for the generator in VSCode:
<img src="Introduction/../res/vscode_ninja_config.png" alt="" /></p>
<h3 id="building-with-visual-studio"><a class="header" href="#building-with-visual-studio">Building with Visual Studio</a></h3>
<ul>
<li>Open a terminal in the project folder.</li>
<li>Run the following command, replacing it with your version of Visual Studio:</li>
</ul>
<p><code>cmake -S . -B build -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release</code></p>
<p>see: <a href="Introduction/02-How-to-build.html#cmake-options">Cmake Options</a></p>
<h2 id="on-linux"><a class="header" href="#on-linux">On Linux</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Ensure cmake, gcc, gdb, and make are installed and up to date.</li>
<li>Install the Vulkan SDK from <a href="https://vulkan.lunarg.com/sdk/home">here</a>. Select a version under Linux -&gt; Ubuntu Packages.</li>
<li>Install Python3, python3-dev, and python3-matplotlib.</li>
<li>The project leverages <a href="https://github.com/BlueBrain/HighFive">libhdf5</a> for data management and incorporates various other libraries for graphical user interfaces, linear algebra computations, and handling different aspects of the X11 window system. Install the necessary libraries with the following command:</li>
<li>Optional (required for Tracing on the GPU):
<ul>
<li>Install Cuda</li>
<li>see <a href="Introduction/02-How-to-build.html#determining-cuda-and-compiler-version">Determining Cuda and compiler version</a></li>
</ul>
</li>
</ul>
<h3 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h3>
<p><code>apt update &amp;&amp; apt -y install libblas-dev liblapack-dev libhdf5-dev libgtk-3-dev pkg-config libxi-dev libxcursor-dev libxinerama-dev libxrandr-dev</code></p>
<ul>
<li>Ensure the libraries are installed at <code>/usr/include/hdf5/serial</code> and <code>/usr/lib/x86_64-linux-gnu/hdf5/serial</code>.</li>
</ul>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<p>Arch Linux users can obtain all necessary packages through pacman, yay, or other package managers. Specific instructions will be provided later.</p>
<h3 id="fedora"><a class="header" href="#fedora">Fedora</a></h3>
<p>To install the required packages on Fedora, run the following command:</p>
<p><code>sudo dnf install cmake gcc gdb vulkan vulkan-tools vulkan-validation-layers hdf5-devel ninja-build gcc-c++ vulkan-loader-devel glslc blas-devel lapack-devel gtk3-devel pkg-config libXi-devel libXcursor-devel libXinerama-devel libXrandr-devel boost</code></p>
<h3 id="determining-cuda-and-compiler-version"><a class="header" href="#determining-cuda-and-compiler-version">Determining Cuda and compiler version</a></h3>
<ul>
<li>GCC: Depending on the Cuda version, different versions of GCC may be supported.
This projects is tested with Cuda version 12.4.1 and GCC version 13.3
Please take a look at the supported versions of GCC for your Cuda installation:
<ul>
<li><a href="https://stackoverflow.com/questions/6622454/Cuda-incompatible-with-my-gcc-version">https://stackoverflow.com/questions/6622454/Cuda-incompatible-with-my-gcc-version</a></li>
<li><a href="https://gist.github.com/ax3l/9489132">https://gist.github.com/ax3l/9489132</a></li>
</ul>
</li>
<li>Clang: Using clang as Cuda compiler is currently not supported.</li>
</ul>
<h3 id="using-compilesh"><a class="header" href="#using-compilesh">Using compile.sh</a></h3>
<p>usage: <code>./compile.sh</code></p>
<h4 id="options"><a class="header" href="#options">Options:</a></h4>
<ul>
<li><code>--release</code> build in release mode (default: build in debug mode)</li>
<li><code>--cuda</code> enable compilation with Cuda (default: build without Cuda)<br />
see <a href="Introduction/02-How-to-build.html#determining-cuda-and-compiler-version">Determining Cuda and compiler version</a> <br />
example usage: <code>CXX=g++-13 ./compile.sh --cuda</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install"><a class="header" href="#how-to-install">How to Install</a></h1>
<p>Welcome to the installation guide for RAYX! This section is a work in progress as we refine our release distribution. If you encounter any issues, we're here to help. Please open an issue on GitHub <a href="https://github.com/hz-b/rayx/issues/new/choose">here</a>. Your feedback helps us improve our documentation and installers based on real user experiences.</p>
<h2 id="releases"><a class="header" href="#releases">Releases</a></h2>
<p>You can find the latest releases of RAYX <a href="https://github.com/hz-b/rayx/releases/tag/v0.21.2">here</a>. Each release includes:</p>
<ul>
<li><strong>rayx-core</strong>: The core library binary.</li>
<li><strong>rayx</strong>: Command-Line Interface (CLI) application.</li>
<li><strong>rayx-ui</strong>: Graphical User Interface (GUI) application.</li>
<li><strong>Data Files</strong>: Includes necessary data, shader, and font files.</li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>There are some dependencies that might not be handled by every distributed package, installer or archive. We give a general overview of missing dependencies you might encounter here.</p>
<h3 id="rayx-core"><a class="header" href="#rayx-core">rayx-core</a></h3>
<ul>
<li><a href="https://www.hdfgroup.org/download-hdf5/">HDF5 Library</a> for faster I/O operations.</li>
</ul>
<h3 id="rayx-ui"><a class="header" href="#rayx-ui">rayx-ui</a></h3>
<ul>
<li>GPU driver from AMD, Intel, or NVIDIA.</li>
</ul>
<h2 id="installation-instructions"><a class="header" href="#installation-instructions">Installation Instructions</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>We provide the following options for Windows:</p>
<ul>
<li><strong>Portable Version (.zip)</strong>: No installation required. Just unzip and run.</li>
<li><strong>Installer (.exe)</strong>: An NSIS installer that guides you through the setup process.</li>
</ul>
<p><strong>Note:</strong> You may need to install the <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170">Microsoft Visual C++ Redistributable</a>.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>We offer several packages for Linux distributions:</p>
<ul>
<li><strong>Debian Package (.deb)</strong>: For Debian-based systems like Ubuntu.</li>
<li><strong>RPM Package (.rpm)</strong>: For Red Hat-based systems like Fedora.</li>
<li><strong>Tarball (.tar.gz)</strong>: For other Linux systems. Intended for experienced users comfortable with manual installations.</li>
</ul>
<h4 id="ubuntu-debian-based-systems"><a class="header" href="#ubuntu-debian-based-systems">Ubuntu (Debian-based Systems)</a></h4>
<p>To install RAYX on Ubuntu:</p>
<ol>
<li>
<p><strong>Download</strong> the <code>.deb</code> package from the <a href="https://github.com/hz-b/rayx/releases/tag/v0.21.2">releases page</a>.</p>
</li>
<li>
<p><strong>Install</strong> the package using:</p>
<pre><code class="language-bash">sudo apt install ./rayx-ui_&lt;version&gt;_amd64.deb
</code></pre>
<p>Replace <code>&lt;version&gt;</code> with the actual version number.</p>
</li>
<li>
<p><strong>Install Dependencies</strong>:</p>
<pre><code class="language-bash">sudo apt-get install libhdf5-dev
</code></pre>
</li>
</ol>
<h4 id="fedora-red-hat-based-systems"><a class="header" href="#fedora-red-hat-based-systems">Fedora (Red Hat-based Systems)</a></h4>
<p>To install RAYX on Fedora:</p>
<ol>
<li>
<p><strong>Download</strong> the <code>.rpm</code> package from the <a href="https://github.com/hz-b/rayx/releases/tag/v0.21.2">releases page</a>.</p>
</li>
<li>
<p><strong>Install</strong> the package using:</p>
<pre><code class="language-bash">sudo dnf install rayx-ui-&lt;version&gt;.rpm
</code></pre>
<p>Replace <code>&lt;version&gt;</code> with the actual version number.</p>
</li>
<li>
<p><strong>Install Dependencies</strong>:</p>
<pre><code class="language-bash">sudo dnf install hdf5
</code></pre>
</li>
</ol>
<h4 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h4>
<p>While we don't provide a native package for Arch Linux, you can use the tarball or build from source.</p>
<p><strong>Install Dependencies</strong>:</p>
<pre><code class="language-bash">sudo pacman -S hdf5
</code></pre>
<hr />
<h3 id="installing-from-tarball-targz"><a class="header" href="#installing-from-tarball-targz">Installing from Tarball (.tar.gz)</a></h3>
<p>The tarball is intended for experienced users who prefer manual installation or are using a Linux distribution not directly supported by our <code>.deb</code> or <code>.rpm</code> packages.</p>
<p><strong>Steps</strong>:</p>
<ol>
<li>
<p><strong>Download</strong> the <code>.tar.gz</code> file from the <a href="https://github.com/hz-b/rayx/releases">releases page</a> or use the provided tarball.</p>
</li>
<li>
<p><strong>Extract</strong> the tarball:</p>
<pre><code class="language-bash">tar -xzf RAYX-&lt;version&gt;-Linux.tar.gz
</code></pre>
<p>This will create a directory named <code>RAYX-&lt;version&gt;-Linux</code>.</p>
</li>
<li>
<p><strong>Move</strong> the extracted files to a directory of your choice (e.g., <code>/opt/rayx</code>):</p>
<pre><code class="language-bash">sudo mv RAYX-&lt;version&gt;-Linux /opt/rayx
</code></pre>
</li>
<li>
<p><strong>Add to PATH</strong> (optional):</p>
<pre><code class="language-bash">echo 'export PATH=/opt/rayx/bin:$PATH' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
</li>
<li>
<p><strong>Run RAYX</strong> from the installation directory or after adding it to your PATH.</p>
</li>
</ol>
<p><strong>Note:</strong> Installing from a tarball does not handle dependencies automatically. You need to ensure all required dependencies are present on your system. Look at the previous sections for guidance.</p>
<hr />
<p>If you have any questions or run into issues during installation, please don't hesitate to <a href="https://github.com/hz-b/rayx/issues/new/choose">open an issue on GitHub</a>. Your input is invaluable in helping us enhance our tools and documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Currently we only support a one over trace for a given beamline file. This means,
you can either use RAY-UI to generate a beamline file or alter an existing one.</p>
<p>Here is an example for a simple beamline file "PlaneMirror.rml":</p>
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;lab&gt;
&lt;version&gt;1.1&lt;/version&gt;
&lt;beamline&gt;

  &lt;object name="Matrix Source" type="Matrix Source"&gt;
    &lt;param id="numberRays" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
    &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
    &lt;param id="sourceDepth" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="horDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="verDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="photonEnergyDistributionFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;1&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;1&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;

  &lt;object name="Plane Mirror" type="Plane Mirror"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" auto="T" enabled="T"&gt;40&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" auto="T" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="systemMount" comment="standalone" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="premirrorShiftZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="pimpaleAlpha1" enabled="F"&gt;1&lt;/param&gt;
    &lt;param id="pimpaleAlpha2" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="pimpaleAlpha3" enabled="F"&gt;3&lt;/param&gt;
    &lt;param id="distancePremirrorGrating" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="elementSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.766044443118978&lt;/y&gt;
      &lt;z&gt;-0.6427876096865393&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.6427876096865393&lt;/y&gt;
      &lt;z&gt;0.766044443118978&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;

&lt;/beamline&gt;

&lt;ExtraData&gt;
&lt;/ExtraData&gt;
&lt;/lab&gt;

</code></pre>
<p>In it we have a matrix source that sends rays onto a plane mirror.
Assuming the beamline file is in the same directory as the binary
you can run the CLI of rayx as follows:</p>
<pre><code>./rayx -i PlaneMirror.rml
</code></pre>
<p>Adding a <code>-p</code> flag will output a footprint of the last element in
in the beamline, which was hit by rays.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rayx-ui-user-guide"><a class="header" href="#rayx-ui-user-guide">RAYX-UI User Guide</a></h1>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p><img src="Introduction/../res/RAYX-UI.png" alt="Alt text" /></p>
<p>Th window in the image above is accessible in the RAYX-UI application once it's opened. The window provides additional options for adjusting the scene you're viewing. Most notably, the "Open File Dialog" button (indicated by a red arrow) opens a file dialog that allows you to load your .rml beamline file. Currently, the application expects the h5 file (RAYX output) to be located next to it. In the future, tracing functionality will be directly integrated into the interface.</p>
<p>The subsequent camera settings in the interface are intended for advanced users and will not be explained here. If you're unfamiliar with these settings, you likely won't need them. Further down, however, you'll find the "Save Camera" and "Load Camera" buttons, which enable you to save and load a single camera position. This feature can be useful if you wish to save your camera settings for future use or compare different beamlines from the same vantage point.</p>
<h2 id="basic-navigation-and-control"><a class="header" href="#basic-navigation-and-control">Basic Navigation and Control</a></h2>
<p>RAYX-UI is an interface designed for real-time visualization of beamline simulations conducted by RAYX-CORE. The application employs keyboard and mouse inputs for navigation and control.</p>
<ul>
<li><strong>Camera Movement</strong>: Use the <code>W</code>, <code>A</code>, <code>S</code>, <code>D</code>, <code>Q</code>, and <code>E</code> keys to move the camera through the 3D space.</li>
<li><strong>Adjust Speed</strong>: Hold down the <code>Shift</code> key to adjust movement speed.</li>
<li><strong>Camera Direction</strong>: Right-clicking the mouse activates a mode to control camera direction.</li>
<li><strong>Toggle Modes</strong>: The application can be toggled between fullscreen and windowed modes using <code>F11</code> and <code>F10</code> keys, respectively.</li>
</ul>
<h2 id="color-indicators"><a class="header" href="#color-indicators">Color Indicators</a></h2>
<p>In the visual representation, various colors are used to indicate specific conditions or states:</p>
<ul>
<li><strong>Just Hit</strong>: Rays that have just hit an element are represented in a yellow to orange gradient.</li>
<li><strong>Absorbed</strong>: Rays that are absorbed by an element are depicted in red.</li>
<li><strong>Other</strong>: Rays created from other events are white (this most likely indicates an issue in the tracing)</li>
</ul>
<p><strong>Optical Elements</strong>: Optical elements like slits or image planes are displayed in varying shades of blue, with the color gradient used to represent surface orientation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rayx-commands"><a class="header" href="#rayx-commands">RAYX Commands</a></h1>
<p>After a successful build, type <code>-h</code> or <code>--help</code> for a summary of all known commands.</p>
<blockquote>
<p>Hint: <code>-c</code> or <code>--command</code> are accepted. But <code>-command</code> can result in errors.</p>
</blockquote>
<pre><code>Terminal application for rayx  
Usage: ./rayx [OPTIONS]

Options:
  -h,--help                   Print this help message and exit
  -c,--ocsv                   Output stored as .csv file.
  -b,--batch INT              Batch size for Vulkan tracing
  -B,--benchmark              Benchmark application and output to stdout
  -X,--gpu                    Tracing on GPU
  -x,--cpu                    Tracing on CPU
  -p,--plot                   Plot output footprints and histograms.
  -l,--list                   List available devices
  -d,--device INT             Device ID
  -i,--input TEXT             Input RML File or Directory.
  -o,--output TEXT            Output path or filename
  -v,--version                Print application metadata
  -f                          Fix the seed to RAYX::FIXED_SEED (Uses default)
  -s,--seed INT               Provide a user-defined seed
  -S,--sequential             Trace rays sequentially
  -V,--verbose                Print detailed debug and trace info
  -F,--format TEXT            Format output CSV / H5 data
  -m,--maxEvents INT          Maximum number of recorded events per ray
  -R,--record-element INT     Record events only for a specific element (Default: -1 to record for all)
</code></pre>
<h1 id="command-descriptions"><a class="header" href="#command-descriptions">Command descriptions</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Command name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--help</code></td><td>Prints the help message.</td></tr>
<tr><td><code>--ocsv</code></td><td>Store the result as a <code>.csv</code> (defaults to <code>.h5</code>). Not recommended for large ray counts.</td></tr>
<tr><td><code>--batch</code></td><td>Specifies how large a batch of rays should be. Useful for compute performance tuning.</td></tr>
<tr><td><code>--benchmark</code></td><td>Benchmarks RAYX core performance. Outputs total runtime stats to stdout.</td></tr>
<tr><td><code>--gpu</code></td><td>Run tracing on the GPU.</td></tr>
<tr><td><code>--cpu</code></td><td>Run tracing on the CPU.</td></tr>
<tr><td><code>--plot</code></td><td>Plots footprints and histograms from the last Image Plane element. Closes only after the user exits the plot window.</td></tr>
<tr><td><code>--list</code></td><td>Lists all supported compute devices available on the system.</td></tr>
<tr><td><code>--device</code></td><td>Select a specific device by ID. Use with <code>--list</code> to see available IDs.</td></tr>
<tr><td><code>--input</code></td><td>Path to the RML file or directory to be used as the beamline.</td></tr>
<tr><td><code>--output</code></td><td>Path where the traced ray data should be saved.</td></tr>
<tr><td><code>--version</code></td><td>Displays application version and build metadata.</td></tr>
<tr><td><code>--dummy</code></td><td>Runs a dummy test beamline with a few optical elements. Useful for quick diagnostics.</td></tr>
<tr><td><code>--seed</code></td><td>Specifies a custom seed for deterministic tracing.</td></tr>
<tr><td><code>--f</code></td><td>Fix the seed to a default constant (<code>RAYX::FIXED_SEED</code>).</td></tr>
<tr><td><code>--sequential</code></td><td>Traces rays sequentially rather than in parallel.</td></tr>
<tr><td><code>--verbose</code></td><td>Outputs more internal information for debugging and performance tuning.</td></tr>
<tr><td><code>--format</code></td><td>Selects the output format. Supported: <code>csv</code>, <code>h5</code>.</td></tr>
<tr><td><code>--maxEvents</code></td><td>Limits the number of events (e.g., interactions with beamline elements) that are recorded per ray.</td></tr>
<tr><td><code>--record-element</code></td><td>Restrict event recording to a specific beamline element by index. Default: <code>-1</code> to record events for <strong>all</strong> elements.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="literature"><a class="header" href="#literature">Literature</a></h1>
<h2 id="bachelors-thesis"><a class="header" href="#bachelors-thesis">Bachelor's Thesis'</a></h2>
<p><a href="Introduction//docs/src/res/Extending_and_Accelerating_a_GPU_Ray_Tracing_Algorithm_for_Photon_Simulation_in_Beamlines_ohne.pdf">Extending_and_Accelerating_a_GPU_Ray_Tracing_Algorithm_for_Photon_Simulation_in_Beamlines_ohne.pdf</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide-for-programming-in-rayx"><a class="header" href="#style-guide-for-programming-in-rayx">Style Guide for Programming in RAYX</a></h1>
<p>This document serves as a comprehensive style guide for the RAY project. It outlines the coding standards and best practices that have evolved over the course of the project's lifecycle. Adherence to these guidelines is crucial for maintaining code readability and facilitating effective collaboration among team members. Please read them attentively.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>Write code with collective ownership in mind; the primary audience is your teammates, not just the compiler. The KISS (Keep It Stupid Simple) principle should be applied whenever possible.</p>
<h2 id="includes"><a class="header" href="#includes">Includes</a></h2>
<p>To enhance readability, includes should be categorized as follows:</p>
<ul>
<li>
<p><code>#include "internalHeader.h"</code></p>
</li>
<li>
<p><code>#include &lt;externalHeader.h&gt;</code></p>
</li>
</ul>
<p>Internal headers are those developed within the project, while external headers pertain to dependencies integrated into the project.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Prioritize frequent and precise commenting. Comments should be tailored to newcomers to the project, who are the most likely to require and benefit from them.</p>
<h3 id="doxygen-comments"><a class="header" href="#doxygen-comments">Doxygen Comments</a></h3>
<pre><code class="language-c++">/**
* a desctription (don't just repeat the function name)
* @param value1 	what the parameter value1 does
* @param value2 	what the parameter value2 does
* @see related function
* @return what the function returns
*/
</code></pre>
<p>The objective is for header files to provide high-level documentation on API usage, while source files should contain more detailed documentation about implementation specifics.</p>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<p>As longer names can contain more than one word, it can help to have a visual divider. In the case of Ray-UI we use "camelCase" and "PascalCase". When to use what, will be explained in the "Classes, Function and Variables" subsection.</p>
<p>The upper case letter indicates a new word and thus improves readability. Every name should be able to stand alone and describe the object, function or variable. Something like "int v;" does not achieve this. This also means to avoid using abbreviations, besides the most common ones ("val" for "value" or "dx" for a distance over x).</p>
<p>Avoid using symbols or variable names from formulas for naming variables in the code. This makes the code a riddle to decipher, without further information.
The correct ways to do this:</p>
<ul>
<li>Add a wiki entry for the formula and link to it</li>
<li>Change the variable names to its purpose or type, e.g. "hypotenuse" instead of "c"</li>
<li>Add a link to the formula, so other developers can find it (The other options are better, but at least do this)</li>
</ul>
<p>Should the name get too long or cryptic, write a comment to clarify what you mean with the name you chose for this variable.</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>Boolean values should begin with is/can/has/etc. when possible.</p>
<h3 id="classes-function-and-variables"><a class="header" href="#classes-function-and-variables">Classes, Function and Variables</a></h3>
<p>Class and object names are written in "PascalCase". Functions and Variables are written in "camelCase".</p>
<p>e.g.:</p>
<ul>
<li>"ClassA"</li>
<li>"functionB(int valueC, bool isD)"</li>
</ul>
<h3 id="member"><a class="header" href="#member">Member</a></h3>
<p>Member objects and variables of a class are indicated by an "m_", e.g. :</p>
<ul>
<li>m_MemberObject</li>
<li>m_memberVariable</li>
</ul>
<h2 id="const-correctness"><a class="header" href="#const-correctness">Const Correctness</a></h2>
<p>Const correctness is the practice of using the <code>const</code> keyword to ensure that objects and variables remain immutable. Use <code>const</code> as the default. One exception: function parameters of trivial data types like <code>int</code>, <code>double</code>, etc.</p>
<ol>
<li><code>void f1(const std::string&amp; s);     </code> <em>// Pass by reference-to-<code>const</code></em></li>
<li><code>void f2(const std::string* sptr);  </code> <em>// Pass by pointer-to-<code>const</code></em></li>
<li><code>void f3(std::string s);            </code> <em>// Pass by value</em></li>
</ol>
<p>Employing const correctness from the start is advisable, as it can simplify code maintenance and improve overall code quality.</p>
<p>Further reading on const correctness is highly recommended and can be found <a href="https://isocpp.org/wiki/faq/const-correctness">here</a>.</p>
<h2 id="pointer-usage-guidelines"><a class="header" href="#pointer-usage-guidelines">Pointer Usage Guidelines</a></h2>
<p>Raw pointers are discouraged except when interfacing with APIs that require them. Following are alternatives to raw pointers for specific use-cases.</p>
<ul>
<li><strong>Smart Pointers</strong>: Use <code>std::unique_ptr</code> and <code>std::shared_ptr</code> for managing dynamic memory.</li>
<li><strong>Optionality with <code>std::optional</code></strong>: Utilize <code>std::optional</code> for optional parameters or return types to explicitly indicate the absence of a value.</li>
<li><strong>Const C-Strings</strong>: Raw C-strings (<code>const char*</code>) are acceptable only when necessary for compatibility with C APIs. Ensure they are <code>const</code> to prevent modification.</li>
<li><strong>Optimize Strings with <code>std::string_view</code></strong>: For performance-critical code, use <code>std::string_view</code> to pass strings by reference without ownership or copy.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>In this section you can find formulas, methods and ideas used to
develop RAYX.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beamline-objects"><a class="header" href="#beamline-objects">Beamline Objects</a></h1>
<p>In the following chapter, you will find extensive information on all the Beamline Objects supported by RAYX.</p>
<h1 id="supported-objects"><a class="header" href="#supported-objects">Supported Objects</a></h1>
<p>We divide the objects into two categories: Light Sources and Optical Elements. As the name suggests, the Light Sources are the objects that create the ray information, such as their starting position, the direction of the flight path, and the energy the ray is carrying.</p>
<h3 id="light-sources"><a class="header" href="#light-sources">Light Sources</a></h3>
<ul>
<li><a href="Model/BeamlineObjects/LightSources/DipoleSource.html">Dipole Source</a></li>
<li><a href="Model/BeamlineObjects/LightSources/Point-Source.html">Point Source</a></li>
<li><a href="Model/BeamlineObjects/LightSources/Matrix-Source.html">Matrix Source</a></li>
<li><a href="Model/BeamlineObjects/LightSources/SimpleUndulatorSource.html">Simple Undulator Source</a></li>
<li><a href="Model/BeamlineObjects/LightSources/Circle-Source.html">Circle Source</a></li>
<li><a href="Model/BeamlineObjects/LightSources/Pixel-Source.html">Pixel Source</a></li>
</ul>
<h3 id="optical-elements"><a class="header" href="#optical-elements">Optical Elements</a></h3>
<ul>
<li><a href="Model/BeamlineObjects/OpticalElements/Image-Plane.html">Image Plane</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Plane-Mirror.html">Plane Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Plane-Grating.html">Plane Grating</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Cone-Mirror.html">Cone Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Cone-Mirror.html">Cone Grating</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Crystal.html">Crystal</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Cylinder-Mirror.html">Cylindrical Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Ellipsoid-Mirror.html">Ellipsoid Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Foil.html">Foil</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Sphere-Mirror.html">Spherical Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Sphere-Grating.html">Spherical Grating</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Toroid-Mirror.html">Toroidal Mirror</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Toroid-Grating.html">Toroidal Grating</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/RZP.html">Reflection Zone Plate</a></li>
<li><a href="Model/BeamlineObjects/OpticalElements/Slit.html">Slit</a></li>
<li><a href="Model/BeamlineObjects/../Quad(ric)-function.html">Custom Quadric Surface Mirror</a></li>
<li>Custom Cubic Surface Mirror</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optical-elements-1"><a class="header" href="#optical-elements-1">Optical Elements</a></h1>
<p>Optical elements are a central part of the tracing process. They define how light is guided through the beamline - where it is focused, redirected, or scattered.
In the context of RAYX a beamline consists of two types of elements:</p>
<ul>
<li>LightSources, to create the rays, and</li>
<li>OpticalElements, to be hit by and manipulate these rays</li>
</ul>
<p>In this section, you can read up on the design choices we made when implementing OpticalElements in RAYX.</p>
<h2 id="behavior-cutout-surface-coating"><a class="header" href="#behavior-cutout-surface-coating">Behavior, Cutout, Surface, Coating</a></h2>
<p>Next to its position and orientation, an OpticalElement is classified by three parts: The Behaviour, Surface and Cutout.</p>
<ul>
<li>The Behavior defines how the element interacts with a ray (eg. reflecting, absorbing, redirecting)</li>
<li>The Surface expresses the curvature of an OpticalElement</li>
<li>The cutout defines the boundaries of the OpticalElement. In other words it "cuts" a finite shape out of the large Surface.</li>
</ul>
<h3 id="behavior"><a class="header" href="#behavior">Behavior</a></h3>
<p>Behavior determines what happens to a ray once it hits the OpticalElement.
Such a "hit" might result in absorbtion, reflection or the ray might pass through the OpticalElement.
Typical examples of Behaviours are Mirror, Grating, Slit and <a href="Model/BeamlineObjects/OpticalElements/./RZP.html">RZP</a>.</p>
<p>Behaviours are defined in the Shared/Behaviour.h file.
Each Behaviour has a "behave" function (eg. behaveMirror, behaveSlit, ...) that translates the incoming ray to the outgoing ray.
These functions are gathered in the behave.comp file.</p>
<h3 id="surface"><a class="header" href="#surface">Surface</a></h3>
<p>Surfaces in RAYX are defined as either a plane, a quadric, or a toroid.
We use mathematical formulas to represent them internally, which means they are not necessarily bounded in size.
Optical elements are often subtly curved; to the human eye, they might appear indistinguishable from planar elements.</p>
<p>There are two ways to describe the reflectivity of the Surface. The User can choose between reflectivity Type '100%' and 'derived by material'.
If you want the second option you need to specify the following parameter:</p>
<ul>
<li>Material Substrate</li>
<li>Roughness Substrate</li>
<li>Density Substrate</li>
<li>Surface Coating</li>
<li>Coating File</li>
<li>Number Layer</li>
<li>Material Coating 1</li>
<li>Thickness Coating 1</li>
<li>Roughness Coating 1</li>
<li>Density Coating 1</li>
<li>Material Coating 2</li>
<li>Thickness Coating 2</li>
<li>Roughness Coating 2</li>
<li>Density Coating 2</li>
<li>Material Top Layer</li>
<li>Thickness Top Layer</li>
<li>Roughness Top Layer</li>
<li>Density Top Layer</li>
</ul>
<p>An example of the RML input looks like this:</p>
<pre><code class="language-XML">    &lt;param id="reflectivityType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.300000000000001&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
</code></pre>
<h3 id="cutout"><a class="header" href="#cutout">Cutout</a></h3>
<p>The cutout defines the boundaries of the OpticalElement, by cutting a shape out of the Surface.
As the surfaces of OpticalElements often only slightly differ from the XZ plane, we implement Cutouts by a simple 2D shape applied to the coordinates X and Z.</p>
<p>Cutouts come in different shapes:</p>
<ul>
<li>Rectangle</li>
<li>Ellipse</li>
<li>Trapezoid</li>
<li>Unlimited</li>
</ul>
<p>The central function is the <code>bool inCutout(Cutout cutout, double x, double z);</code>.
A given 3D point <code>p</code> is <em>within the cutout c</em>, if <code>inCutout(c, p.x, p.z)</code> returns <code>true</code>.</p>
<p>Not all OpticalElements use exactly one Cutout.
The Slit for example uses three Cutouts, one for the ray-absorbing shape around the "opening", then one for the "opening" itself, and another one for the ray-absorbing beamstop within the opening.</p>
<h3 id="coating"><a class="header" href="#coating">Coating</a></h3>
<p>The Coating describes the Layers a Mirror or Grating can have: No Layer, Single Layer or Multilayer.</p>
<h3 id="ray-opticalelement-collision"><a class="header" href="#ray-opticalelement-collision">Ray-OpticalElement collision</a></h3>
<p>When checking whether a ray collides with an OpticalElement, we first convert the Ray to the element coordinate system of the ray.
This makes (0, 0, 0) the center of the element, which generally lies in the XZ plane.
Rays then come from negative or positive y.</p>
<p>We then ask the Surface of our OpticalElement for a hitpoint using the <code>findCollisionWith</code> function.
And finally, if this hitpoint is in the cutout, we have found a collision.</p>
<h3 id="how-they-are-combined"><a class="header" href="#how-they-are-combined">How They Are Combined</a></h3>
<p>In the following image, you can see a visualization of how the surface and cutout interact.
The surface is a quadric that defines a sphere. The cutout is a rectangle, defined by points \(A\), \(B\), \(C\), and \(D\).</p>
<!-- TODO what role does icurv really play? -->
<p>Coupled with the <code>icurv</code> parameter, the cutout is mapped to the correct side of the sphere, visualized by points \(A_1\), \(B_1\), \(C_1\), and \(D_1\).
If a ray intersects the element's surface within the bounds of the cutout, it will be counted as a hit.
This is, where the behaviour comes into play to calculate the continuing path of the ray.</p>
<p>The cutout itself does not have a position; it is always at the origin of the element's coordinate system.</p>
<p>For some quadrics, this rule might not adequately define the position.
Therefore, we use the <code>icurv</code> parameter to determine whether the quadric is concave or convex.
This suffices since we calculate all intersection points with elements.
When two intersections occur, the <code>icurv</code> parameter informs us which intersection point to select.</p>
<p><img src="Model/BeamlineObjects/OpticalElements/../../res/wastebox.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cone-mirror"><a class="header" href="#cone-mirror">Cone Mirror</a></h1>
<h2 id="tracing-parameter"><a class="header" href="#tracing-parameter">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Cone:</p>
<ul>
<li>Grazing Inc Angle</li>
<li>Entrance Arm Length</li>
<li>Exit Arm Length</li>
<li>Total Length</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object"><a class="header" href="#rml-object">RML Object</a></h2>
<p>To track a Cone Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">    &lt;object name="Cone" type="Cone"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="entranceArmLength" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLength" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="upstreamRadius" auto="T" enabled="T"&gt;346.85522293840654&lt;/param&gt;
    &lt;param id="downstreamRadius" auto="T" enabled="T"&gt;284.67930120577341&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.300000000000001&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.98480775301220802&lt;/y&gt;
      &lt;z&gt;-0.17364817766693033&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.17364817766693033&lt;/y&gt;
      &lt;z&gt;0.98480775301220802&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plane-crystal"><a class="header" href="#plane-crystal">Plane-Crystal</a></h1>
<h2 id="crystal-diffraction"><a class="header" href="#crystal-diffraction">Crystal Diffraction</a></h2>
<p>We simulate X-ray diffraction using the <strong>dynamical theory</strong> in the <strong>Bragg-case geometry</strong>, assuming a <strong>perfect and thick crystal</strong>.</p>
<p>We compute the <strong>reflection coefficient</strong> based on this model. The reflected field is then determined from it. To run this simulation, the following user inputs are required:</p>
<h3 id="required-inputs"><a class="header" href="#required-inputs">Required Inputs</a></h3>
<ul>
<li><strong>Photon energy</strong> (in eV)</li>
<li><strong>lattice spacing*2</strong> (in nm)</li>
<li><strong>Unit cell volume</strong> (in nm³)</li>
<li><strong>Structure factors</strong>:
<ul>
<li>F₀, F_H, F_H̄ with real/imaginary components</li>
</ul>
</li>
<li><strong>Crystal surface offset angle</strong> α (in radians)</li>
</ul>
<p>The following sections explain how each physical quantity and formula is derived and used in the simulation.
This section details the implementation of dynamical X-ray diffraction theory for perfect crystals, based on the foundational work of Batterman &amp; Cole (1964).</p>
<h3 id="bragg-angle-calculation"><a class="header" href="#bragg-angle-calculation">Bragg Angle Calculation</a></h3>
<p>\[
\theta_B = \arcsin\left(\frac{\lambda}{2d}\right)
\]</p>
<ul>
<li><strong>Function</strong>: <code>getBraggAngle(energy, dSpacing2)</code></li>
<li><strong>Purpose</strong>: Calculate the Bragg diffraction angle</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>energy</code>: Photon energy (eV)</li>
<li><code>dSpacing2</code>: lattice spacing*2 (nm)</li>
</ul>
</li>
<li><strong>Returns</strong>: Bragg angle in radians</li>
</ul>
<h3 id="asymmetry-factor"><a class="header" href="#asymmetry-factor">Asymmetry Factor</a></h3>
<p>\[
b = \frac{\sin(\theta_B - \alpha)}{\sin(\theta_B + \alpha)}
\]</p>
<ul>
<li><strong>Function</strong>: <code>getAsymmetryFactor(braggAngle, offsetAngle)</code></li>
<li><strong>Purpose</strong>: Account for crystal surface orientation effects</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>braggAngle</code>: Calculated Bragg angle</li>
<li><code>offsetAngle</code>: Surface tilt angle α</li>
</ul>
</li>
</ul>
<p>This definition corresponds to the asymmetry factor derived from direction cosines<br />
and is consistent with the definition on page 690 in <a href="https://doi.org/10.1103/RevModPhys.36.681">Batterman &amp; Cole (1964)</a>.</p>
<h3 id="diffraction-prefactor"><a class="header" href="#diffraction-prefactor">Diffraction Prefactor</a></h3>
<p>\[
\Gamma = \frac{r_e \lambda^2}{\pi V}
\]</p>
<ul>
<li><strong>Function</strong>: <code>getDiffractionPrefactor(wavelength, unitCellVolume)</code></li>
<li><strong>Purpose</strong>: Calculate scaling factor for absorption/dispersion</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>wavelength</code>: X-ray wavelength (nm)</li>
<li><code>unitCellVolume</code>: Unit cell volume (nm³)</li>
</ul>
</li>
</ul>
<p>Gamma is defined in <a href="https://doi.org/10.1103/RevModPhys.36.681">Batterman &amp; Cole (1964)</a> p. 685.</p>
<h3 id="eta-parameter-η"><a class="header" href="#eta-parameter-η">Eta Parameter (η)</a></h3>
<p>\[
\eta = \frac{b\Delta\theta\sin 2\theta + \frac{1}{2}\Gamma F_0(1-b)}{\Gamma|P|\sqrt{|b|}\sqrt{F_H F_{\overline{H}}}}
\]</p>
<ul>
<li><strong>Function</strong>: <code>computeEta(theta, bragg, asymmetry, FH_re, FH_im, FHC_re, FHC_im, F0_re, F0_im, polFactor, gamma)</code></li>
<li><strong>Purpose</strong>: Compute normalized angular deviation parameter</li>
<li><strong>Parameters</strong>:
<ul>
<li>Structure factors (F₀, F_H, F_H̄) with real/imaginary components</li>
<li><code>polFactor</code>: Polarization factor (1 or |cos2θ_B|)</li>
</ul>
</li>
</ul>
<p>Eta is defined as equation (32) in <a href="https://doi.org/10.1103/RevModPhys.36.681">Batterman &amp; Cole (1964)</a> p. 690 .</p>
<h3 id="reflection-coefficient-r"><a class="header" href="#reflection-coefficient-r">Reflection Coefficient (R)</a></h3>
<p>\[
R = \left(\eta \pm \sqrt{\eta^2 - 1}\right)\sqrt{\frac{F_H}{F_{\overline{H}}}}
\]</p>
<ul>
<li><strong>Function</strong>: <code>computeR(eta, FH_re, FH_im, FHC_re, FHC_im)</code></li>
<li><strong>Purpose</strong>: Calculate complex reflection coefficient</li>
<li><strong>Note</strong>: Sign selection based on real part of η</li>
</ul>
<p>This function is based on Equation (103) from  <a href="https://doi.org/10.1103/RevModPhys.36.681">Batterman &amp; Cole (1964)</a> p. 706.<br />
We applied the square to the structure factor terms in advance and omitted the leading (|b|) factor.</p>
<h3 id="polarization-factors"><a class="header" href="#polarization-factors">Polarization Factors</a></h3>
<p>Two states considered:</p>
<ul>
<li>\(\sigma\)-polarization: \(P = 1\)</li>
<li>\(\pi\)-polarization: \(P = |\cos 2\theta_B|\)</li>
</ul>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>Batterman, B. W., &amp; Cole, H. (1964). <em>Dynamical Diffraction of X Rays by Perfect Crystals</em>. Reviews of Modern Physics, 36(3), 681–717. <a href="https://doi.org/10.1103/RevModPhys.36.681">https://doi.org/10.1103/RevModPhys.36.681</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cylindrical-mirror"><a class="header" href="#cylindrical-mirror">Cylindrical Mirror</a></h1>
<h2 id="tracing-parameter-1"><a class="header" href="#tracing-parameter-1">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Cylinder:</p>
<ul>
<li>Bending Radius</li>
<li>Radius</li>
<li>Grazing Inc Angle</li>
<li>Entrance Arm Length</li>
<li>Exit Arm Length</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-1"><a class="header" href="#rml-object-1">RML Object</a></h2>
<p>To track a Cylindrical Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">    &lt;object name="Cylinder" type="Cylinder"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="entranceArmLength" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLength" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="bendingRadius" comment="Long Radius R" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="radius" auto="T" enabled="T"&gt;10470.4917875&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.98480775301220802&lt;/y&gt;
      &lt;z&gt;-0.17364817766693033&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.17364817766693033&lt;/y&gt;
      &lt;z&gt;0.98480775301220802&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ellipsoid-mirror"><a class="header" href="#ellipsoid-mirror">Ellipsoid Mirror</a></h1>
<h2 id="tracing-parameter-2"><a class="header" href="#tracing-parameter-2">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Ellipoid:</p>
<ul>
<li>Entrance Arm Length</li>
<li>Exit Arm Length</li>
<li>Short Half Axis B</li>
<li>Long Half Axis A</li>
<li>Design Grazing Inc Angle</li>
<li>Figure Rotation</li>
<li>Parameter A11</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-2"><a class="header" href="#rml-object-2">RML Object</a></h2>
<p>To track a Ellipsoid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">    &lt;object name="Ellipsoid" type="Ellipsoid"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="entranceArmLength" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLength" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="designGrazingIncAngle" auto="T" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="longHalfAxisA" auto="T" enabled="T"&gt;5500&lt;/param&gt;
    &lt;param id="shortHalfAxisB" auto="T" enabled="T"&gt;549.12375296508355&lt;/param&gt;
    &lt;param id="figureRotation" comment="Yes" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="parameter_a11" enabled="F"&gt;1&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.300000000000001&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="misalignmentCoordinateSystem" comment="Ellipsoid" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.98480775301220802&lt;/y&gt;
      &lt;z&gt;-0.17364817766693033&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.17364817766693033&lt;/y&gt;
      &lt;z&gt;0.98480775301220802&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foil"><a class="header" href="#foil">Foil</a></h1>
<p>The Foil is an optical element that simulates the interaction of light with thin material layers (e.g., gold filters). It calculates polarization-dependent transmission/reflection using Fresnel equations.</p>
<h2 id="tracing-parameter-3"><a class="header" href="#tracing-parameter-3">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Foil:</p>
<ul>
<li>Substrate Thicness</li>
<li>Substrate Roughness</li>
</ul>
<h2 id="transmission-coefficient-calculation"><a class="header" href="#transmission-coefficient-calculation">Transmission Coefficient Calculation</a></h2>
<h3 id="angle-theta"><a class="header" href="#angle-theta">Angle Theta</a></h3>
<p>\begin{aligned}
\sin\theta_1 &amp;= \frac{N_1}{N_2}\sin\theta_0 \
\theta_2 &amp;= \theta_0 \quad \text{(Exit angle equals incidence angle)}
\end{aligned}</p>
<h3 id="fresnel-coefficients"><a class="header" href="#fresnel-coefficients">Fresnel Coefficients</a></h3>
<p>These are calculated for the entrance and exit surfaces.
\begin{aligned}
r_s &amp;= \frac{N_1\cos\theta_0 - N_2\cos\theta_1}{N_1\cos\theta_0 + N_2\cos\theta_1}, \
t_s &amp;= \frac{2N_1\cos\theta_0}{N_1\cos\theta_0 + N_2\cos\theta_1} <br />
r_p &amp;= \frac{N_2\cos\theta_0 - N_1\cos\theta_1}{N_2\cos\theta_0 + N_1\cos\theta_1}, <br />
t_p &amp;= \frac{2N_1\cos\theta_0}{N_2\cos\theta_0 + N_1\cos\theta_1}
\end{aligned}</p>
<h3 id="phaseshift"><a class="header" href="#phaseshift">Phaseshift</a></h3>
<p>\begin{aligned}
\delta &amp;= \frac{2\pi}{\lambda}N_2d\cos\theta_1, <br />
\phi &amp;= e^{i\delta}
\end{aligned}</p>
<h3 id="total-transmission"><a class="header" href="#total-transmission">Total Transmission</a></h3>
<p>\begin{aligned}
t_{\text{total}} &amp;= \frac{t_{01}t_{12}e^{i\delta}}{1 + r_{01}r_{12}e^{2i\delta}}
\end{aligned}</p>
<h2 id="rml-configuration"><a class="header" href="#rml-configuration">RML Configuration</a></h2>
<pre><code class="language-XML">  &lt;object name="Foil" type="Foil"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;40&lt;/param&gt;
   &lt;param id="totalHeight" enabled="T"&gt;60&lt;/param&gt;
   &lt;param id="normalIncidenceAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="transmissionType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
   &lt;param id="thicknessSubstrate" enabled="T"&gt;50&lt;/param&gt;
   &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.3&lt;/param&gt;
   &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="lateralThicknessGradientCoating" comment="No" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;10000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-plane"><a class="header" href="#image-plane">Image Plane</a></h1>
<p>The <strong>Image Plane</strong> is a fundamental optical element characterized by its flat, absorbing surface. This element is designed to capture all incoming rays, regardless of their direction or divergence. The Image Plane can be used in various optical simulations and is typically placed at a specified distance from the light source.</p>
<h2 id="light-properties"><a class="header" href="#light-properties">Light Properties</a></h2>
<p>In an Image Plane, rays are absorbed upon contact, allowing for the collection of all light interacting with the surface. This element does not modify the rays' properties but serves as a detector or absorber.</p>
<h2 id="standard-image-plane"><a class="header" href="#standard-image-plane">Standard Image Plane</a></h2>
<h3 id="rml-configuration-1"><a class="header" href="#rml-configuration-1">RML Configuration</a></h3>
<p>The standard configuration for an Image Plane does not impose any restrictions on size, meaning it effectively has an unlimited area for rays to hit.</p>
<pre><code class="language-XML">  &lt;object name="ImagePlane" type="ImagePlane"&gt;
   &lt;param id="distanceImagePlane" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li>distanceImagePlane: The distance from the light source to the image plane.</li>
<li>worldPosition: The (x, y, z) coordinates of the image plane in world space.</li>
<li>worldXdirection: Direction vector along the X-axis.</li>
<li>worldYdirection: Direction vector along the Y-axis.</li>
<li>worldZdirection: Direction vector along the Z-axis.</li>
</ul>
<h2 id="image-plane-with-cutout"><a class="header" href="#image-plane-with-cutout">Image Plane with Cutout</a></h2>
<p>In scenarios where only a specific area of the image plane is needed, a cutout can be specified. This will restrict the absorption to the defined geometrical shape.</p>
<pre><code class="language-XML">  &lt;object name="ImagePlane" type="ImagePlane"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
   &lt;param id="totalHeight" enabled="T"&gt;200&lt;/param&gt;
   &lt;param id="distanceImagePlane" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<h2 id="parameters-with-cutout"><a class="header" href="#parameters-with-cutout">Parameters with Cutout</a></h2>
<ul>
<li>geometricalShape: The shape of the cutout (e.g., rectangle).</li>
<li>totalWidth: Width of the image plane (or cutout).</li>
<li>totalHeight: Height of the image plane (or cutout).</li>
<li>distanceImagePlane: The distance from the light source to the image plane.</li>
<li>worldPosition: The (x, y, z) coordinates of the image plane in world space.</li>
<li>worldXdirection: Direction vector along the X-axis.</li>
<li>worldYdirection: Direction vector along the Y-axis.</li>
<li>worldZdirection: Direction vector along the Z-axis.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paraboloid-mirror"><a class="header" href="#paraboloid-mirror">Paraboloid Mirror</a></h1>
<h2 id="tracing-parameter-4"><a class="header" href="#tracing-parameter-4">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Paraboloid:</p>
<ul>
<li>Arm Length</li>
<li>Parameter P</li>
<li>Parameter P Type</li>
<li>Grazing Inc Angle</li>
<li>Parameter</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-3"><a class="header" href="#rml-object-3">RML Object</a></h2>
<p>To track a Paraboloid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">    &lt;object name="Paraboloid" type="Paraboloid"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
   &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
   &lt;param id="secondSurface" comment="on" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
   &lt;param id="armLength" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="parameter_P_type" comment="focusing" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="parameter_P" auto="T" enabled="T"&gt;-603.0737921409161&lt;/param&gt;
   &lt;param id="figureRotation" comment="Yes" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="parameter_a11" enabled="F"&gt;1&lt;/param&gt;
   &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="azimuthalAngle" enabled="T"&gt;10&lt;/param&gt;
   &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="materialSubstrate" enabled="F"&gt;Au&lt;/param&gt;
   &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
   &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="lateralThicknessGradientCoating" comment="No" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="misalignmentCoordinateSystem" comment="Paraboloid" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;10000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;0.9848077530122080&lt;/x&gt;
    &lt;y&gt;0.1736481776669303&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;-0.1736481776669303&lt;/x&gt;
    &lt;y&gt;0.9848077530122080&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plane-mirror"><a class="header" href="#plane-mirror">Plane Mirror</a></h1>
<p>A Plane Mirror is amongst the simplest Elements you can include in your beamline. The Surface is flat and reflective as described by the material.</p>
<h2 id="tracing-parameter-5"><a class="header" href="#tracing-parameter-5">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-4"><a class="header" href="#rml-object-4">RML Object</a></h2>
<p>To track a Plane Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">  &lt;object name="Plane Mirror" type="Plane Mirror"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" auto="T" enabled="T"&gt;40&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" auto="T" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="systemMount" comment="standalone" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="premirrorShiftZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="pimpaleAlpha1" enabled="F"&gt;1&lt;/param&gt;
    &lt;param id="pimpaleAlpha2" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="pimpaleAlpha3" enabled="F"&gt;3&lt;/param&gt;
    &lt;param id="distancePremirrorGrating" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="elementSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.766044443118978&lt;/y&gt;
      &lt;z&gt;-0.6427876096865393&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.6427876096865393&lt;/y&gt;
      &lt;z&gt;0.766044443118978&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plane-grating"><a class="header" href="#plane-grating">Plane Grating</a></h1>
<p>A Plane Grating is amongst the simplest Elements you can include in your beamline. The Surface is flat and it reflects light like an optical grating.</p>
<h2 id="tracing-parameter-6"><a class="header" href="#tracing-parameter-6">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Grating:</p>
<ul>
<li>vls parameter</li>
<li>Line Density</li>
<li>Order Of Diffraction</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-5"><a class="header" href="#rml-object-5">RML Object</a></h2>
<p>To track a Plane Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">  &lt;object name="Plane Grating" type="Plane Grating"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="gratingMount" comment="constant deviation" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="systemMount" comment="standalone, none" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="deviationAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="halfConeAngle" enabled="F"&gt;10&lt;/param&gt;
    &lt;param id="pimpaleX0" enabled="F"&gt;10000&lt;/param&gt;
    &lt;param id="pimpaleY0" enabled="F"&gt;10&lt;/param&gt;
    &lt;param id="premirrorMountPsi0" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="designEnergyMounting" auto="T" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="lineDensity" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="orderDiffraction" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="cFactor" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="alpha" auto="T" enabled="T"&gt;5.35655050894&lt;/param&gt;
    &lt;param id="beta" auto="T" enabled="T"&gt;-4.64344949106&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="entranceArmLength" enabled="F"&gt;10000&lt;/param&gt;
    &lt;param id="lineSpacing" comment="constant" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="vlsParameterB7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lineProfile" comment="unknown" enabled="F"&gt;3&lt;/param&gt;
    &lt;param id="gratingEfficiency" enabled="F"&gt;0.5&lt;/param&gt;
    &lt;param id="blazeAngle" enabled="F"&gt;4&lt;/param&gt;
    &lt;param id="aspectAngle" enabled="F"&gt;90&lt;/param&gt;
    &lt;param id="grooveDepth" enabled="F"&gt;10&lt;/param&gt;
    &lt;param id="grooveRatio" enabled="F"&gt;0.65&lt;/param&gt;
    &lt;param id="multilayerFourierCoefficients" auto="T" enabled="F"&gt;11&lt;/param&gt;
    &lt;param id="multilayerIntegrationSteps" auto="T" enabled="F"&gt;50&lt;/param&gt;
    &lt;param id="reflectivitySenkrecht" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="reflectivityParallel" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="reflectivityPhase" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.766044443118978&lt;/y&gt;
      &lt;z&gt;-0.6427876096865393&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.6427876096865393&lt;/y&gt;
      &lt;z&gt;0.766044443118978&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sphere-mirror"><a class="header" href="#sphere-mirror">Sphere Mirror</a></h1>
<h2 id="tracing-parameter-7"><a class="header" href="#tracing-parameter-7">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Sphere:</p>
<ul>
<li>Radius</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-6"><a class="header" href="#rml-object-6">RML Object</a></h2>
<p>To track a Sphere Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">  &lt;object name="SphereMirrorDefault" type="Sphere"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="entranceArmLength" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLength" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="radius" auto="T" enabled="T"&gt;10470.4917875&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="elementSubstrate" enabled="T"&gt;Cu&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;8.94&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.98480775301220802&lt;/y&gt;
      &lt;z&gt;-0.17364817766693033&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.17364817766693033&lt;/y&gt;
      &lt;z&gt;0.98480775301220802&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spherical-grating"><a class="header" href="#spherical-grating">Spherical Grating</a></h1>
<p>TBA</p>
<h2 id="tracing-parameter-8"><a class="header" href="#tracing-parameter-8">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Sphere:</p>
<ul>
<li>Radius</li>
</ul>
<p>Grating:</p>
<ul>
<li>vls parameter</li>
<li>Line Density</li>
<li>Order Of Diffraction</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-7"><a class="header" href="#rml-object-7">RML Object</a></h2>
<p>To track a Spherical Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">  &lt;object name="Spherical Grating" type="Spherical Grating"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
   &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
   &lt;param id="gratingMount" comment="constant deviation" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="deviationAngle" enabled="T"&gt;10&lt;/param&gt;
   &lt;param id="entranceArmLength" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="exitArmLength" auto="T" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="radius" auto="T" enabled="T"&gt;1825.126977351541&lt;/param&gt;
   &lt;param id="designEnergy" auto="T" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="lineDensity" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="orderDiffraction" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="alpha" auto="T" enabled="T"&gt;5.356547628646595&lt;/param&gt;
   &lt;param id="beta" auto="T" enabled="T"&gt;-4.643452371353405&lt;/param&gt;
   &lt;param id="lineSpacing" comment="constant" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter3" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter4" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter5" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter6" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="lineProfile" comment="unknown" enabled="T"&gt;3&lt;/param&gt;
   &lt;param id="gratingEfficiency" enabled="T"&gt;0.5&lt;/param&gt;
   &lt;param id="blazeAngle" enabled="F"&gt;4&lt;/param&gt;
   &lt;param id="aspectAngle" enabled="F"&gt;90&lt;/param&gt;
   &lt;param id="grooveDepth" enabled="F"&gt;10&lt;/param&gt;
   &lt;param id="grooveRatio" enabled="F"&gt;0.65&lt;/param&gt;
   &lt;param id="multilayerFourierCoefficients" auto="T" enabled="F"&gt;11&lt;/param&gt;
   &lt;param id="multilayerIntegrationSteps" auto="T" enabled="F"&gt;50&lt;/param&gt;
   &lt;param id="reflectivityType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
   &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.3&lt;/param&gt;
   &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;10000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0933532651278599&lt;/y&gt;
    &lt;z&gt;-0.9956330488136518&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.9956330488136518&lt;/y&gt;
    &lt;z&gt;0.0933532651278599&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slit"><a class="header" href="#slit">Slit</a></h1>
<p>The <strong>Slit</strong> is an optical element that allows users to define a cutout through which light rays pass. You can configure the shape and size of the slit opening, as well as the size and shape of a central beamstop to block part of the light. The Slit element also accounts for Fraunhofer diffraction, producing realistic diffraction patterns when light interacts with the slit, especially in the case of single-slit diffraction.</p>
<h2 id="tracing-parameter-9"><a class="header" href="#tracing-parameter-9">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Opening Shape</li>
<li>Opening Width</li>
<li>Opening Height</li>
<li>Central Beamstop</li>
<li>Total Width Stop</li>
<li>Total Height Stop</li>
</ul>
<h2 id="fraunhofer-diffraction-rectangular-slits"><a class="header" href="#fraunhofer-diffraction-rectangular-slits">Fraunhofer Diffraction (Rectangular Slits)</a></h2>
<p>The RAYX simulation software calculates <strong>Fraunhofer diffraction</strong> for rectangular slits, which impacts the diffraction angle of rays passing through the slit. The diffraction effect is dependent on the slit dimensions and the wavelength of the light. The diffraction pattern produced follows the well-known Fraunhofer single-slit diffraction model, where the intensity of the light depends on the angle and the size of the slit.</p>
<p>For a rectangular slit of dimension <code>b</code>, the diffraction angle <code>dAngle</code> is calculated based on the equation:</p>
<p>[
u = \frac{\pi b \sin(\theta)}{\lambda}
]</p>
<p>where:</p>
<ul>
<li>( b ) is the width or height of the slit</li>
<li>( \theta ) is the diffraction angle</li>
<li>( \lambda ) is the wavelength of the light</li>
</ul>
<p>The intensity distribution is proportional to ( \left( \frac{\sin(u)}{u} \right)^2 ).</p>
<p>The algorithm ensures that rays with different angles are assigned based on a random distribution, simulating the diffraction pattern as light passes through the slit.</p>
<h3 id="circular-apertures-and-zone-plates"><a class="header" href="#circular-apertures-and-zone-plates">Circular Apertures and Zone Plates</a></h3>
<p>In addition to rectangular slit diffraction, the software also supports <strong>Bessel diffraction</strong> for circular slits and zone plates. For a circular aperture of radius <code>r</code>, the diffraction is modeled using Bessel functions, producing characteristic ring-like diffraction patterns.</p>
<p>In this case, the diffraction angle <code>dphi</code> and <code>dpsi</code> are calculated based on the aperture radius and wavelength, simulating the radial symmetry of diffraction patterns from circular openings.</p>
<h2 id="rml-object-8"><a class="header" href="#rml-object-8">RML Object</a></h2>
<p>To track a Slit using an RML File, you'll require an XML Object to encompass all the mirror details.</p>
<pre><code class="language-XML">  &lt;object name="Slit" type="Slit"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;20&lt;/param&gt;
   &lt;param id="totalHeight" enabled="T"&gt;2&lt;/param&gt;
   &lt;param id="centralBeamstop" comment="none" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidthStop" enabled="F"&gt;20&lt;/param&gt;
   &lt;param id="totalHeightStop" enabled="F"&gt;1&lt;/param&gt;
   &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;10000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<h3 id="references-1"><a class="header" href="#references-1">References</a></h3>
<p>For further reading on Fraunhofer diffraction, please refer to the <a href="https://en.wikipedia.org/wiki/Fraunhofer_diffraction">Wikipedia page on Fraunhofer Diffraction</a> or standard optics textbooks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toroid-mirror"><a class="header" href="#toroid-mirror">Toroid Mirror</a></h1>
<p>TBA</p>
<h2 id="tracing-parameter-10"><a class="header" href="#tracing-parameter-10">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Toroid:</p>
<ul>
<li>Short Radius</li>
<li>Long Radius</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-9"><a class="header" href="#rml-object-9">RML Object</a></h2>
<p>To track a Toroid Mirror using an RML File, you'll require an XML Object to encompass all the mirror details. The default mirror setup from RAY-UI is provided here for your convenience. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">   &lt;object name="Toroid" type="Toroid"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="grazingIncAngle" enabled="T"&gt;10&lt;/param&gt;
    &lt;param id="entranceArmLengthSag" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLengthSag" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="entranceArmLengthMer" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="exitArmLengthMer" enabled="T"&gt;1000&lt;/param&gt;
    &lt;param id="longRadius" auto="T" enabled="T"&gt;10470.4917875&lt;/param&gt;
    &lt;param id="shortRadius" auto="T" enabled="T"&gt;315.723959394&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="reflectivityType" comment="100%" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="F"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="F"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="coatingFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="roughnessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.98480775301220802&lt;/y&gt;
      &lt;z&gt;-0.17364817766693033&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.17364817766693033&lt;/y&gt;
      &lt;z&gt;0.98480775301220802&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toroid-grating"><a class="header" href="#toroid-grating">Toroid Grating</a></h1>
<p>TBA</p>
<h2 id="tracing-parameter-11"><a class="header" href="#tracing-parameter-11">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>Toroid:</p>
<ul>
<li>Short Radius</li>
<li>Long Radius</li>
</ul>
<p>Grating:</p>
<ul>
<li>Varied line spaceing parameter</li>
<li>Line Density</li>
<li>Order Of Diffraction</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-10"><a class="header" href="#rml-object-10">RML Object</a></h2>
<p>To track a Toroid Grating using an RML File, you'll require an XML Object to encompass all the grating details. Remember, successful tracing requires you to specify a Light Source first. We suggest adding an Imageplane at the end for clearer results.</p>
<pre><code class="language-XML">   &lt;object name="Toroidal Grating" type="Toroidal Grating"&gt;
   &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
   &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
   &lt;param id="gratingMount" comment="constant deviation" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="deviationAngle" enabled="T"&gt;10&lt;/param&gt;
   &lt;param id="entranceArmLengthSag" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="exitArmLengthSag" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="entranceArmLengthMer" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="exitArmLengthMer" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="longRadius" auto="T" enabled="T"&gt;1823.537175159428&lt;/param&gt;
   &lt;param id="shortRadius" auto="T" enabled="T"&gt;1811.228017099299&lt;/param&gt;
   &lt;param id="designEnergy" auto="T" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="lineDensity" enabled="T"&gt;1000&lt;/param&gt;
   &lt;param id="orderDiffraction" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="alpha" auto="T" enabled="T"&gt;5.356547628646594&lt;/param&gt;
   &lt;param id="beta" auto="T" enabled="T"&gt;-4.643452371353406&lt;/param&gt;
   &lt;param id="lineSpacing" comment="constant" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter3" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter4" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter5" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="vlsParameter6" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
   &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="lineProfile" comment="unknown" enabled="T"&gt;3&lt;/param&gt;
   &lt;param id="gratingEfficiency" enabled="T"&gt;0.5&lt;/param&gt;
   &lt;param id="blazeAngle" enabled="F"&gt;4&lt;/param&gt;
   &lt;param id="aspectAngle" enabled="F"&gt;90&lt;/param&gt;
   &lt;param id="grooveDepth" enabled="F"&gt;10&lt;/param&gt;
   &lt;param id="grooveRatio" enabled="F"&gt;0.65&lt;/param&gt;
   &lt;param id="reflectivityType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
   &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.3&lt;/param&gt;
   &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;10000.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0933532651278599&lt;/y&gt;
    &lt;z&gt;-0.9956330488136518&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.9956330488136518&lt;/y&gt;
    &lt;z&gt;0.0933532651278599&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
   &lt;param id="profileFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection-zone-plate"><a class="header" href="#reflection-zone-plate">Reflection Zone Plate</a></h1>
<p>Information about RZP</p>
<p>Literature:<br/>
<a href="Model/BeamlineObjects/OpticalElements/uploads/45bc7d1c0044bc7dbf5b65bd126881f5/RehanekJens_2014_Doktorarbeit.pdf">PhD_JensRehanek_2014.pdf</a><br/>
<a href="Model/BeamlineObjects/OpticalElements//docs/src/uploads/0d9a389a4e5f548ec89c174338bccbc6/L%C3%B6chel_Doktorarbeit_3+++.pdf">PhD_HeikeLöchel_2016.pdf</a><br/></p>
<h2 id="tracing-parameter-12"><a class="header" href="#tracing-parameter-12">Tracing Parameter</a></h2>
<p>Mandatory:</p>
<ul>
<li>Reflectivity Type (see more in chapter Optical Elements)</li>
<li>Slope Error</li>
<li>World Position</li>
<li>Misalignment</li>
</ul>
<p>RZP:</p>
<ul>
<li>Fresnel Z Offset</li>
<li>Design Alpha Angle</li>
<li>Design Beta Angle</li>
<li>Design Order Diffraction</li>
<li>Design Energy</li>
<li>Entrance Arm Length Sag</li>
<li>Exit Arm Length Sag</li>
<li>Entrance Arm Length Sag</li>
<li>Exit Arm Length Mer</li>
<li>Order Diffraction</li>
<li>Additional Order</li>
<li>Curvature Type</li>
<li>Long Radius</li>
<li>Image Type</li>
</ul>
<p>Cutout:</p>
<ul>
<li>Geometrical Shape</li>
<li>Total Width</li>
<li>Total Length</li>
</ul>
<h2 id="rml-object-11"><a class="header" href="#rml-object-11">RML Object</a></h2>
<p>If you want to follow a RZP using an RML File, you'll need an XML Object that contains all the RZP details. The default RZP from RAY-UI is available for use. Just remember, tracing only works if you set up a Light Source first. It's a good idea to add an Imageplane Object at the end for clearer results.</p>
<pre><code class="language-XML">  &lt;object name="Reflection Zoneplate" type="Reflection Zoneplate"&gt;
    &lt;param id="geometricalShape" comment="rectangle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="totalWidth" enabled="T"&gt;50&lt;/param&gt;
    &lt;param id="totalLength" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="gratingMount" comment="constant incidence angle" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="grazingIncAngle" auto="T" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="deviationAngle" enabled="F"&gt;170&lt;/param&gt;
    &lt;param id="distancePreceding" enabled="T"&gt;10000&lt;/param&gt;
    &lt;param id="azimuthalAngle" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="elementOffsetZType" comment="manual" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="elementOffsetZ" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="meridionalIncidenceBeamDivergence" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="meridionalIncidenceFocusDistance" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="orderDiffraction" auto="T" enabled="T"&gt;-1&lt;/param&gt;
    &lt;param id="betaDiffraction" auto="T" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="derivationMethod" comment="Formulas" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="coefficientsFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="designEnergy" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="designOrderDiffraction" auto="T" enabled="T"&gt;-1&lt;/param&gt;
    &lt;param id="entranceArmLengthSag" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="entranceArmLengthMer" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="designAlphaAngle" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="exitArmLengthSag" enabled="T"&gt;500&lt;/param&gt;
    &lt;param id="exitArmLengthMer" enabled="T"&gt;500&lt;/param&gt;
    &lt;param id="curvatureType" comment="planar" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="longRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="shortRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="designType" comment="use Fresnel Center Offset" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="FresnelZOffset" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="designBetaAngle" enabled="F"&gt;1&lt;/param&gt;
    &lt;param id="imageType" comment="point to point" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="stretchXdirection" enabled="F"&gt;1&lt;/param&gt;
    &lt;param id="rzpType" comment="elliptical (standard)" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="zDcalc" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="xDcalc" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="Dz" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="Dx" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="refracMethod" comment="2D (new)" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="additionalOrder" comment="off" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="lineProfile" comment="unknown" enabled="T"&gt;3&lt;/param&gt;
    &lt;param id="fullEfficiency" comment="off" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="gratingEfficiency" enabled="T"&gt;0.5&lt;/param&gt;
    &lt;param id="blazeAngle" enabled="F"&gt;4&lt;/param&gt;
    &lt;param id="aspectAngle" enabled="F"&gt;90&lt;/param&gt;
    &lt;param id="grooveDepth" enabled="F"&gt;10&lt;/param&gt;
    &lt;param id="grooveRatio" enabled="F"&gt;0.65&lt;/param&gt;
    &lt;param id="multilayerFourierCoefficients" auto="T" enabled="F"&gt;11&lt;/param&gt;
    &lt;param id="multilayerIntegrationSteps" auto="T" enabled="F"&gt;50&lt;/param&gt;
    &lt;param id="reflectivityType" comment="Derived by Material" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="materialSubstrate" enabled="T"&gt;Au&lt;/param&gt;
    &lt;param id="roughnessSubstrate" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="densitySubstrate" auto="T" enabled="T"&gt;19.3&lt;/param&gt;
    &lt;param id="surfaceCoating" comment="Substrate only" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="numberLayer" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="materialCoating1" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating1" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialCoating2" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessCoating2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityCoating2" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="materialTopLayer" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="thicknessTopLayer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="densityTopLayer" auto="T" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="lateralThicknessGradientCoating1" comment="No" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B1" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B2" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B3" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B4" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B5" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B6" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B7" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="gradientC1B8" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationZerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="profileKind" comment="no Profile" enabled="F"&gt;2&lt;/param&gt;
    &lt;param id="profileFile" relative="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="slopeErrorSag" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="slopeErrorMer" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaX" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="thermalDistortionSigmaZ" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingAmp" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="cylindricalBowingRadius" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;10000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.99984769515639127&lt;/y&gt;
      &lt;z&gt;-0.017452406437283512&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0.017452406437283512&lt;/y&gt;
      &lt;z&gt;0.99984769515639127&lt;/z&gt;
    &lt;/param&gt;
  &lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-sources-1"><a class="header" href="#light-sources-1">Light Sources</a></h1>
<p>Light sources are the starting point for each ray. Here, the properties of the light are set. Depending on user input, the direction, photon energy, and light polarization are determined. This section provides a description of how the light sources are implemented and how to use them for different beamlines. Depending on your needs, it can be useful to understand which light source is most suitable.<br />
The key part of light source implementation in RAYX is the overall distribution of values. Most light sources produce a spectrum of light rays.</p>
<h2 id="implemented-sources"><a class="header" href="#implemented-sources">Implemented Sources</a></h2>
<p>Currently, there are six light sources implemented in RAYX. They are fundamentally different and serve various purposes:</p>
<ul>
<li>Dipole Source</li>
<li>Matrix Source</li>
<li>Point Source</li>
<li>Circle Source</li>
<li>Pixel Source</li>
<li>Simple Undulator Source</li>
</ul>
<p>The Matrix and Point Sources are conceptual sources, whereas the Dipole Source aims to replicate real-world behavior as accurately as possible.</p>
<h2 id="light-properties-1"><a class="header" href="#light-properties-1">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. Each light source has a different approach to determining these, depending on which aspects should be realistic and which should be synthetically generated. The values are almost always in a given distribution window and are randomly generated. This ensures minimal systematic errors impact the ray generation. The user can choose a distribution window and a distribution type.</p>
<p>Parameters:</p>
<ul>
<li>Origin</li>
<li>Direction</li>
<li>Photon Energy</li>
<li>Polarization</li>
</ul>
<h3 id="origin"><a class="header" href="#origin">Origin</a></h3>
<p>The user sets the following parameters:</p>
<ul>
<li>Source width (x-dir)</li>
<li>Source height (y-dir)</li>
<li>Source depth (z-dir)</li>
<li>Distribution types (up to 3 different ones)</li>
</ul>
<p>The origin for each ray is described by x, y, and z values.</p>
<p>With repeatability in mind, the Matrix Source has a fully deterministic approach to setting the origin of each ray. All rays are positioned in a uniform grid within the given width and height. Depending on the number of rays, this grid can appear sparse or fully filled.</p>
<p>The Point Source uses preset distribution types for the positions. Each ray has a random origin, but when considered collectively, they represent the chosen distribution type. Common choices are either hard-edge or soft-edge distributions.</p>
<p>The Dipole Source additionally considers the horizontal divergence and bending radius. The origin positions are in a 3-dimensional curve, representing the trajectory of the electrons in the synchrotron. The positions have a natural distribution that depends on the horizontal divergence of the electron beam.</p>
<h3 id="direction"><a class="header" href="#direction">Direction</a></h3>
<p>The user sets the following parameters:</p>
<ul>
<li>Horizontal divergence (x-dir)</li>
<li>Vertical divergence (y-dir)</li>
<li>Distribution type</li>
</ul>
<p>The direction for each ray is calculated using the phi and psi values, which are the horizontal and vertical angles of the direction. A direction vector is then calculated from these angles and used in the tracing process.</p>
<p>Each source has different directional behaviors, which are detailed in their respective chapters.</p>
<h3 id="energy"><a class="header" href="#energy">Energy</a></h3>
<p>The user sets the following parameters:</p>
<ul>
<li>Photon Energy (mean)</li>
<li>Energy Spread</li>
<li>Distribution type</li>
<li>(File path)</li>
</ul>
<p>Photon energy is understood as the mean energy in a given distribution. If the energy spread is defined as 0, all rays have the same energy.</p>
<p>The energy is equivalent to the wavelength of the light ray. Different distribution types are available for observing the behavior.</p>
<h3 id="polarization"><a class="header" href="#polarization">Polarization</a></h3>
<p>Light polarization impacts the reflective properties of the ray. Depending on the light source, it is either calculated or provided by the user.</p>
<p>For more information on how to implement and use light sources, please refer to the documentation for the specific light source (updated soon).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circle-source"><a class="header" href="#circle-source">Circle Source</a></h1>
<h2 id="light-properties-2"><a class="header" href="#light-properties-2">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. The values are randomly generated according to the given distribution. This ensures that minimal systematic errors impact the simulation.</p>
<p>Light properties include:</p>
<ul>
<li>Origin</li>
<li>Direction</li>
<li>Photon Energy</li>
<li>Polarization</li>
</ul>
<h3 id="origin-1"><a class="header" href="#origin-1">Origin</a></h3>
<p>The origin of each ray is described by its x, y, and z positions.</p>
<h2 id="tracing-parameters"><a class="header" href="#tracing-parameters">Tracing Parameters</a></h2>
<ul>
<li>Source Depth</li>
<li>Source Height</li>
<li>Source Width</li>
<li>Linear Pol 0</li>
<li>Linear Pol 45</li>
<li>Circular Pol</li>
<li>numOfEquidistantCircles</li>
<li>maxOpeningAngle</li>
<li>minOpeningAngle</li>
<li>deltaOpeningAngle</li>
<li>Energy</li>
<li>Energy Spread</li>
<li>Energy Spread Type</li>
<li>Energy Distribution Type</li>
<li>Energy Distribution File</li>
</ul>
<h2 id="rml-object-12"><a class="header" href="#rml-object-12">RML Object</a></h2>
<p>To trace a Circle Source through an RML file, use an XML object to contain all relevant information for the light source. Below is the default configuration for the light source from RAY-UI for your convenience. It is recommended to include an Image Plane at the end for clearer results.</p>
<pre><code class="language-xml">&lt;object name="Circle Source" type="Circle Source"&gt;
   &lt;param id="numberRays" enabled="T"&gt;20000&lt;/param&gt;
   &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
   &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
   &lt;param id="sourceDepth" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="numberCircles" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="maximumOpeningAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="minimumOpeningAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="deltaOpeningAngle" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
&lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dipole-source"><a class="header" href="#dipole-source">Dipole Source</a></h1>
<p>The Dipole Source in RAYX is implemented to generate a realistic light beam. To simulate realistic behavior, the natural spectral and spatial distributions of synchrotron radiation are used as a foundation. Specifically, the distributions defined by the universal function for synchrotron radiation, as outlined by Wiedemann in <em>Synchrotron Radiation</em>, p. 159, are utilized.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Dipole sources are among the most common light sources used to generate synchrotron radiation. In synchrotrons, dipole magnets are used to bend a charged particle beam. Depending on the strength of the magnetic field and other adjustable parameters, bending the particle beam produces X-rays—high-energy photons traveling at relativistic speeds. These photons then travel through the beamline, interacting with optical elements, and eventually reaching an experiment at the end of the line.</p>
<h2 id="light-properties-3"><a class="header" href="#light-properties-3">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. Each light source has a different approach to determining these, depending on which parts should be realistic and which should be synthetically generated. The values are randomly generated for the given distribution, ensuring that minimal systematic errors impact the simulation. The user provides a distribution window for these properties.</p>
<h3 id="origin-2"><a class="header" href="#origin-2">Origin</a></h3>
<p>The origin of each ray is described by its x, y, and z positions. For the dipole source, the position depends on the strength of the dipole magnet. In the coordinate system for the light source, x lies on the horizontal plane with z, while the y direction is "up" and "down" when looking from the source down the beamline (toward the experiment or the next optical element, described by z). The user has limited influence over the distribution of the position, which is primarily determined by the magnetic field and the horizontal divergence window.</p>
<h3 id="direction-1"><a class="header" href="#direction-1">Direction</a></h3>
<p>The direction is determined by the vertical and horizontal angles, based on the user's input for vertical and horizontal divergence. The direction is calculated using two variables: the Phi and Psi angles. Phi is determined randomly with a uniform distribution over the given horizontal divergence. Psi is more complex, depending on the polarization. From the given vertical electron beam divergence, a distribution window is calculated.</p>
<h3 id="energy-1"><a class="header" href="#energy-1">Energy</a></h3>
<p>The photon energy depends on the specified mean energy and the energy spread. The focus of the simulation is the distribution of photon energies among all generated rays. The energy can be understood as equivalent to the wavelength of the photon. For the dipole source, energy is randomly distributed according to the universal function for synchrotron radiation. The basis for this simulation is Helmut Wiedemann’s description in <em>Synchrotron Radiation</em>, p. 259 (D.21), where edge cases simplify the simulation.</p>
<h3 id="polarization-1"><a class="header" href="#polarization-1">Polarization</a></h3>
<p>Light polarization affects the reflective properties of the ray. Polarization is also important for the distribution of the vertical direction of the ray. As described by Helmut Wiedemann (<em>Synchrotron Radiation</em>, p. 155 (9.78)), polarization, direction, and photon energy jointly determine the distribution.</p>
<h2 id="struct-ray"><a class="header" href="#struct-ray">Struct Ray</a></h2>
<p>In RAYX, all the generated information from the light sources is transferred to the optical elements using the <code>Ray</code> structure.</p>
<h2 id="tracing-parameters-1"><a class="header" href="#tracing-parameters-1">Tracing Parameters</a></h2>
<ul>
<li>Energy Distribution</li>
<li>Photon Flux</li>
<li>Electron Energy Orientation</li>
<li>Source Pulse Type</li>
<li>Bending Radius</li>
<li>Electron Energy</li>
<li>Photon Energy</li>
<li>Vertical E-beam Divergence</li>
<li>Energy Spread</li>
<li>Energy Spread Unit</li>
<li>Horizontal Divergence</li>
<li>Source Height</li>
<li>Source Width</li>
<li>Energy</li>
<li>Energy Spread</li>
<li>Energy Spread Type</li>
<li>Energy Distribution Type</li>
<li>Energy Distribution File</li>
</ul>
<h2 id="rml-object-13"><a class="header" href="#rml-object-13">RML Object</a></h2>
<p>To trace a Dipole Source through an RML file, use an XML object to contain all relevant information for the light source. Below is the default configuration for the light source from RAY-UI for your convenience. It is recommended to include an Image Plane at the end for clearer results.</p>
<pre><code class="language-xml">&lt;object name="Dipole Source" type="Dipole Source"&gt;
    &lt;param id="numberRays" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
    &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
    &lt;param id="verEbeamDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="horDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="electronEnergy" enabled="T"&gt;1.7&lt;/param&gt;
    &lt;param id="electronEnergyOrientation" comment="clockwise" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="bendingRadius" enabled="T"&gt;4.35&lt;/param&gt;
    &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
     &lt;x&gt;0.0000000000000000&lt;/x&gt;
     &lt;y&gt;0.0000000000000000&lt;/y&gt;
     &lt;z&gt;0.0000000000000000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
     &lt;x&gt;1.0000000000000000&lt;/x&gt;
     &lt;y&gt;0.0000000000000000&lt;/y&gt;
     &lt;z&gt;0.0000000000000000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
     &lt;x&gt;0.0000000000000000&lt;/x&gt;
     &lt;y&gt;1.0000000000000000&lt;/y&gt;
     &lt;z&gt;0.0000000000000000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
     &lt;x&gt;0.0000000000000000&lt;/x&gt;
     &lt;y&gt;0.0000000000000000&lt;/y&gt;
     &lt;z&gt;1.0000000000000000&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
    &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="energySpreadUnit" comment="eV" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="photonFlux" enabled="T"&gt;2.76089e+12&lt;/param&gt;
&lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix-source"><a class="header" href="#matrix-source">Matrix Source</a></h1>
<h2 id="light-properties-4"><a class="header" href="#light-properties-4">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. The values are randomly generated within the given distribution. This guarantees that minimal systematic errors impact the simulation.</p>
<p>Light properties:</p>
<ul>
<li>Origin</li>
<li>Direction</li>
<li>Photon Energy</li>
<li>Polarization</li>
</ul>
<h3 id="origin-3"><a class="header" href="#origin-3">Origin</a></h3>
<p>The origin for each ray is described by its x, y, and z position.</p>
<h2 id="tracing-parameters-2"><a class="header" href="#tracing-parameters-2">Tracing Parameters</a></h2>
<ul>
<li>Ver Div</li>
<li>Hor Div</li>
<li>Source Depth</li>
<li>Source Height</li>
<li>Source Width</li>
<li>Linear Pol 0</li>
<li>Linear Pol 45</li>
<li>Circular Pol</li>
<li>Energy</li>
<li>Energy Spread</li>
<li>Energy Spread Type</li>
<li>Energy Distribution Type</li>
<li>Energy Distribution File</li>
</ul>
<h2 id="rml-object-14"><a class="header" href="#rml-object-14">RML Object</a></h2>
<p>To trace a <strong>Pixel Source</strong> through an RML file, use an XML object to encompass all pertinent information for the light source. The default configuration for the light source from RAY-UI is presented here for ease of use. It is recommended to include an Imageplane at the end for clearer results.</p>
<pre><code class="language-xml">&lt;object name="Pixel Source" type="Pixel Source"&gt;
   &lt;param id="numberRays" enabled="T"&gt;20000&lt;/param&gt;
   &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
   &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
   &lt;param id="sourceDepth" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="horDiv" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="verDiv" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;1.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
&lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pixel-source"><a class="header" href="#pixel-source">Pixel Source</a></h1>
<h2 id="light-properties-5"><a class="header" href="#light-properties-5">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. The values are randomly generated for the given distribution. This guarantees that minimal systematic errors impact the simulation.</p>
<p>Light properties:</p>
<ul>
<li>Origin</li>
<li>Direction</li>
<li>Photon Energy</li>
<li>Polarization</li>
</ul>
<h3 id="origin-4"><a class="header" href="#origin-4">Origin</a></h3>
<p>The origin for each ray is described by its x, y, and z position.</p>
<h2 id="tracing-parameters-3"><a class="header" href="#tracing-parameters-3">Tracing Parameters</a></h2>
<ul>
<li>Ver Div</li>
<li>Hor Div</li>
<li>Source Depth</li>
<li>Source Height</li>
<li>Source Width</li>
<li>Linear Pol 0</li>
<li>Linear Pol 45</li>
<li>Circular Pol</li>
<li>Energy</li>
<li>Energy Spread</li>
<li>Energy Spread Type</li>
<li>Energy Distribution Type</li>
<li>Energy Distribution File</li>
</ul>
<h2 id="rml-object-15"><a class="header" href="#rml-object-15">RML Object</a></h2>
<p>To trace a <strong>Pixel Source</strong> through an RML file, use an XML object to encompass all pertinent information for the light source. The default configuration for the light source from RAY-UI is presented here for ease of use. It is recommended to include an Imageplane at the end for clearer results.</p>
<pre><code class="language-xml">&lt;object name="Pixel Source" type="Pixel Source"&gt;
   &lt;param id="numberRays" enabled="T"&gt;20000&lt;/param&gt;
   &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
   &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
   &lt;param id="sourceDepth" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="horDiv" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="verDiv" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;1.0000000000000000&lt;/y&gt;
      &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0.0000000000000000&lt;/x&gt;
      &lt;y&gt;0.0000000000000000&lt;/y&gt;
      &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
&lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="point-source"><a class="header" href="#point-source">Point Source</a></h1>
<h2 id="light-properties-6"><a class="header" href="#light-properties-6">Light Properties</a></h2>
<p>In RAYX, every ray is described by four properties. The values are randomly generated within the given distribution to ensure minimal systematic errors during simulation.</p>
<p>Light properties:</p>
<ul>
<li>Origin</li>
<li>Direction</li>
<li>Photon Energy</li>
<li>Polarization</li>
</ul>
<h3 id="origin-5"><a class="header" href="#origin-5">Origin</a></h3>
<p>The origin for each ray is described by its x, y, and z position.</p>
<h2 id="tracing-parameters-4"><a class="header" href="#tracing-parameters-4">Tracing Parameters</a></h2>
<ul>
<li>sourceWidthDistribution</li>
<li>sourceHeightDistribution</li>
<li>horDivDistribution</li>
<li>verDivDistribution</li>
<li>Ver Div</li>
<li>Hor Div</li>
<li>Source Depth</li>
<li>Source Height</li>
<li>Source Width</li>
<li>Linear Pol 0</li>
<li>Linear Pol 45</li>
<li>Circular Pol</li>
<li>Energy</li>
<li>Energy Spread</li>
<li>Energy Spread Type</li>
<li>Energy Distribution Type</li>
<li>Energy Distribution File</li>
</ul>
<h2 id="rml-object-16"><a class="header" href="#rml-object-16">RML Object</a></h2>
<p>To trace a <strong>Point Source</strong> through an RML file, use an XML object to encapsulate all relevant information about the light source. Below is the default configuration for a point source from RAY-UI, which can be used as a template. It is recommended to include an Imageplane at the end for clearer simulation results.</p>
<pre><code class="language-xml">&lt;object name="Point Source" type="Point Source"&gt;
    &lt;param id="numberRays" enabled="T"&gt;200&lt;/param&gt;
    &lt;param id="sourceWidthDistribution" comment="gaussian (sigma)" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="sourceWidth" enabled="T"&gt;0.065&lt;/param&gt;
    &lt;param id="sourceHeightDistribution" comment="gaussian (sigma)" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="sourceHeight" enabled="T"&gt;0.04&lt;/param&gt;
    &lt;param id="sourceDepth" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="horDivDistribution" comment="gaussian (sigma)" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="horDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="verDivDistribution" comment="gaussian (sigma)" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="verDiv" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="alignmentError" comment="Yes" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="translationXerror" enabled="F"&gt;5&lt;/param&gt;
    &lt;param id="translationYerror" enabled="F"&gt;5&lt;/param&gt;
    &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
    &lt;param id="photonEnergy" enabled="T"&gt;151&lt;/param&gt;
    &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="energySpreadUnit" comment="eV" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="energySpread" enabled="T"&gt;6&lt;/param&gt;
    &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
    &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
    &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
    &lt;param id="worldPosition" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldXdirection" enabled="F"&gt;
      &lt;x&gt;1&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldYdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;1&lt;/y&gt;
      &lt;z&gt;0&lt;/z&gt;
    &lt;/param&gt;
    &lt;param id="worldZdirection" enabled="F"&gt;
      &lt;x&gt;0&lt;/x&gt;
      &lt;y&gt;0&lt;/y&gt;
      &lt;z&gt;1&lt;/z&gt;
    &lt;/param&gt;
&lt;/object&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-undulator-source"><a class="header" href="#simple-undulator-source">Simple Undulator Source</a></h1>
<p>The Simple Undulator source in RAYX approximates the physics of a real undulator source, allowing for faster tracing of an undulator light beam. This light source uses <strong>Gaussian Beam Theory</strong>, which simplifies the beam properties significantly. By treating the light beam as a collection of individual rays, complex wave theory can be substituted with approximations.</p>
<p>Simply put, <strong>Gaussian Beam Theory</strong> states that certain beam properties are distributed in Gaussian patterns. These patterns flatten or squeeze after collisions with optical elements, but generally, the beam maintains a Gaussian bell curve shape.</p>
<h2 id="light-properties-7"><a class="header" href="#light-properties-7">Light Properties</a></h2>
<p>In RAYX, every ray is characterized by four properties, which are randomly generated to ensure minimal systematic errors in the simulation:</p>
<ul>
<li><strong>Origin</strong>: Position in x, y, and z coordinates.</li>
<li><strong>Direction</strong>: Direction vector of the ray.</li>
<li><strong>Photon Energy</strong>: Energy of the photon carried by the ray.</li>
<li><strong>Polarization</strong>: Polarization state of the photon.</li>
</ul>
<h3 id="origin-6"><a class="header" href="#origin-6">Origin</a></h3>
<p>The origin for each ray is described by x, y, and z positions.</p>
<h2 id="tracing-parameters-5"><a class="header" href="#tracing-parameters-5">Tracing Parameters</a></h2>
<p>Key parameters used for tracing an undulator source include:</p>
<ul>
<li><strong>sourceDepth</strong>: Depth of the light source.</li>
<li><strong>linearPol0</strong>: Linear polarization at 0 degrees.</li>
<li><strong>linearPol45</strong>: Linear polarization at 45 degrees.</li>
<li><strong>circularPol</strong>: Circular polarization.</li>
<li><strong>undulatorLength</strong>: Length of the undulator.</li>
<li><strong>photonEnergy</strong>: Energy of the photons.</li>
<li><strong>sigmaType</strong>: Type of sigma (distribution type).</li>
<li><strong>electronSigmaX</strong>: Horizontal electron beam size.</li>
<li><strong>electronSigmaXs</strong>: Horizontal electron beam divergence.</li>
<li><strong>electronSigmaY</strong>: Vertical electron beam size.</li>
<li><strong>electronSigmaYs</strong>: Vertical electron beam divergence.</li>
<li><strong>Energy</strong>: Photon energy level.</li>
<li><strong>Energy Spread</strong>: Spread in energy.</li>
<li><strong>Energy Spread Type</strong>: Type of energy spread (e.g., white band).</li>
<li><strong>Energy Distribution Type</strong>: Distribution type of the photon energy.</li>
<li><strong>Energy Distribution File</strong>: File used to define energy distribution.</li>
</ul>
<h2 id="rml-object-17"><a class="header" href="#rml-object-17">RML Object</a></h2>
<p>To trace a Simple Undulator Source using an RML file, you can define the source in an XML format. The default configuration from RAY-UI is provided here, which can be customized for your specific needs. It is advisable to include an Imageplane at the end for more accurate results.</p>
<pre><code class="language-xml">&lt;object name="Simple Undulator" type="Simple Undulator"&gt;
   &lt;param id="numberRays" enabled="T"&gt;20000&lt;/param&gt;
   &lt;param id="sigmaType" comment="standard" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="undulatorLength" enabled="T"&gt;4&lt;/param&gt;
   &lt;param id="electronDistributionType" comment="manual" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="electronSigmaX" enabled="T"&gt;216&lt;/param&gt;
   &lt;param id="electronSigmaXs" enabled="T"&gt;24.8&lt;/param&gt;
   &lt;param id="electronSigmaY" enabled="T"&gt;18.7&lt;/param&gt;
   &lt;param id="electronSigmaYs" enabled="T"&gt;4.3&lt;/param&gt;
   &lt;param id="sourceDepth" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="alignmentError" comment="No" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="translationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="translationZerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationXerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="rotationYerror" enabled="F"&gt;0&lt;/param&gt;
   &lt;param id="worldPosition" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="worldXdirection" enabled="F"&gt;
    &lt;x&gt;1.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/x&gt;
   &lt;/param&gt;
   &lt;param id="worldYdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;1.0000000000000000&lt;/y&gt;
    &lt;z&gt;0.0000000000000000&lt;/x&gt;
   &lt;/param&gt;
   &lt;param id="worldZdirection" enabled="F"&gt;
    &lt;x&gt;0.0000000000000000&lt;/x&gt;
    &lt;y&gt;0.0000000000000000&lt;/y&gt;
    &lt;z&gt;1.0000000000000000&lt;/z&gt;
   &lt;/param&gt;
   &lt;param id="energyDistributionType" comment="Values" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="photonEnergyDistributionFile" absolute="" enabled="F"&gt;&lt;/param&gt;
   &lt;param id="photonEnergy" enabled="T"&gt;100&lt;/param&gt;
   &lt;param id="energySpreadType" comment="white band" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="energySpreadUnit" comment="eV" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="energySpread" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="linearPol_0" enabled="T"&gt;1&lt;/param&gt;
   &lt;param id="linearPol_45" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="circularPol" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseType" comment="all rays start simultaneously" enabled="T"&gt;0&lt;/param&gt;
   &lt;param id="sourcePulseLength" enabled="F"&gt;0&lt;/param&gt;
&lt;/object&gt;
</code></pre>
<h2 id="literature-1"><a class="header" href="#literature-1">Literature</a></h2>
<p>[1] Representation of a Gaussian Beam by Rays, P. P. Crooker, W. B. Colson, and J. Blau, Physics Department, Naval Postgraduate School, Monterey, California. Published 2006.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beamline-parameter"><a class="header" href="#beamline-parameter">Beamline Parameter</a></h1>
<p>This table explains all the parameters that can be used in a RAYX beamline.
They are ordered for Elements and Sources and roughly in their order of importance.</p>
<h2 id="light-source-parameter"><a class="header" href="#light-source-parameter">Light Source Parameter</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Number of Rays</td><td>Number of rays emitted from the source</td></tr>
<tr><td>Source Width</td><td>Width of the light source in millimeters</td></tr>
<tr><td>Source Height</td><td>Height of the light source in millimeters</td></tr>
<tr><td>Source Depth</td><td>Depth of the light source in millimeters</td></tr>
<tr><td>Horizontal Divergence</td><td>Horizontal angular spread of the rays</td></tr>
<tr><td>Vertical Divergence</td><td>Vertical angular spread of the rays</td></tr>
<tr><td>Source Width Distribution</td><td>Distribution type for source width</td></tr>
<tr><td>Source Height Distribution</td><td>Distribution type for source height</td></tr>
<tr><td>Horizontal Divergence Distribution</td><td>Distribution type for horizontal divergence</td></tr>
<tr><td>Vertical Divergence Distribution</td><td>Distribution type for vertical divergence</td></tr>
<tr><td>Linear Pol 0</td><td>Degree of linear polarization at 0 degrees</td></tr>
<tr><td>Linear Pol 45</td><td>Degree of linear polarization at 45 degrees</td></tr>
<tr><td>Circular Pol</td><td>Degree of circular polarization</td></tr>
<tr><td>Energy Distribution Type</td><td>How the nergy distribution should be defined (e.g. Values, File)</td></tr>
<tr><td>Energy Spread Type</td><td>Distribution pattern for the Energy (e.g Gaussian)</td></tr>
<tr><td>Energy Spread</td><td>Spread of energy around the central photon energy</td></tr>
<tr><td>Photon Energy Distribution File</td><td>Filepath for .DAT- File with Energy distribution information</td></tr>
<tr><td>Photon Energy</td><td>Central photon energy</td></tr>
<tr><td>Separate Energies</td><td>Number of seperate energy spikes</td></tr>
<tr><td>Electron Energy Orientation</td><td>Movement in the Synchrotron (clockwise, counter-clockwise)</td></tr>
<tr><td>Source Pulse Type</td><td>(unused)</td></tr>
<tr><td>Vertical E-beam Divergence</td><td>Vertical divergence of the electron beam</td></tr>
<tr><td>Bending Radius</td><td>Bending radius of the electron bunch in a bending magnet</td></tr>
<tr><td>Electron Energy</td><td>Energy of the electrons in the source</td></tr>
<tr><td>Alignment Error</td><td>Possible misalignment of the source</td></tr>
<tr><td>Photon Flux</td><td>--</td></tr>
<tr><td>Photon Energy</td><td>Central photon energy of the source</td></tr>
<tr><td>Energy Spread</td><td>Energy spread around the central energy</td></tr>
<tr><td>Energy Spread Unit</td><td>Unit for energy spread (eV)</td></tr>
<tr><td>Number of Equidistant Circles</td><td>--</td></tr>
<tr><td>Maximum Opening Angle</td><td>Maximum divergence angle for the rays</td></tr>
<tr><td>Minimum Opening Angle</td><td>Minimum divergence angle for the rays</td></tr>
<tr><td>Delta Opening Angle</td><td>--</td></tr>
<tr><td>Parameter P</td><td>--</td></tr>
<tr><td>Parameter P Type</td><td>--</td></tr>
<tr><td>Sigma Type</td><td>--</td></tr>
<tr><td>Undulator Length</td><td>--</td></tr>
<tr><td>Electron Sigma X</td><td>Horizontal electron beam size</td></tr>
<tr><td>Electron Sigma Xs</td><td>Horizontal electron beam divergence</td></tr>
<tr><td>Electron Sigma Y</td><td>Vertical electron beam size</td></tr>
<tr><td>Electron Sigma Ys</td><td>Vertical electron beam divergence</td></tr>
</tbody></table>
</div>
<h2 id="optical-element-parameter"><a class="header" href="#optical-element-parameter">Optical Element Parameter</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>World Position</td><td>3D coordinates of the optical element's position</td></tr>
<tr><td>Total Width</td><td>Width of the optical element</td></tr>
<tr><td>Total Length</td><td>Length of the optical element</td></tr>
<tr><td>Total Height</td><td>Height of the optical element</td></tr>
<tr><td>Grazing Incidence Angle</td><td>Angle of incidence for grazing rays</td></tr>
<tr><td>Arm Length</td><td>Length of the arm of the optical element</td></tr>
<tr><td>Entrance Arm Length</td><td>Length of the entrance arm</td></tr>
<tr><td>Exit Arm Length</td><td>Length of the exit arm</td></tr>
<tr><td>Entrance Arm Length (Mer)</td><td>Meridional entrance arm length</td></tr>
<tr><td>Exit Arm Length (Mer)</td><td>Meridional exit arm length</td></tr>
<tr><td>Entrance Arm Length (Sag)</td><td>Sagittal entrance arm length</td></tr>
<tr><td>Exit Arm Length (Sag)</td><td>Sagittal exit arm length</td></tr>
<tr><td>Central Beamstop</td><td>Stop placed in the center of the beam</td></tr>
<tr><td>Total Width Stop</td><td>Width of the beamstop</td></tr>
<tr><td>Total Height Stop</td><td>Height of the beamstop</td></tr>
<tr><td>Opening Width</td><td>Width of the optical element opening</td></tr>
<tr><td>Opening Height</td><td>Height of the optical element opening</td></tr>
<tr><td>Opening Shape</td><td>Shape of the optical element opening (e.g., rectangle, circle)</td></tr>
<tr><td>Grating Mount</td><td>--</td></tr>
<tr><td>Radius</td><td>Radius of curvature for curved surfaces</td></tr>
<tr><td>Design Energy</td><td>Target design energy for the optical element</td></tr>
<tr><td>Line Density</td><td>--</td></tr>
<tr><td>Order of Diffraction</td><td>Diffraction order for grating elements</td></tr>
<tr><td>Design Energy Mounting</td><td>--</td></tr>
<tr><td>Design Order of Diffraction</td><td>--</td></tr>
<tr><td>Design Alpha Angle</td><td>--</td></tr>
<tr><td>Design Beta Angle</td><td>--</td></tr>
<tr><td>Short Radius</td><td>Short radius for elliptical elements</td></tr>
<tr><td>Long Radius</td><td>Long radius for elliptical elements</td></tr>
<tr><td>Fresnel Z Offset</td><td>--</td></tr>
<tr><td>Bending Radius Direction</td><td>--</td></tr>
<tr><td>Parameter A11</td><td>--</td></tr>
<tr><td>Design Grazing Inc Angle</td><td>Grazing incidence angle in design</td></tr>
<tr><td>Long Half Axis A</td><td>Long half-axis for elliptical elements</td></tr>
<tr><td>Short Half Axis B</td><td>Short half-axis for elliptical elements</td></tr>
<tr><td>Figure Rotation</td><td>--</td></tr>
<tr><td>Distance Preceding</td><td>Distance from preceding element</td></tr>
<tr><td>Misalignment Coordinate System</td><td>Coordinate system for misalignment</td></tr>
<tr><td>Reflectivity Type</td><td>Type of reflectivity used</td></tr>
<tr><td>Material Substrate</td><td>Material of the substrate</td></tr>
<tr><td>Geometrical Shape</td><td>Shape of the optical element</td></tr>
<tr><td>Image Type</td><td>Type of image plane</td></tr>
<tr><td>Azimuthal Angle</td><td>Azimuthal angle of rotation</td></tr>
<tr><td>Additional Order</td><td>--</td></tr>
<tr><td>Slope Error</td><td>Slope error for reflecting surfaces</td></tr>
<tr><td>Slope Error Sag</td><td>Sagittal slope error</td></tr>
<tr><td>Slope Error Mer</td><td>Meridional slope error</td></tr>
<tr><td>Thermal Distortion Amp</td><td>Amplitude of thermal distortion</td></tr>
<tr><td>Thermal Distortion Sigma X</td><td>Sigma in X for thermal distortion</td></tr>
<tr><td>Thermal Distortion Sigma Z</td><td>Sigma in Z for thermal distortion</td></tr>
<tr><td>Cylindrical Bowing Amp</td><td>Amplitude of cylindrical bowing</td></tr>
<tr><td>Cylindrical Bowing Radius</td><td>Radius for cylindrical bowing</td></tr>
<tr><td>VLS Parameter</td><td>--</td></tr>
<tr><td>Reflectivity Type</td><td>Type of reflectivity coating</td></tr>
<tr><td>Material Substrate</td><td>Substrate material for reflecting surfaces</td></tr>
<tr><td>Roughness Substrate</td><td>Surface roughness of the substrate</td></tr>
<tr><td>Density Substrate</td><td>Density of the substrate material</td></tr>
<tr><td>Surface Coating</td><td>Coating material for the optical surface</td></tr>
<tr><td>Coating File</td><td>External file for custom coating</td></tr>
<tr><td>Number Layer</td><td>Number of layers in multilayer coatings</td></tr>
<tr><td>Material Coating 1</td><td>Material of the first coating layer</td></tr>
<tr><td>Thickness Coating 1</td><td>Thickness of the first coating layer</td></tr>
<tr><td>Roughness Coating 1</td><td>Roughness of the first coating layer</td></tr>
<tr><td>Density Coating 1</td><td>Density of the first coating layer</td></tr>
<tr><td>Material Coating 2</td><td>Material of the second coating layer</td></tr>
<tr><td>Thickness Coating 2</td><td>Thickness of the second coating layer</td></tr>
<tr><td>Roughness Coating 2</td><td>Roughness of the second coating layer</td></tr>
<tr><td>Density Coating 2</td><td>Density of the second coating layer</td></tr>
<tr><td>Material Top Layer</td><td>Material of the top layer coating</td></tr>
<tr><td>Thickness Top Layer</td><td>Thickness of the top layer coating</td></tr>
<tr><td>Roughness Top Layer</td><td>Roughness of the top layer coating</td></tr>
<tr><td>Density Top Layer</td><td>Density of the top layer coating</td></tr>
<tr><td>Lattice Spacing × 2</td><td>Twice the lattice spacing (2d) of the crystal (in nm)</td></tr>
<tr><td>Unit Cell Volume</td><td>Volume of the crystal's unit cell (in nm³)</td></tr>
<tr><td>Structure Factor F₀</td><td>Real and imaginary parts of the forward scattering factor</td></tr>
<tr><td>Structure Factor F_H</td><td>Real and imaginary parts of the Bragg-reflected structure factor</td></tr>
<tr><td>Structure Factor F_H̄</td><td>Real and imaginary parts of the conjugate reflected factor</td></tr>
<tr><td>Offset Angle α</td><td>Crystal surface tilt relative to atomic planes (in radians)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="user-vs-model-parameter"><a class="header" href="#user-vs-model-parameter">User vs Model Parameter</a></h1>
<p>In RAYX we intend to work on better modularity and readability in our code. In our opinion, one step to achieve this, to reevaluate and restructure the parameters of RAY-UI. Since a lot of the parameters had dependencies on each other, we decided that a distinction between them was needed. This is where our definition of User and Model Parameters comes into play.</p>
<h2 id="model-parameter"><a class="header" href="#model-parameter">Model Parameter</a></h2>
<p>A Model Parameter is any parameter that is directly influencing the calculations of the tracer. Further, a Model Parameter can also be a parameter, which is required for the fundamental definition of our model.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The position and direction Matrix are not directly used in the calculations of the Tracer, but they still are Model Parameters, since they are essential in directly defining our model.</p>
<h2 id="user-parameters"><a class="header" href="#user-parameters">User Parameters</a></h2>
<p>User Parameters are all the parameters that are only used to calculate Model Parameters. They only exist to improve the user experience of our application and are neither passed directly to the tracer nor are needed to define our model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-generation"><a class="header" href="#ray-generation">Ray Generation</a></h1>
<p>Rays are described in tree-dimensional space with an origin and a direction.
The origin are described with a three dimensional vector. However, the direction can be interpreted as the cosines of two angles \(\phi\) and \(\psi\). Since the z-axis is the direction of the center ray, the direction of all other rays can be described as the angle between ray direction vector and z-y-plane (horizontal divergence \(\phi\)) and between vector and z-x-plane (vertical divergence \(\psi\)).
See also <a href="https://it-ed-git.basisit.de/RAY/RAY/-/wikis/uploads/bdcf4515e03b2fccf462c5f0d76052c3/Paper_Schaefers_RAY_Springer_2007.pdf">documentation</a> p.18,19.</p>
<p>\[
ray = \begin{bmatrix}
x_s \\ y_s \\ z_s
\end{bmatrix} + t
\begin{bmatrix}
l_S \\ m_S \\ n_S
\end{bmatrix}
= \begin{bmatrix}
x_s \\ y_s \\ z_s
\end{bmatrix} + t
\begin{bmatrix}
sin \phi_S \cdot cos \psi_S \\ cos \psi_S \\ cos \psi_S \cdot cos \phi_S
\end{bmatrix}
\]</p>
<p>When the ray is created in the light source, its origin and direction angles are chosen randomly.</p>
<h2 id="light-sources-point-source"><a class="header" href="#light-sources-point-source">Light sources: Point source</a></h2>
<p>The user sets the following parameters:</p>
<ul>
<li>number of rays</li>
<li>source dimensions width(x-dir), height(y-dir) and depth(z-dir)</li>
<li>horizontal and vertical divergence</li>
</ul>
<p>The intensity distribution in the lightsource is understood as the probability distribution of the parameters position and angle.
The parameters \(x\), \(y\) and \(z\) of position and the angles \(\phi\) and \(\psi\) are chosen randomly but according to a probability distribution. Uniformly distributed random numbers within the range \([0,1]\) are obtained by FORTRAN's <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.0/gfortran/RANDOM_005fNUMBER.html">random_number</a> function.
There are two options for the probability distribution in the light source:
soft edge (Gaussian) and hard edge (uniformly).
Afterwards, some predefined offset can be added to each component.</p>
<h3 id="hard-edge"><a class="header" href="#hard-edge">Hard edge</a></h3>
<p>The hard edge option is the simpler one since the random numbers are already uniformly distributed. Thus, the ray parameters \(x\), \(y\), \(z\), \(\phi\), \(\psi\) are chosen uniformly within the given extent (width, height, divergence..) of the point source by calculating a random number \(u\), subtracting 0.5 such that the number ranges in \([-0.5,+0.5]\) and multiplying with the given width/height/depth or horizontal/vertical extent of the point source.</p>
<p>\(x_S = (u_x - 0.5) \cdot width\) <br>
\(y_S = (u_y - 0.5) \cdot height\) <br>
\(z_S = (u_z - 0.5) \cdot depth\) <br>
\(\phi_S = (u_\phi - 0.5) \cdot hor. div\) <br>
\(\psi_S = (u_\psi - 0.5) \cdot vert. div\) <br></p>
<p>Thus, the x-coordinate of the origin, for example, lies within \([-\frac{width}{2}, +\frac{width}{2}]\) and is picked uniformly.</p>
<h3 id="soft-edge"><a class="header" href="#soft-edge">Soft edge</a></h3>
<p>(See also <a href="https://it-ed-git.basisit.de/RAY/RAY/-/wikis/uploads/bdcf4515e03b2fccf462c5f0d76052c3/Paper_Schaefers_RAY_Springer_2007.pdf">documentation</a> p.14)</p>
<p>For the soft edge we have to transform the uniform distribution to a Gaussian distribution with \(\mu = 0\) and \(\sigma = extent\). The resulting values for a specific ray are not bound by the input parameters as for the hard edge. Instead, the more they deviate from \(\mu\) the more rare they are.</p>
<h4 id="in-fortran-code"><a class="header" href="#in-fortran-code">In FORTRAN code</a></h4>
<p>The old implementation uses the following apporach:</p>
<ol>
<li>create two random numbers \(u_1,u_2\) from a uniform distribution in \([0,1]\)</li>
<li>\(x =(u_1 - 0.5 ) \cdot \sigma \cdot 9\)</li>
<li>\(wx =  \exp(\frac{-x^2}{2})\)</li>
<li>\(dif = wx-u_2\)</li>
<li>\(wx\) is the value of the densitiy function \(f(x)\) of the distribution with \(\mu=0\) and \(\sigma\). If \(wx &lt; u_2\), then repeat from step 1 (keep \(x\) with probability \(f(x)\))</li>
<li>else keep \(x\)</li>
</ol>
<p>Here, 9 is used as a factor for \(\sigma\), since the Gaussian distribution is defined from \(-\infty\) to \(+\infty\) but a confidence interval \([-4.5 \sigma, +4.5 \sigma]\) contains already more than 99.99%.</p>
<p>\(w(x_s)\) lies in \([0,1]\). It is \(1\) for \(x_s = 0\) and becomes smaller the more \(x_s\) deviates from \(0\) according to the gaussian bell curve.
Since \(w(x_s)\) is the probability that \(x_s\) occurs in our gaussian distribution, we want to use \(x_s\) for the origin of the ray with a probability of \(w(x_s)\). Thus, we get a second random number \(u_x'\) from FORTRAN's random_number function and if \(u_x' \leq w(x_s)\) holds we use \(x_S\) for the ray. Otherwise, \(x_S\) is discarded and re-calculated with a new random number \(u_x\). Thereby, we use \(x_S\) with a probability that corresponds to the Gaussian distribution.</p>
<p>However, this is not very efficient as a lot of rays are thrown away. The following method uses a different approach which - although some values are discarded as well - is more efficient and creates two values in one iteration instead of one (<a href="https://www.desy.de/~sschmitt/blobel/eBuch.pdf">more here</a> Section 5.5.2):</p>
<h4 id="more-efficiently"><a class="header" href="#more-efficiently">More efficiently:</a></h4>
<ol>
<li>create two random numbers \(u_1, u_2\) from a uniform distribution in \([0,1]\)</li>
<li>calculate \(x_1 = 2u_1-1\) and \(x_2 = 2u_2 -1\)</li>
<li>calculate  \(r^2 = x_1^2 + x_2^2r^2\)</li>
<li>if \(r^2 &gt; 1\) repeat from step 1</li>
<li>else calculate
\(z_1 = x_1 \cdot \sqrt{-2\frac{\ln{r^2}}{r^2}} \cdot \sigma\) and
\(z_2 = x_2 \cdot \sqrt{-2\frac{\ln{r^2}}{r^2}} \cdot \sigma\)</li>
</ol>
<p>Now \(z_1\) and \(z_2\) are distributed according to the Gaussian distribution with \(\mu = 0\) and \(\sigma = extent\) as defined by the user.</p>
<p>This calculation is faster since we get 2 values instead of 1.
(In python the first method took twice as long as this method to create the same amount of values)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pseudo-random-number-generators-prngs-on-the-gpu"><a class="header" href="#pseudo-random-number-generators-prngs-on-the-gpu">Pseudo Random Number Generators (PRNGs) on the GPU</a></h1>
<p>For RAYX we found a good and performant pseudo random number generator after some research. We cannot use default C++ options as they are not supported by our Shader code. We decided to use Squares RNG, which is counter based and utilizes a version of the Middle Square Weyl Sequence. We tested the method with the TestU01 bigcrush test with different seeds and it passed all of them.</p>
<p>We added a few more methods for creating random numbers with more variety. These methods are:</p>
<ul>
<li><code>uint64_t squares64RNG(inout uint64_t ctr)</code>, which generates 64-Bit random integers from two 32-Bit random integers</li>
<li><code>double squaresDoubleRNG(inout uint64_t ctr)</code>, which generates uniformly distributed doubles between 0 and 1 from one 64-Bit random integer</li>
<li><code>double squaresNormalRNG(inout uint64_t ctr, double mu, double sigma)</code>, which creates (via the Box-Muller transform) a normal distributed double with mean <code>mu</code> and standard deviation <code>sigma</code>. This takes three random doulbes, which takes six 32-Bit integers.</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://arxiv.org/pdf/2004.06278.pdf">Squares: A Fast Counter-Based RNG</a></li>
<li><a href="https://www.iro.umontreal.ca/~lecuyer/myftp/papers/testu01.pdf">TestU01: A C Library for Empirical Testing of
Random Number Generators</a></li>
<li><a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform?oldformat=true">Box–Muller transform</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transformation-between-coordinate-systems"><a class="header" href="#transformation-between-coordinate-systems">Transformation between coordinate systems</a></h1>
<h2 id="how-to-calculate-world-coordinates"><a class="header" href="#how-to-calculate-world-coordinates">How to calculate World Coordinates</a></h2>
<p>This explains how to get world coordinates (global position and orientation of an optical element) from the sequential setup of a beamline that is often used, where the position and orientation of an element is described with distances and rotations relative to its predecesor.</p>
<p>First a small introduction to rotation matrices which is not super relevant for the transformations but might help to visualize the rotations and understand why some angles are positive and others negative.</p>
<details><summary>Rotation Matrices</summary>
<h3 id="rotation-matrices"><a class="header" href="#rotation-matrices">Rotation matrices</a></h3>
<p>A rotation through an angle \(\theta\) can either be active or passive.
An active rotation around for example the z-axis through the angle \(\theta\) rotates the point within the coordinate system. Thereby, the coordinates of the point are changed whereas the coordinate system is left unchanged. When looking along the rotation axis in a right-handed coordinate system towards the origin, the rotation direction is counter-clockwise.</p>
<p>\[
R_a({\theta}) =
\begin{bmatrix}
\cos(\theta) &amp; -\sin(\theta) &amp; 0 \\
\sin(\theta) &amp; \cos(\theta) &amp; \\
0           &amp; 0         &amp; 1
\end{bmatrix}
\]</p>
<p>A passive rotation leaves the position of the vector unchanged and rotates the axes of the coordinate system relative to the vector i.e. rotates the basis vectors (change of basis). When looking along the rotation-axis towards the origin in a right-handed coordinate system, the rotation of the rotating axes is clockwise. Thus, it is defined as an active rotation (applied to the basis vectors) in the other direction i.e. through the negative angle (\(\cos(-\theta) = \cos(\theta)\) and \(-\sin(\theta) = \sin(-\theta))\):</p>
<p>\[<br />
R_p({\theta}) = \begin{bmatrix}
\cos(\theta) &amp; \sin(\theta) &amp; 0 \\
-\sin(\theta) &amp; \cos(\theta) &amp;  \\
0           &amp; 0         &amp; 1
\end{bmatrix} = \begin{bmatrix}
\cos(-\theta) &amp; -\sin(-\theta) &amp; 0 \\
\sin(-\theta) &amp; \cos(-\theta) &amp;  \\
0           &amp; 0         &amp; 1
\end{bmatrix}
\]</p>
<p>The relation between axes and the position of the point are the same after each of the rotations: After the passive rotation the basis vectors are different and the vector coordinates stay the same whereas after the active rotation the vector coordinates are different but the basis vectors are the same.</p>
<p>Example for active (left) and passive (right) rotation through \(\alpha=25^\circ\):
<img src="Model//docs/src/uploads/7eb17510a7f200d4ce89ed337e0a4eda/rotation_active_vs_passive.PNG" alt="active_passive" />
The relative position of the vector to the axes is the same after each rotation.
See also <a href="https://en.wikipedia.org/wiki/Active_and_passive_transformation">active vs passive transformation</a></p>
<p>However, active and passive are in our case only an <em>interpretation</em> of the rotations that makes sense when looking at the beamline from a global point of view. Globally seen, the local coordinate system of each optical element is rotated and translated differently with respect to a global coordinate system whereas the vectors (the rays) only change by e.g. reflection when interacting with an element.
Thus, we have coordinate systems for optical elements, that are identical for each element in the sense that the y-axis is the normal and the x-z-plane is the tangent plane of the surface at the origin, and for rays where the center ray is the z-axis and a global system. The transformation between the systems is implemented by rotating and translating the vectors within the same coordinate system.
\(\rightarrow\) In the implementation only the vectors are transformed by active transformations and the axes of the coordinate system stay the same, although in the "real world", the beams remain unchanged and only the coordinate system is rotated around them.</p>
</details>
<p>The following sections describe how to calculate the transformation matrices from beam coordinates to element coordinates and again to (new) beam coordinates based on the given distance and angles in the sequential setup.
This is relevant for RAYX if you need to calculate the world coordinates from the user parameters that describe the sequential setup yourself and cannot directly use the world coordinates from the rml file:</p>
<details><summary>Positioning of elements in sequential setup</summary>
<p>In the RAY-UI rays are represented in a beam coordinate system. In that system the main ray always points from the origin towards the z-axis wheras the individual rays have slight deviations in their direction and origin.</p>
<p>Elements are represented in an element coordinate system.
The elements are mostly located in the x-z-plane of their coordinate system. The y-axis is the normal in the center of the element (Visualized in the <a href="https://it-ed-git.basisit.de/RAY/RAY/-/wikis/uploads/bdcf4515e03b2fccf462c5f0d76052c3/Paper_Schaefers_RAY_Springer_2007.pdf">documentation</a>).</p>
<p>In order to calculate the intersection point with the "quad" function, we first need to transfer the incoming rays from beam coordinates to the object coordinates. The relation between these system is defined by two angles \(\alpha\) and \(\chi\) and a translation by \(z_0\). The transformation affects the position and direction of the ray.</p>
<ol>
<li>
<p>the offset \(z_0\) describes the distance between the previous element or the source and the current optical element.</p>
</li>
<li>
<p>the main ray should have a specific incidence angle \(\alpha\) (angle between main ray and x-z-plane of the optical element). This rotation is counter-clockwise around the x-axis:</p>
</li>
</ol>
<p>\[
R_x({\alpha}) = \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos(\alpha) &amp; -\sin(\alpha) \\
0 &amp; \sin(\alpha) &amp; \cos(\alpha)
\end{bmatrix}
\]</p>
<details><summary>Side note</summary>
Side note for visualization: An example for this rotation interpreted as an [active](/docs/src/uploads/33a69b81f3f7c491842bcdeda4ca97b7/incidence_angle_active.PNG) and as a [passive](/docs/src/uploads/5ab2555382dc2b2ef10a9864aaee0224/incidence_angle_passive.PNG) rotation of the main ray (z-axis) and a ray \\(v\\) through the grazing incidence angle \\(\alpha=25°\\). The first coordinate system shows the incoming ray in the ray-coordinate system. In the second one the rays/the axes are rotated through \\(\alpha\\) such that the rays lie in the element-coordinate system. In the third image the reflection is calculated. Finally, in the last image, the reflected ray/the axes are rotated to the new ray-coordinate system.
Since we are using a right-handed coordinate system, the x-axis points into the image and the rotations that appear to be clockwise are actually counter-clockwise around the x-axis.
</details>
<ol start="3">
<li>The second rotation through angle \(\chi\) around the z-axis tilts the optical element such that the ray is not reflected upwards (\(\chi=0°\)) but to the right (\(\chi=90°\)), downwards (\(\chi=180°\)) or to the left (\(\chi=270°\)). This is a clockwise rotation. Thus, we rotate through \(-\chi\) when \(\chi\) is given.</li>
</ol>
<p>After tracing we need to transform the ray back to the beam coordinate system. Therefore we rotate back around \(\chi\) and then rotate around the exit angle \(\beta\) All these parameters are given as "user" parameters. The following section describes how to calculate beam-element and element-beam transformation matrices.</p>
</details>
<details><summary>Calculating transformation matrices between elements in sequential setup</summary>
<h5 id="beam-to-element"><a class="header" href="#beam-to-element">Beam to Element</a></h5>
<ol>
<li>
<p>Translation by \(z_0\) in z direction = distance to preceeding element</p>
</li>
<li>
<p>Rotation by azimuthal angle \(\chi\) around z-axis.</p>
</li>
</ol>
<p>\[
R_z(-\chi) = \begin{bmatrix} \cos(-\chi) &amp; -\sin(-\chi) &amp; 0 \\
\sin(-\chi) &amp; \cos(-\chi) &amp; 0 \\
0 &amp; 0 &amp; 1 \end{bmatrix} =
\begin{bmatrix} \cos(\chi) &amp; \sin(\chi) &amp; 0 \\
-\sin(\chi) &amp; \cos(\chi) &amp; 0 \\
0 &amp; 0 &amp; 1 \end{bmatrix}
\]</p>
<ol start="3">
<li>Rotation through grazing incidence angle \(\alpha\) around x-axis. Sometimes, the normal incidence angle with \(90°-\alpha\) is given. Then, it has to be converted to the grazing incidence angle \(\alpha\).<br></li>
</ol>
<p>\[
R_x(\alpha) = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\
0 &amp; \cos(\alpha) &amp; -\sin(\alpha) \\
0 &amp; \sin(\alpha) &amp; \cos(\alpha) \end{bmatrix}
\]</p>
<p>Putting it all together this is an affine transformation and can be written in homogeneous coordinates as one single matrix:</p>
<p>\[
\begin{align*}
M_{b2e} &amp;= R_{x}(\alpha) R_z(-\chi) T_z(z_0) \\
M_{b2e} &amp;= \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos(\alpha) &amp; -\sin(\alpha) &amp; 0 \\ 0 &amp; \sin(\alpha) &amp; \cos(\alpha) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} \cos(\chi) &amp; \sin(\chi) &amp; 0 &amp; 0\\ -\sin(\chi) &amp; \cos(\chi) &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; -z_0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \\
&amp;= \begin{bmatrix} \cos(\chi) &amp; \sin(\chi) &amp; 0 &amp; 0 \\
-\sin(\chi)\cos(\alpha) &amp; \cos(\chi)\cos(\alpha) &amp; -\sin(\alpha) &amp; z_0 \sin(\alpha) \\
-\sin(\chi) \sin(\alpha) &amp; \sin(\alpha)\cos(\chi) &amp; \cos(\alpha) &amp; -z_0 \cos(\alpha) \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
\end{align*}
\]</p>
<h5 id="element-to-beam"><a class="header" href="#element-to-beam">Element to Beam</a></h5>
<p>After the interaction with the element, the reflected ray \(x_R\) is transformed back to a beam coordinate system. The rotations around the axes are applied in reverse order.</p>
<ol>
<li>Rotation through gracing exit angle \(\beta\) around x-axis. We do not need to rotate back through \(\alpha\) but keep rotating in the same direction since the new z-axis should point in the direction of the reflected and not of the incoming main ray. E.g. \(\beta\) is the same as \(\alpha\) for mirrors.<br></li>
</ol>
<p>\[
R_x(\beta) = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\
0 &amp; \cos(\beta) &amp; -\sin(\beta) \\ 0 &amp; \sin(\beta) &amp; \cos(\beta) \end{bmatrix}
\]</p>
<ol start="2">
<li>Rotation back through \(\chi\).<br></li>
</ol>
<p>\[
R_z(\chi) = R_z^{-1}(-\chi) = \begin{bmatrix} \cos(\chi) &amp; -\sin(\chi) &amp; 0 \\
\sin(\chi) &amp; \cos(\chi) &amp; 0 \\
0 &amp; 0 &amp; 1 \end{bmatrix}
\]</p>
<p>In homogeneous coordinates:</p>
<p>\[
\begin{align*}
M_{e2b} &amp;= R_z(\chi)R_{x}(\beta) \\
M_{e2b} &amp;= \begin{bmatrix} \cos(\chi) &amp; -\sin(\chi) &amp; 0 &amp; 0\\
\sin(\chi) &amp; \cos(\chi) &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot  \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos(\beta) &amp; -\sin(\beta) &amp; 0 \\ 0 &amp; \sin(\beta) &amp; \cos(\beta) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\\
&amp;= \begin{bmatrix} \cos(\chi) &amp; -\sin(\chi) \cos(\beta) &amp; \sin(\chi)\sin(\beta) &amp; 0 \\
\sin(\chi) &amp; \cos(\chi)\cos(\beta) &amp; -\cos(\chi)\sin(\beta) &amp; 0 \\
0 &amp; \sin(\beta) &amp; \cos(\beta) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
\end{align*}
\]</p>
<p>(Since there is no translation a 3x3 matrix would suffice)</p>
<h3 id="misalignment"><a class="header" href="#misalignment">Misalignment</a></h3>
<p>Misalignment is used when the optical element does not lie exactly where it should after applying the beam to element matrix. Therefore some rotation or translation might be necessary before the intersection point can be calculated.</p>
<p>The misalignment transformation matrix \(M_{mis}\) is simply derived from the user parameters \(d_x\), \(d_y\), \(d_z\), \(d_{\phi}\), \(d_{\psi}\), \(d_{\chi}\). It can be calculated by spliting into a transformation matrix (from \(d_x\), \(d_y\), \(d_z\)) and multiplying with a rotation matrix (from \(d_{\phi}\), \(-d_{\psi}\), \(d_{\chi}\)):</p>
<p>\[
\begin{align*}
M_{mis} &amp;= T_{x,y,z} R_{\phi, -\psi, \chi} \\
&amp;= \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -d_x\\
0 &amp; 1 &amp; 0 &amp; -d_y\\
0 &amp; 0 &amp; 1 &amp; -d_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot R^x_{-\psi} \cdot R^y_{\phi} \cdot R^z_{\chi}
\end{align*}
\]</p>
<p>where e.g. \(R^x_{\psi}\) is the 4x4 homogeneous rotation matrix through \(\psi\) around the x-axis.</p>
<p>The inverse misalignment matrix is then calculated as follows:</p>
<p>\[
\begin{align*}
M_{mis}^{-1} &amp;= R_{-\psi, \phi, \chi}^{-1} \cdot T_{x,y,z}^{-1}\\
&amp;= (R^x_{-\psi} \cdot R^y_{\phi} \cdot R^z_{\chi}) ^{T} \cdot
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; d_x \\
0 &amp; 1 &amp; 0 &amp; d_y \\
0 &amp; 0 &amp; 1 &amp; d_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align*}
\]</p>
<p>Since rotation matrices are orthogonal, the inverse of \((R^x_{-\psi} R^y_{\phi} R^z_{\chi})\) is the same as the transpose. The inverse of the translation matrix is the same but with negative offsets.</p>
<p>\(M_{mis}\), \(M_{mis}^{-1}\) are multiplied with \(M_{b/g2e}\) and \(M_{e2g/b}\), respectively, to form the final transformation matrices which could be given to the shader if we would still use the sequential approach in RAYX. However, we use a global coordinate system instead of the beam coordinate system but don't worry you didn't just read all of that for nothing, it will be important in the derivation of the transformation from global to element coordinates and back.</p>
</details>
<p>The next section describes how to replace the beam coordinate system that is used in the sequential approach with the global coordinate system and how to calculate the position and orientation.</p>
<details><summary>Sequential to world coordinates</summary>
<p>As explained in the previous sections, there is no global coordinate system in the sequential implementation but instead rays are transformed from beam coordinate system to element coordinate system and back to a different beam coordinate system such that the z-axis of the beam coordinate system always follows the main ray, which means that the main ray with \(pos=(0,0,0)\), \(dir=(0,0,1)\) in beam coordinates is always the same after each interaction with an optical element.</p>
<p>In a global coordinate system this is different. The origin of the system is the (first) source. When the main ray hits the first element, it is transformed into the element's coordinate system, traced (e.g. reflected) and transformed back into the global coordinate system. Then it does no longer have the values \(pos=(0,0,0)\) and \(dir=(0,0,1)\). To achieve this for the first element (i=1) in the beamline, we can still use \(M_{b2e}\) that we defined previously \((M_{g2e}^{-1} = M_{b2e}^{-1})\) since for the first element the global coordinate system is the same as the beam coordinate system of the incoming rays (bc the source is in \((0,0,0)\) which is the origin of both the global coord system and the initial beam coord. system). However, we need a different element to global coordinate system transformation for this elemet \(M_{g2e}^{-1} \neq M_{b2e}^1\) and of course also for all following elements. Moreover, for all following elements we also need a different \(M_{g2e}^i \neq M_{b2e}^i\) for \(i&gt;1\).</p>
<h3 id="transformation-matrices-from-position-and-orientation"><a class="header" href="#transformation-matrices-from-position-and-orientation">Transformation matrices from position and orientation</a></h3>
<p>global coordinates are sometimes given by the user directly via e.g. an rml file, which stores the global orientation as a 3x3 matrix and the position as a 3 element vector. Expanding both to homogeneous 4x4 rotation/translation matrices makes it possible to calculate \(M_{g2e}\) and \(M_{e2g}\) by multiplying them.
For the case that the beamline was still build sequentially, it was decided to first build the global position and orientation from \(\alpha\), \(\beta\), \(\chi\), the distance \(z_0\) and the misalignment and then derive the matrices \(M_{g2e}\) and \(M_{e2g}\)  in the same way.</p>
<p>The following calculations can be used for all optical elements. For the ellipsoid, however, the misalignment can be defined in the coordinate system of the mirror or of the curvation. The usual misalignment is in the coordinate system of the mirror. The coordinate system of the curvation differs by a rotation through the tangent angle \(\theta\) around the x-axis. This angle depends on the shape of the ellipsoid. Depending on the coordinate system, we add the rotation \(T_x(\theta)\) (in red), for all other elements this is irrelevant so \(\theta = 0\).</p>
<p>As mentioned before, in the case that the element is the first in the beamline, it is simply placed at a certain distance on the z-axis. Therefore, the position (pos) is, in homogeneous coordinates:</p>
<p>\[
pos^0 = \begin{bmatrix} 0 \\ 0 \\ z_0^0 \\ 1 \end{bmatrix} + or^0 \cdot \color{red}{R_x^0(\theta)} \cdot \color{black}{\begin{bmatrix} d_x^0 \\ d_y^0 \\ d_z^0 \\ 1 \end{bmatrix}}
\]</p>
<p>where or is the orientation of the element and \(d_x\), \(d_y\), \(d_z\) are the positional misalignment.
The orientation of the first element is calculated as follow:</p>
<p>\[
or^0 = R_x^0(\alpha) R_z^0(-\chi) \cdot \color{red}{R_x^0(\theta)} \cdot \color{black}{R_{\phi, -\psi, \chi}^0} \cdot \color{red}{R_x^0(\theta)^T}
\]</p>
<p>where \(R_{\phi -\psi \chi}\) contains the orientational misalignment and \(R_x(\alpha) R_z(-\chi)\) is the rotational part of \(M_{b2e}\) (without the translation by \(z_0\) since the distance is not part of the orientation but of the position)</p>
<p>When the element is not the first in the beamline, we need in addition to the ususal parameters of this element (\(\alpha\), \(\beta\), \(\chi\), the distance \(z_0\) and the misalignment) also the global position and orientation and the \(M_{e2b}\) matrix of the previous element. Unfortunately, we also have to remove the misalignment from the global position of the previous element (equation 1), then we can add the distance from the previous to new element to the position of the previous element following the direction of the outgoing ray (2). Finally, we can add the positional misalignment of element i to the position (3).</p>
<p>\[
\begin{align}
pos^{(i-1)} &amp;= pos^{i-1} - or^{i-1} \cdot \color{red}{R_x^{i-1}(\theta)} \cdot \color{black}{\begin{bmatrix} d_x^{i-1} \\ d_y^{i-1} \\ d_z^{i-1} \\ 1 \end{bmatrix}} \\
pos^i &amp;= pos^{i-1} - or^{i-1} \cdot R_x^{i-1}(\theta) \cdot \begin{bmatrix} 0 \\ 0 \\ z_0^i \\ 1 \end{bmatrix} \\
pos^i &amp;= pos^i + or^{i} \cdot \color{red}{R_x^{i}(\theta)} \cdot \color{black}{\begin{bmatrix} d_x^i \\ d_y^i \\ d_z^i \\ 1 \end{bmatrix}}
\end{align}
\]</p>
<p>The calculation of the orientation of the ith element is a bit simpler. The global orientation of element i is the global orientation of the previous element \((or^{i-1})\) without the rotational misalignment (1) multiplied with the rotation of the new element coordinate system with respect to the previous element coordinate system \((M_{e2b}, \text{eq 2})\) multiplied with the orientation of the new element in its own element coordinate system (which is calculated in the same way as for the first element: local orientation \(\cdot\) misalignment, eq. 3):</p>
<p>\[
\begin{align}
or^{(i-1)} &amp;= or^{i-1} \cdot \color{red}{R_x^{i-1}(\theta)^T} \cdot \color{black}{(R_{\phi, -\psi, \chi}^{i-1})^{T}} \cdot \color{red}{R_x^{i-1}(\theta)} \\
or^i &amp;= or^{(i-1)} \cdot M_{e2b}^{i-1} \\
or^i &amp;= or^i \cdot (R_x^i(\alpha) R_z^i(-\chi) \cdot \color{red}{R_x^i(\theta)} \cdot \color{black}{R_{\phi, -\psi, \chi}^i} \color{red}{R_x^i(\theta)^T})
\end{align}
\]</p>
<p>These calculations are done in WorldUserParams.cpp. They have been tested but still there might be some mistake in there, so feel free to question the calculations if something is not working.</p>
</details>
<p>Once you have the global position and orientation, you can derive the Transformation matrices by expanding the position p to a homogeneous translation matrix and the orientation to a homogeneous rotation matrix:</p>
<p>\[
M_{g2e} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -p_x \\
0 &amp; 1 &amp; 0 &amp; -p_y \\
0 &amp; 0 &amp; 1 &amp; -p_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \cdot or
\]
\[
M_{e2g} = M_{g2e}^{-1} = or^T \cdot \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; p_x \\
0 &amp; 1 &amp; 0 &amp; p_y \\
0 &amp; 0 &amp; 1 &amp; p_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quadric-function"><a class="header" href="#quadric-function">Quad(ric) Function</a></h1>
<p>Function for calculating the intersection of a ray with the surface of an optical element in 3-dimensional space.</p>
<h3 id="input"><a class="header" href="#input">Input:</a></h3>
<ul>
<li>16 parameters \(a_{11}\) to \(a_{44}\) to define the surface in 3D space with the general equation for second order surfaces. Parameter values for specific surfaces can be found in the <a href="https://it-ed-git.basisit.de/RAY/RAY/-/wikis/uploads/bdcf4515e03b2fccf462c5f0d76052c3/Paper_Schaefers_RAY_Springer_2007.pdf">documentation</a>.</li>
<li>\(ray = \begin{bmatrix} x_{S'} \\ y_{S'} \\z_{S'} \\ \end{bmatrix} + t \begin{bmatrix} l_{S'} \\ m_{S'}\\ n_{S'} \\ \end{bmatrix}\)</li>
<li>weight/III (set to 0(python)/-4(Fortran) if ray missed surface, unchanged otherwise)</li>
<li>icurv: determines the sign in the formula for calculating \(t\), if negative first intersection point, if positive second intersection point.</li>
</ul>
<h3 id="output"><a class="header" href="#output">Output:</a></h3>
<ul>
<li>modified ray</li>
<li>normal at intersection point</li>
<li>weight/III</li>
</ul>
<h3 id="calculation-of-intersection-point"><a class="header" href="#calculation-of-intersection-point">Calculation of intersection point</a></h3>
<p>general equation for second order surfaces:
\[F(x,y,z) = a_{11}x^2 + a_{22}y^2 + a_{33}z^2 + 2a_{12}xy + 2a_{13}xz + 2a_{23}yz + 2a_{14}x + 2a_{24}y + 2a_{34}z + a_{44}\]</p>
<p>The intersection is determined by inserting the x, y and z-coordinates of the ray in $F(x,y,z)$ and set to zero: <br>
\[F(x_{S'}+t \cdot l_{S'} ,y_{S'}+t \cdot m_{S'}, z_{S'}+t \cdot n_{S'}) = 0\]</p>
<p>We obtain a quadratic equation of the form \(0 = a \cdot t^2 + b \cdot t + c\) with variable \(t\) and the following coefficients:</p>
<p>\[
\begin{align*}
a &amp;= a_{11}l_{S'}^2 + a_{22}m_{S'}^2 + a_{33}n_{S'}^2 + 2a_{13}l_{S'}n_{S'} + 2a_{12}l_{S'}m_{S'} + 2a_{23}m_{S'}n_{S'} \\
b &amp;= 2a_{11}x_{S'}l_{S'} + 2a_{22}y_{S'}m_{S'} + 2a_{33}z_{S'}n_{S'} \\
&amp;+ 2a_{12}y_{S'}l_{S'} + 2a_{12}x_{S'}m_{S'}
+ 2a_{13}z_{S'}l_{S'} + 2a_{13}x_{S'}n_{S'} \\
&amp;+ 2a_{23}z_{S'}m_{S'} + 2a_{23}y_{S'}n_{S'}
+ 2a_{14}l_{S'} + 2a_{24}m_{S'} + 2a_{34}n_{S'} \\
c &amp;= a_{11}x_{S'}^2 + a_{22}y_{S'}^2 + a_{33}z_{S'}^2 + 2a_{12}x_{S'}y_{S'} + 2a_{13}x_{S'}z_{S'} + 2a_{23}y_{S'}z_{S'} \\
&amp;+ 2a_{14}x_{S'} + 2a_{24}y_{S'} + 2a_{34}z_{S'} + a_{44}
\end{align*}
\]</p>
<p>Since a, b and c can simply be calculated, we could solve the equation directly with  \(t = \frac{-b+ICURV \cdot \sqrt{b^2-4ac}}{2a}\) and use \(t\) to find the intersection point. If ICURV is negative, we get the first intersection point with the object (smaller \(t\)). If ICURV is positive we get the second intersection point from when the ray exits the element (larger \(t\)). Some optimizations are applied to this formula in the code. Depending on the largest component in the direction of the ray, it is normalized in x, y or z direction to simplify the ray equation. Thus, there are three cases.</p>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<p>Assume \(l_{S'} \geq m_{S'}\) and \(l_{S'} \geq n_{S'}\) (first case). Then, we can divide the direction by \(l_{S'}\), such that it is normalized in x and the y- and z-coordinates are within \([-1,1]\) (I). Moreover, we can translate the origin of the ray along the direction vector towards the origin of the coordinate system until the y-z-plane is hit \((x=0, II)\). Then, we end up with a normalized ray (III), where \(x=t\).</p>
<p>\[
\begin{align*}
ray
&amp;\overset{\text{I}}{=} \begin{bmatrix} x_{S'} \\ y_{S'} \\z_{S'} \\ \end{bmatrix} + t \begin{bmatrix} 1 \\ m_{S'}/l_{S'}\\ n_{S'}/l_{S'} \\ \end{bmatrix} \\
&amp;\overset{\text{II}}{=} \begin{bmatrix} x_{S'}-1\cdot x_{S'} \\ y_{S'} - (m_{S'}/l_{S'}) \cdot y_{S'} \\z_{S'} - (n_{S'}/l_{S'}) \cdot z_{S'} \\ \end{bmatrix} + t \begin{bmatrix} 1 \\ m_{S'}/l_{S'}\\ n_{S'}/l_{S'} \\ \end{bmatrix} \\
&amp;\overset{\text{III}}{=} \begin{bmatrix} 0 \\ y \\ z \end{bmatrix} + t \begin{bmatrix} 1 \\ a_{ml} \\ a_{nl} \\ \end{bmatrix}
\end{align*}
\]</p>
<p>When we plug this parameterization of the ray into \(F(x,y,z)=0\), some terms in a, b and c are removed (see code).</p>
<p>Since every term in b contains the factor 2, the equation for calculating t can be simplified:
\[
t = \frac{-2\frac{b}{2} +ICURV \cdot \sqrt{(2\frac{b}{2})^2 - 4ac}}{2a} \\ = \frac{-2\frac{b}{2} +ICURV \cdot 2\sqrt{(\frac{b}{2})^2 - ac}}{2a} \\ = \frac{-\frac{b}{2} +ICURV \cdot \sqrt{(\frac{b}{2})^2 - ac}}{a}
\]</p>
<p>In the code the factor 2 is left out of the equation for \(b\) from the beginning. Thus, what is called \(b\) in the code is actually \(\frac{b}{2}\).</p>
<p>If the term in the root is negative there is no intersection and weight is set to 0 (or III to -4 in fortran).
Otherwise it is checked whether the factor a is much smaller than \(c\). Then, the divisor is very small or zero which can cause problems with the division. In that case, \(a \cdot t^2\) is removed from the quadratic equation \(a \cdot t^2 + b \cdot t + c\) which thus yields \(t=x=- \frac{c}{b}\) or \(t=x= \frac{c}{2b}\) in the code since the factor \(2\) is excluded from \(b\) (<a href="https://www.cs.uaf.edu/2012/spring/cs481/section/0/lecture/01_26_ray_intersections.html">see also</a> (Ray Quadric Intersection)).
If \(a\) is not much smaller than \(c\), \(t\) is calculated with the simplified equation above. Subsequently, \(t (=x)\) is plugged into the modified ray equation and the intersection point is calculated.</p>
<p>The other two cases for when \(y\) or \(z\) are the largest component of the direction of the ray are similar.</p>
<p>The partial derivatives of \(F(x,y,z)\) form the normal vector \(f_{x,y,z}\) of the surface. Inserting the calculated intersection point into the normal vector yields the normal of the surface at this specific point. The intersection point is set to be the new origin of the ray. The ray direction \((l_{S'},m_{S'},n_{S'})\) remains unchanged.</p>
<h3 id="general-equation-for-second-order-surfaces"><a class="header" href="#general-equation-for-second-order-surfaces">General equation for second order surfaces</a></h3>
<p>The equation can describe the surface of several elements in a similar way as a circle with radius 1 can be described in 2D as \(x^2 + y^2 -1 = 0\). Elements that can be described by this general equation include sphere, ellipsoid, plane, cone, cylinder, paraboloid. These are so called quadric surfaces. Surfaces that cannot be described by any quadratic function include for example the torus.
The equation refers to a right-handed coordinate system with the center of the optical element in the origin. The element's surface is the x-z-plane and the y-axis is the normal vector.</p>
<p>\[
\begin{align*}
F(x,y,z) &amp;= \vec{x}^TA\vec{x} \\
\vec{x} = \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}
A &amp;= \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\
a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44}
\end{bmatrix} \\
a_{ij} = a_{ji} &amp;\Rightarrow A^T = A
\end{align*}
\]</p>
<p>Literature: <br>
<a href="https://en.wikipedia.org/wiki/Quadric">https://en.wikipedia.org/wiki/Quadric</a> <br>
<a href="https://www.win.tue.nl/~sterk/Bouwkunde/2db60-chap3.pdf">https://www.win.tue.nl/~sterk/Bouwkunde/2db60-chap3.pdf</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h1>
<p>wiki for efficiency calculations</p>
<h3 id="snells-law"><a class="header" href="#snells-law">Snell's law</a></h3>
<p>A fraction of the light is reflected and another transmitted:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/89/Fresnel1.svg" alt="refraction_fresnel" /><br>
\(\theta_i =\)  (normal) incidence angle <br>
\(\theta_r =\) (normal) reflection angle (same as \(\theta_i\))<br>
\(\theta_t =\) (normal) transmittance angle <br>
\(N_1 =\) refraction index of material from which the ray is coming  (left in image)<br>
\(N_2 =\) refraction index of material into which the ray is going (right in image)<br></p>
<p>all parameters are potentially complex numbers. The refractive indices are retrieved from files (Palik, Henke, Cromer..)</p>
<p>Snell's law:
\[
N_1 \sin \theta_i = N_2 \sin \theta_t \rightarrow \sin \theta_t = \frac{N_1}{N_2} \sin \theta_i
\]</p>
<p>\(\theta_i\), \(N_1\), \(N_2\) are known, we are looking for \(\theta_t\).  <br>
We do not calculate the angle specifically but only the cosinus, which is sufficient for further calculations and more efficient/precise than calculating the angle itself because we do not need to use more trigonometric functions.
We can calculate the incidence angle \(\theta_i\) of each ray from its direction and the surface normal. Then we calculate \(\cos(\theta_i)\) and from that we can derive \(\cos(\theta_t)\) with snell's law:</p>
<p>\[
(\sin \theta_i)^2 = 1 - (\cos \theta_i)^2 \\
(\sin \theta_t)^2 = (\frac{N_1}{N_2})^2 (\sin \theta_i)^2 \\
\cos \theta_t = \sqrt{1 - (\sin \theta_t)^2} = \sqrt{1 - \Big(\frac{N_1}{N_2} \sin \theta_i\Big)^2}
\]</p>
<p>The cosine of both angles is then used in the Fresnel equations to calculate the s- and p-polarization</p>
<h3 id="fresnel-equation"><a class="header" href="#fresnel-equation">Fresnel equation</a></h3>
<p>Any polarization state can be described by two components: one vertical and one horizontal. Or - relative to the plane of incidence - s- and p-polarization.
p-polarization (parallel, left image) lies parallel in the plane of incidence and s-polarization (senkrecht, right image) is orthogonal to the plane of incidence.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Polarisation_p.png" alt="ppol" width="200"/>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/3c/Polarisation_s.png" alt="spol" width="200"/>
<p>the reflectance of both polarizations is calculated with the fresnel equations:</p>
<p>\[r_s = \frac{N_1 \cdot \cos \theta_i - N_2 \cdot \cos \theta_t}{N_1 \cdot \cos \theta_i + N_2 \cdot \cos \theta_t}\]
\[r_p = \frac{N_2 \cdot \cos \theta_i - N_1 \cdot \cos \theta_t}{N_2 \cdot \cos \theta_i + N_1 \cdot \cos \theta_t}\]</p>
<p>(The transmitted power is then "the rest": \(t_s = 1 - r_s\) and \(t_p = 1 -r_p\))</p>
<h3 id="multilayer-reflection"><a class="header" href="#multilayer-reflection">Multilayer Reflection</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>When the tracing process is finished, our Tracer does not only return the final state of the rays;
additionally it provides us with a sequence of events - expressing what happened to each ray individually.
This allows us to fully understand what happened to each ray, and potentially where in the beamline it diverged from our expectations.</p>
<p>Each of these events contains a "snapshot" of the ray at that point in time,
and information about what happened at this point (encoded as an "EventType").</p>
<p>Some typical events include (for more, see the Doxygen documentation):</p>
<ul>
<li>Just hit: The ray did just intersect with an element.</li>
<li>Fly off: The ray did not hit any more elements and instead it will now fly in the same direction forever.</li>
<li>Absorbed: The ray was absorbed by the element.</li>
</ul>
<p>Some EventTypes "finalize" the corresponding ray, preventing it from being processed further.
Examples for this are "Fly Off" and "Absorbed".</p>
<p>For more details see the Shared/EventType.h file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>In this section, you can read up on all the tools used to develop RAYX.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-code-coverage"><a class="header" href="#what-is-code-coverage">What is Code Coverage:</a></h1>
<p>Analyzing your code Coverage is a necessary step in devloping complex big projects.</p>
<p>Getting the code's coverage is simply generating a summary of how much a piece of code is executed and "covered".</p>
<p>Code Coverage offers line, function, and branch analysis.</p>
<p>Generally, the most reasonable method is to check how much code your Testsuites cover.</p>
<h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<p><em>Please Note: This has only been tested on UNIX System (Ubuntu)</em></p>
<p>Code Coverage is supported by GNU GCC and LLVM. Make sure that one of these build tools is installed. Gcov, lcov and genhtml are packages that are also needed. For more information, you can check the usage of gcov (GCC) <a href="https://gcc.gnu.org/onlinedocs">here</a>.</p>
<p>You can also use gcovr as an alternative to gcov.</p>
<h1 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h1>
<p>Code Coverage only works if the main function returns 0. (The Test Suite returns 0 if all testcases pass).</p>
<p>The test suite should run only in DEBUG Mode and with all optimizations turned off "-O0" for Coverage. Warnings will pop if not.</p>
<p>With the correct gcov and -fdump added to <code>CXX_COMPILER_FLAGS</code>, running the Testsuite will generate <code>*.gcno</code> and <code>*.gch</code> files meant for lcov. The file generation and flags are handled by a CMAKE submodule. An <code>*.info</code> file is then created and transformed afterwards to interactable <code>index.html</code> page on the web browser. Configuration information on the CMAKE Output window show up as the submodule defaults to verbose.</p>
<h1 id="how-to-enable"><a class="header" href="#how-to-enable">How to enable</a></h1>
<h2 id="visual-stuido-code"><a class="header" href="#visual-stuido-code">Visual Stuido Code</a></h2>
<ul>
<li>Uncomment the code under <code>#CodeCoverage</code> in the CMakeLists.txt on the project's root directory, to set the option <code>BUILD_WITH_GCOV</code>.</li>
<li>(Optional) You can also build with <code>DBUILD_WITH_GCOV</code> instead of last step.</li>
<li>Make sure to choose RAYX_tst as target in Debug Mode.</li>
<li>Once ran, <code>cd build</code> and run:</li>
</ul>
<p><code>lcov --capture --directory . --output-file coverage.info</code></p>
<p><code>genhtml coverage.info --output-directory coverage</code></p>
<ul>
<li>A new file in <code>build/</code> called coverage, with and <code>index.html</code> can be opened to see Code Coverage.</li>
</ul>
<h2 id="jetbrains-clion"><a class="header" href="#jetbrains-clion">JetBrains Clion</a></h2>
<ul>
<li>Chose the Google Test "RAYX_tst | Debug-Coverage" as configuration, if first time doing this you should only see "RAYX_tst | Debug " as option, chose that instead.</li>
<li>Near the <strong>Run</strong> button, you should see "Run "RAYX_tst" with Coverage".</li>
<li>If configration is missing, let CLion handle the creation of a new Cmake configuration.</li>
<li>Once all testsuites are successfuly ran, a dialog box  of the Line, Branch coverages pops out. Notice also the colors in the editor.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Rayx uses a number of languages but mainly C++ and GLSL.</p>
<h1 id="debugging-the-applications-c"><a class="header" href="#debugging-the-applications-c">Debugging the application's C++</a></h1>
<p>If you are using VS Code, you may create a new Debugging Setting to launch rayx through gdb. <a href="https://code.visualstudio.com/Docs/editor/debugging">More here</a></p>
<p>Once the setting file (launch.json) is ready, you can change and add arguments for VSCode/gdb to parse.</p>
<ul>
<li>set "program" : "${workspaceFolder}/build/bin/TerminalApp" (For TerminalApp)</li>
<li>set "args" : [arg1,arg2 etc.] (keep arguments between " " )</li>
<li>set "cwd" : "${workspaceFolder}/build/bin/"</li>
</ul>
<p>If you are familiar with gdb, add more commands in setupCommands, eg. Disassembly Flavor for Intel</p>
<h1 id="debugging-the-applications-vulkan-and-glsl"><a class="header" href="#debugging-the-applications-vulkan-and-glsl">Debugging the application's Vulkan and GLSL</a></h1>
<p>The shader language (GLSL) does not offer live debugging and stepping with gdb or similar. If you run the CPU Tracer then you can step through the code as it was compiled into C code, since it's only running on the CPU. However when using Vulkan a few more steps needs attention.</p>
<p>Vulkan offers a debug extension layer that can be activated with the combination of vkconfig to launch the application in debug mode.</p>
<ol>
<li>
<p>We need <code>#extension GL_EXT_debug_printf : enable</code> in the shader file.</p>
</li>
<li>
<p>We also need to add <code>VK_KHR_shader_non_semantic_info</code> as in extension in the Vulkan Instance.</p>
</li>
<li>
<p>Launch the application with <strong>vkconfig</strong> and chose the <strong>Debug Printf Preset</strong> in <em>VK_LAYER_KHRONOS_validation</em>. (Vkconfig should be packaged with Vulkan-SDK)</p>
</li>
<li>
<p>Make sure to increase <strong>Printf buffer size</strong> under <strong>Debug Printf</strong> if you get a Validation Layer Warning.</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KhronosGroup/Vulkan-ValidationLayers/master/docs/images/vkconfig_setup.png" alt="screenshot" title="Khronos Github screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-doxygen"><a class="header" href="#how-to-use-doxygen">How to use Doxygen</a></h1>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Doxygen: http://www.doxygen.nl/download.html#srcbin</li>
<li>(GraphViz: https://graphviz.gitlab.io/download/) \(\leftarrow\) at the moment not needed</li>
</ul>
<p>Note GraphViz installation: On windows you can install graphviz via MSYS2 since you might already have it to build the project. Simply call: pacman -S mingw-w64-x86_64-graphviz in the MSYS2 commandline window. The DOT_PATH muust then be set to {MSYS2}/mingw64/bin</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<ol>
<li>Open the Doxyfile in Intern/rayx-core/doc/ with Doxywizard</li>
<li>Under Wizard-&gt;Diagrams check "Use dot tool from the GraphViz package"</li>
<li>Change the DOT_PATH in "Expert \(\rightarrow\) Dot" to the bin-directory in your GraphViz-Folder (where you installed it). This is usually the doxygen/bin folder.</li>
<li>Click on the "Run"-tab and click "Run doxygen" (this will take a while, depending on your cpu performance)</li>
<li>After completion click "Show HTML output" in the Doxywizard or open the Index.html in Intern/rayx-core/doc/html/</li>
</ol>
<h2 id="class-diagram"><a class="header" href="#class-diagram">Class Diagram</a></h2>
<p>A generated Class Diagram can be found under "Classes-&gt;Class Hierarchy"</p>
<h2 id="generating-documentation-with-gpt-4-35-not-recommended"><a class="header" href="#generating-documentation-with-gpt-4-35-not-recommended">Generating documentation with GPT-4 (3.5 not recommended)</a></h2>
<p>Use this prompt and replace the header and cpp code in the lower part with your code.
Note: The first code is example code for ChatGPT so it knows the style. Do not replace it. Just replace the lower code after "Create a documentation for this header file:" and "Create a documentation for this cpp file:"</p>
<h3 id="important"><a class="header" href="#important">Important:</a></h3>
<p>Read and check all generated content. ChatGPT can easily make errors and assumptions. It is only a tool to save time writing text. The information needs to be approved by the developer.</p>
<p>Prompt:</p>
<pre><code>I need to create a doxygen documentation for some code I wrote. You will help me with that. The comments in the header file should include the information what the function does/is for. In the cpp file, it's how the function is implemented. This is a good example how it should be:

.h
/**
 * @brief Triangulates optical elements for rendering.
 * @param elements A vector of optical elements to be triangulated.
 * @param useMarchinCubes Flag to determine if Marching Cubes triangulation should be used.
 * @return A vector of RenderObject, which are the triangulated version of the input elements.
 */
std::vector&lt;RenderObject&gt; triangulateObjects(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements, bool useMarchinCubes = false);

/**
 * @brief Generates visual representations of rays based on bundle history and optical elements.
 * @param bundleHist RAYX-Core type, providing details of ray interactions in the beamline.
 * @param elements A vector of optical elements used for coordinate conversions.
 * @return A vector of lines, which visually represents the paths of rays in the beamline.
 */
std::vector&lt;Line&gt; getRays(const RAYX::BundleHistory&amp; bundleHist, const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements);

.cpp
/**
 * This function processes the BundleHistory and determines the ray's path in the beamline.
 * Depending on the event type associated with the ray, the function produces visual lines that represent
 * ray segments, colored based on the event type.
 */
std::vector&lt;Line&gt; getRays(const RAYX::BundleHistory&amp; bundleHist, const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements) {
    std::vector&lt;Line&gt; rays;

    for (const auto&amp; rayHist : bundleHist) {
        glm::vec3 rayLastPos = {0.0f, 0.0f, 0.0f};
        for (const auto&amp; event : rayHist) {
            if (event.m_eventType == ETYPE_JUST_HIT_ELEM || event.m_eventType == ETYPE_ABSORBED) {
                // Events where rays hit objects are in element coordinates
                // We need to convert them to world coordinates
                glm::vec4 worldPos = elements[(size_t)event.m_lastElement].m_element.m_outTrans * glm::vec4(event.m_position, 1.0f);

                Vertex origin = {{rayLastPos.x, rayLastPos.y, rayLastPos.z, 1.0f}, YELLOW};
                Vertex point = (event.m_eventType == ETYPE_JUST_HIT_ELEM) ? Vertex(worldPos, ORANGE) : Vertex(worldPos, RED);

                rays.push_back(Line(origin, point));
                rayLastPos = point.pos;
            } else if (event.m_eventType == ETYPE_FLY_OFF) {
                // Fly off events are in world coordinates
                // The origin here is the position of the event
                // The point is defined by the direction of the ray (default length)

                glm::vec4 eventPos = glm::vec4(event.m_position, 1.0f);
                glm::vec4 eventDir = glm::vec4(event.m_direction, 0.0f);
                glm::vec4 pointPos = eventPos + eventDir * 1000.0f;

                Vertex origin = {eventPos, GREY};
                Vertex point = {pointPos, GREY};

                rays.push_back(Line(origin, point));
            }
        }
    }

    return rays;
}

Create a documentation for this header file:

// Marching Cubes
std::vector&lt;RenderObject&gt; marchingCubeTriangulation(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements);
std::vector&lt;Triangle&gt; trianglesFromQuadric(const double* quadric, Cutout cutout);  // TODO: make nicer

glm::vec3 getPositionAtCorner(int cornerIndex);
Vertex interpolateVertex(int edgeIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY, int offsetZ,
                         glm::vec3 scale);
double evaluateQuadricAtPosition(const double surface[16], const glm::vec4&amp; pos);
int determineMarchingCubesCase(const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int x, int y, int z);
std::vector&lt;Triangle&gt; lookupTrianglesForCase(int caseIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY,
                                             int offsetZ, glm::vec3 scale);
Vertex getVertexFromEdge(int edgeIndex);
double getScalarValueAtCorner(int x, int y, int z, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE]);

// Marching Cubes
const int edgeTable[256] = {...}
const int triTable[256][16] = {...}

Create a documentation for this cpp file:
#include "MarchingCubes.h"

#include "Colors.h"
#include "Debug/Debug.h"

namespace RAYX {
namespace CPU_TRACER {
bool RAYX_API inCutout(Cutout cutout, double x1, double x2);
}  // namespace CPU_TRACER
}  // namespace RAYX

std::vector&lt;RenderObject&gt; marchingCubeTriangulation(const std::vector&lt;RAYX::OpticalElement&gt;&amp; elements) {
    std::vector&lt;RenderObject&gt; objects;

    for (RAYX::OpticalElement element : elements) {
        auto quadric = element.m_element.m_surface.m_params;
        std::vector&lt;Triangle&gt; triangles = trianglesFromQuadric(quadric, element.m_element.m_cutout);
        RenderObject object(glm::mat4(element.m_element.m_outTrans));
        for (Triangle triangle : triangles) {
            object.addTriangle(triangle);
        }
        objects.push_back(object);
    }

    return objects;
}

std::vector&lt;Triangle&gt; trianglesFromQuadric(const double* quadric, Cutout cutout) {
    // Define the size and resolution of the grid
    double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE];
    if (cutout.m_type == CTYPE_UNLIMITED) {
        RAYX_ERR &lt;&lt; "Unlimited cutout not supported by marching cubes";
    }
    RAYX_LOG &lt;&lt; "cutout: " &lt;&lt; cutout.m_params[0] &lt;&lt; ", " &lt;&lt; cutout.m_params[1];

    const double SCALE = 1;  // Define your desired scaling factor here

    const glm::vec3 bounding_box = glm::vec3(cutout.m_params[0], cutout.m_params[1], 1.0f);
    const glm::vec3 scale = glm::vec3(cutout.m_params[0] * SCALE / GRIDSIZE, SCALE * 1.0f, cutout.m_params[1] * SCALE / GRIDSIZE);

    // 1. Sample the 3D space
    for (int x = 0; x &lt; GRIDSIZE; x++) {
        for (int y = 0; y &lt; GRIDSIZE; y++) {
            for (int z = 0; z &lt; GRIDSIZE; z++) {
                // Convert grid coordinate to centered &amp; scaled space coordinate

                double realX = ((double(x) / GRIDSIZE) - 0.5) * bounding_box.x;
                double realY = ((double(y) / GRIDSIZE) - 0.5) * bounding_box.y;
                double realZ = ((double(z) / GRIDSIZE) - 0.5) * bounding_box.z;

                glm::vec4 pos(realX, realY, realZ, 1);
                double value = evaluateQuadricAtPosition(quadric, pos);
                scalarGrid[x][y][z] = value;
            }
        }
    }

    // 2. March through each voxel
    std::vector&lt;Triangle&gt; triangles;
    for (int x = 0; x &lt; GRIDSIZE - 1; x++) {
        for (int y = 0; y &lt; GRIDSIZE - 1; y++) {
            for (int z = 0; z &lt; GRIDSIZE - 1; z++) {
                double realX = ((double(x) / GRIDSIZE) - 0.5) * bounding_box.x;
                double realZ = ((double(z) / GRIDSIZE) - 0.5) * bounding_box.y;
                if (RAYX::CPU_TRACER::inCutout(cutout, realX, realZ)) {
                    int caseIndex = determineMarchingCubesCase(scalarGrid, x, y, z);
                    std::vector&lt;Triangle&gt; voxelTriangles = lookupTrianglesForCase(caseIndex, scalarGrid, x, y, z, scale);
                    triangles.insert(triangles.end(), voxelTriangles.begin(), voxelTriangles.end());
                }
            }
        }
    }

    return triangles;
}

double evaluateQuadricAtPosition(const double surface[16], const glm::vec4&amp; pos) {
    double icurv = surface[0];
    double a11 = surface[1];
    double a12 = surface[2];
    double a13 = surface[3];
    double a14 = surface[4];
    double a22 = surface[5];
    double a23 = surface[6];
    double a24 = surface[7];
    double a33 = surface[8];
    double a34 = surface[9];
    double a44 = surface[10];
    double result = a11 * pos.x * pos.x + a22 * pos.y * pos.y + a33 * pos.z * pos.z + a12 * pos.x * pos.y + a13 * pos.x * pos.z +
                    a23 * pos.y * pos.z + a14 * pos.x + a24 * pos.y + a34 * pos.z + a44;

    return result;
}

int determineMarchingCubesCase(const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int x, int y, int z) {
    // Based on the scalar values at the voxel corners, determine the index for the lookup tables.
    int cubeIndex = 0;

    auto test = scalarGrid[x][y][z];
    if (scalarGrid[x][y][z] &lt; 0) cubeIndex |= 1;
    auto test2 = scalarGrid[x + 1][y][z];
    if (scalarGrid[x + 1][y][z] &lt; 0) cubeIndex |= 2;
    if (scalarGrid[x + 1][y][z + 1] &lt; 0) cubeIndex |= 4;
    if (scalarGrid[x][y][z + 1] &lt; 0) cubeIndex |= 8;
    if (scalarGrid[x][y + 1][z] &lt; 0) cubeIndex |= 16;
    if (scalarGrid[x + 1][y + 1][z] &lt; 0) cubeIndex |= 32;
    if (scalarGrid[x + 1][y + 1][z + 1] &lt; 0) cubeIndex |= 64;
    if (scalarGrid[x][y + 1][z + 1] &lt; 0) cubeIndex |= 128;

    return cubeIndex;
}

std::vector&lt;Triangle&gt; lookupTrianglesForCase(int caseIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY,
                                             int offsetZ, glm::vec3 scale) {
    // Using the triTable to generate the triangles for the voxel.

    std::vector&lt;Triangle&gt; triangles;

    // triTable[caseIndex] provides the edges to be connected for the triangles.
    // Every 3 indices in the table make up a triangle.
    for (int i = 0; triTable[caseIndex][i] != -1; i += 3) {
        Triangle triangle;

        // Convert edge indices to vertices
        triangle.v1 = interpolateVertex(triTable[caseIndex][i], scalarGrid, offsetX, offsetY, offsetZ, scale);
        triangle.v2 = interpolateVertex(triTable[caseIndex][i + 1], scalarGrid, offsetX, offsetY, offsetZ, scale);
        triangle.v3 = interpolateVertex(triTable[caseIndex][i + 2], scalarGrid, offsetX, offsetY, offsetZ, scale);
        triangle.v1.color = DARKER_BLUE;
        triangle.v2.color = BLUE;
        triangle.v3.color = LIGHTER_BLUE;

        triangles.push_back(triangle);
    }

    return triangles;
}

glm::vec3 getPositionAtCorner(int cornerIndex) {
    glm::vec3 cornerPositions[8] = {
        glm::vec3(0, 0, 0),  // 0
        glm::vec3(1, 0, 0),  // 1
        glm::vec3(1, 0, 1),  // 2
        glm::vec3(0, 0, 1),  // 3
        glm::vec3(0, 1, 0),  // 4
        glm::vec3(1, 1, 0),  // 5
        glm::vec3(1, 1, 1),  // 6
        glm::vec3(0, 1, 1)   // 7
    };
    // Check for valid index
    if (cornerIndex &lt; 0 || cornerIndex &gt;= 8) {
        throw std::out_of_range("Invalid corner index");
    }
    return cornerPositions[cornerIndex];
}
Vertex interpolateVertex(int edgeIndex, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE], int offsetX, int offsetY, int offsetZ,
                         glm::vec3 scale) {
    int edgeToVertex[12][2] = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {4, 5}, {5, 6}, {6, 7}, {7, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}};

    // Define the corner-to-voxel mapping
    int cornerToVoxel[8][3] = {{0, 0, 0}, {1, 0, 0}, {1, 0, 1}, {0, 0, 1}, {0, 1, 0}, {1, 1, 0}, {1, 1, 1}, {0, 1, 1}};

    int v0Index = edgeToVertex[edgeIndex][0];
    int v1Index = edgeToVertex[edgeIndex][1];

    double value0 = getScalarValueAtCorner(cornerToVoxel[v0Index][0] + offsetX, cornerToVoxel[v0Index][1] + offsetY,
                                           cornerToVoxel[v0Index][2] + offsetZ, scalarGrid);
    double value1 = getScalarValueAtCorner(cornerToVoxel[v1Index][0] + offsetX, cornerToVoxel[v1Index][1] + offsetY,
                                           cornerToVoxel[v1Index][2] + offsetZ, scalarGrid);
    // Check for divide by zero

    double t;
    if (fabs(value1 - value0) &lt; 1e-6) {
        t = 0.5;  // or choose a reasonable default
        RAYX_LOG &lt;&lt; "Divide by zero";
    } else {
        t = (0 - value0) / (value1 - value0);
    }
    double move = (GRIDSIZE / 2.0);
    Vertex v;
    v.pos = glm::vec4((glm::mix(getPositionAtCorner(v0Index), getPositionAtCorner(v1Index), t) + glm::vec3(offsetX, offsetY, offsetZ) -
                       glm::vec3(move, move, move)) *
                          scale,
                      1.0f);

    return v;
}

double getScalarValueAtCorner(int x, int y, int z, const double scalarGrid[GRIDSIZE][GRIDSIZE][GRIDSIZE]) {
    if (x &lt; 0 || x &gt;= GRIDSIZE || y &lt; 0 || y &gt;= GRIDSIZE || z &lt; 0 || z &gt;= GRIDSIZE) {
        throw std::out_of_range("Invalid corner index");
    }
    return scalarGrid[x][y][z];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-our-formatter"><a class="header" href="#how-to-use-our-formatter">How to use our formatter</a></h1>
<p>In RAYX we decided on using a formatter to keep our code clean and organized. Here you can read how to use it.</p>
<h2 id="general-1"><a class="header" href="#general-1">General</a></h2>
<p>We use clang-format for this purpose. The style is defined in the .clang-format file in the project root. As you can see in the file, our style is based on the Google C++ style. Remember: the formatter just completes our style guide and doesn't replace it.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>If you are using Visual Studio Code you can use the C/C++ extension for formatting. It includes the clang-format binary so you just need to change a few settings to configure it correctly. You can see the changes (highlighted in red) in the following screenshots:</p>
<p><img src="Tools/../res/format1.png" alt="image" /></p>
<p>The following settings control, when the formatting should happen. This is up to you as long as the commited code is formatted.</p>
<p><img src="Tools/../res/format2.png" alt="image" /></p>
<h3 id="using-format-all-files-in-workspace"><a class="header" href="#using-format-all-files-in-workspace">Using <em>Format All Files in Workspace</em></a></h3>
<p>To format all the workspace at once, you can use the following <a href="https://marketplace.visualstudio.com/items?itemName=alexr00.formatallfilesinworkspace">Visual Studio Code's Extension</a>.</p>
<p>In your settings .json file, add the lines to go through the correct directories and only format C++ files:</p>
<pre><code>    "formatAll.includeFileExtensions": [
        ".cpp",
        ".h"
    ],
    "formatAll.excludeFolders": [
        "build",
        "Extern",
    ], 
</code></pre>
<p><em>WARNING</em>: Using this extension can take up some time, you'll see all targeted files opening in new tabs. Grab a cup of coffee and let it do the trick :)</p>
<h2 id="vim-integration"><a class="header" href="#vim-integration">Vim Integration</a></h2>
<p><a href="https://clang.llvm.org/docs/ClangFormat.html#vim-integration">ClangFormat — Clang 13 documentation (llvm.org)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-in-rayx"><a class="header" href="#testing-in-rayx">Testing in RAYX</a></h1>
<p>There are several kinds of tests:</p>
<h2 id="testing-c-code"><a class="header" href="#testing-c-code">Testing C++ Code</a></h2>
<p>testing only c++ code and not using the shader, to check if parameters of optical elements are calculated correctly</p>
<p>check especially if the values that are derived from given user parameters and given to the shader are correct. These include the surface Parameters, the object parameters, the element parameters and the world to element and element to world coordinate transformation matrices, each of which are stored in an 16 element value array.</p>
<h2 id="testing-shader-code-test_shadercpp"><a class="header" href="#testing-shader-code-test_shadercpp">Testing Shader Code (test_shader.cpp)</a></h2>
<p>The testing suite "Tracer" contains unit tests that check if the individual functions in the shader code are behaving as expected. As the functions that are tested are on the shader and in our current framework the only values that can be moved to the shader are mainly the Ray and Optical Element buffers, we cannot just call the functions with the required input values.
Instead we first store the test values in Rays on the C++ side and retrieve them from the Rays on the shader side. Then the test can be executed on the shader and the results are stored again in the Ray buffer (outputRays). Back on the C++ side this can then be compared with the expected values.</p>
<p>Example: Testing the refraction function <br>
The refraction function on the shader calculates the direction and weight of the refracted ray from the direction of the incoming ray, the normal at the intersection and the line density. The input to the test should therefore be:</p>
<ul>
<li>dvec3 <strong>direction</strong></li>
<li>dvec3 <strong>normal</strong></li>
<li>double <strong>lineDensity</strong></li>
<li>double <strong>weight</strong></li>
</ul>
<p>The output and therefore the values to verify are:</p>
<ul>
<li>dvec3 <strong>direction_out</strong></li>
<li>double <strong>weight_out</strong></li>
</ul>
<p>after the refraction</p>
<p>To move the test data to the shader and retrieve the results after applying the function we use the Ray buffer. Each test case is encoded in one Ray and we can add as many test cases as we want to the ray buffer. A ray consists of:</p>
<ul>
<li>dvec3 <strong>position</strong></li>
<li>dvec3 <strong>direction</strong></li>
<li>double <strong>energy</strong></li>
<li>double <strong>weight</strong></li>
<li>dvec4 <strong>stokes</strong></li>
<li>double <strong>order</strong></li>
<li>double <strong>pathLength</strong></li>
<li>double <strong>lastElement</strong></li>
<li>double <strong>extra Parameter</strong></li>
</ul>
<p>We can for example encode the test values for the refraction test as:</p>
<ul>
<li>dvec <strong>position</strong> \(\leftarrow\) <strong>normal</strong></li>
<li>dvec <strong>direction</strong> \(\leftarrow\) <strong>direction</strong></li>
<li>double <strong>energy</strong> \(\leftarrow\) <strong>lineDensity</strong></li>
<li>double <strong>weight</strong> \(\leftarrow\) <strong>weight</strong></li>
<li>others \(\leftarrow\) 0</li>
</ul>
<p>For this, we can use the function "addTestSetting" that receives the test values in the correct order, creates a ray and adds it to a given ray vector which is in this case the one that will be transferred to the shader (std::vector&lt;RAYX::Ray&gt; <strong>testValues</strong>).
To be able to verify the result that we will later retrieve from the shader, we need to store also the expected direction_out and weight_out. To make the comparison later easier we also store these in a Ray that corresponds to the test case and add it to std::vector&lt;RAYX::Ray&gt; <strong>correct</strong> using for example the following encoding:</p>
<ul>
<li>dvec <strong>position</strong> \(\leftarrow\) (0,0,0)</li>
<li>dvec <strong>direction</strong> \(\leftarrow\) <strong>direction_expected</strong></li>
<li>double <strong>energy</strong> \(\leftarrow\) 0</li>
<li>double <strong>weight</strong> \(\leftarrow\) <strong>weight_expected</strong></li>
<li>others \(\leftarrow\) 0</li>
</ul>
<p>Now we have in both vectors one Ray for each test case, where <strong>testValues</strong> contains the values that we move to the shader and <strong>correct</strong> contains those that we expect to get back. Now, we can move <strong>testValues</strong> as the Ray buffer to the shader.</p>
<p>Then, on the shader side we need to make sure that the test values are "unpacked" correctly from the ray buffer. We can execute the function and store the updated direction and weight in the output ray buffer in the same format as they are stored in <strong>correct</strong> on the C++ side which is:</p>
<ul>
<li>dvec <strong>position</strong> \(\leftarrow\) (0,0,0)</li>
<li>dvec <strong>direction</strong> \(\leftarrow\) <strong>direction_out</strong></li>
<li>double <strong>energy</strong> \(\leftarrow\) 0</li>
<li>double <strong>weight</strong> \(\leftarrow\) <strong>weight_out</strong></li>
<li>others \(\leftarrow\) 0</li>
</ul>
<p>These Rays are returned to the C++ test code as <strong>outputRays</strong> where the can be compared with compareFromCorrect(correct, outputRays, tolerance); for a given tolerance.</p>
<p>For other functions, like the approximation of sinus for example, we do not necessarily need the <strong>correct</strong> vector but we can simply apply the function sin() to the <strong>testValues</strong> and compare them directly with: <br>
auto sinfun = fn&lt;double, double&gt;([](double x) { return sin(x); }); <br>
compareFromFunction(sinfun, testValues, outputRays, tolerance);</p>
<p>If a test has more test values than a ray has paramters, one could use the opticalElement buffer and add e.g. one opticalElement for each test case.</p>
<p>To make things even more complicated, we also need to have an id for each test to distinguish on the shader side which test is run and how the rays should be interpreted. The id is set in the surfaceParams of an optical Element. Because we want to have only one main function on the shader we also have to distinguish between a test case and a normal run of a beamline. This is achieved by setting the id to 0 if it is a beamline and to the test id otherwise (there is no test with id=0).</p>
<h2 id="testing-beamlines-test_shadercpp"><a class="header" href="#testing-beamlines-test_shadercpp">Testing Beamlines (test_shader.cpp)</a></h2>
<p>Tests from the testing suite opticalElements read a beamline from a given rml file, run the tracer on it and writes the returned rays to a csv file with the same name as the rml file.
If the beamlines give deterministic results, we can compare them with the output of RAY-UI using the test.py file. Therefore it is necessary to export the traced data from the same beamline traced in RAY-UI. Moreover, the beamline needs to end with an image plane because of the different coordinate systems that are used (Ray coodinates vs world coordinates).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rayx-profiling"><a class="header" href="#rayx-profiling">Rayx Profiling</a></h1>
<p>Here you can find an overview of the profiling tools used in rayx. Further reading can be done in the code (see Instrumentor.h file in "Debug"-folder).</p>
<p><em>The code for this profiler, was taken from a tutorial by TheCherno on Youtube.</em></p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The Profiling used in RAYX is a simple json export of the time each profiled function took. If you want to add profiling to a function, simply add:</p>
<p><code>RAYX_PROFILE_FUNCTION;</code></p>
<p>at the beginning of the function.</p>
<p>For profiling specific scopes, you can use <code>RAYX_PROFILE_SCOPE</code>, which takes in a name for the scoped timer.</p>
<h2 id="profiled-data"><a class="header" href="#profiled-data">Profiled Data</a></h2>
<p>The data will be output to the directory, the executable was started in. You can use the tracing functionality of any chromium based browser to read the data.</p>
<p>For example, use the URL "chrome://tracing" for the Chrome browser.</p>
<h2 id="sessions"><a class="header" href="#sessions">Sessions</a></h2>
<p>The profiling can happen in multiple sessions. You can't have to sessions running at the same time though. This is functionality is mainly supposed to give the option to separate data for different parts of the program.</p>
<p>An example would be seperating measurements into <em>startup, runtime, shutdown.</em></p>
<p>The Macros used to create and end sessions:</p>
<ul>
<li><code>RAYX_PROFILE_BEGIN_SESSION</code></li>
<li><code>RAYX_PROFILE_END_SESSION</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan"><a class="header" href="#vulkan">Vulkan</a></h1>
<p>In this section we introduce our design decisions for Vulkan and how
we use it to get efficient tracing on the GPU.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkantracer-rayx"><a class="header" href="#vulkantracer-rayx">VulkanTracer (rayx)</a></h1>
<p>The VulkanTracer is a ray tracing module using VULKAN by KHRONOS GROUP to efficiently trace rays with hardware acceleration.</p>
<p>In the current version the Vulkan Engine is a Compute Class that runs as much parallel as possible on the GPU.</p>
<p>Current procedure:</p>
<ul>
<li>generate rays</li>
<li>create input and output buffers</li>
<li>initialize Vulkan</li>
<li>run the main loop</li>
<li>clean up</li>
</ul>
<p>initVulkan():</p>
<ul>
<li>create a Vulkan instance</li>
<li>set up the debug messenger</li>
<li>pick the physical device and create a logical device to access it</li>
<li>create the input and output buffers</li>
<li>create the descriptors to connect the buffers to the shader</li>
<li>create a compute pipeline and a command buffer for the shader</li>
</ul>
<p>mainLoop():</p>
<ul>
<li>run the command buffer</li>
<li>read the data from the output buffer</li>
</ul>
<hr />
<h1 id="how-the-vulkantracer-works"><a class="header" href="#how-the-vulkantracer-works"><strong>How the VulkanTracer works</strong></a></h1>
<p><img src="Vulkan/../res/vulkan_flow.png" alt="vulkan_flow" /></p>
<h2 id="buffer-types-used"><a class="header" href="#buffer-types-used"><em>Buffer types used:</em></a></h2>
<p><strong>A uniform buffer</strong> (<code>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</code>) is a descriptor type associated with a buffer resource directly, described in a shader as a structure with various members that load operations can be performed on. <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#descriptorsets-storagebuffer">More here</a></p>
<p><strong>A storage buffer</strong> (<code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code>) is a descriptor type associated with a buffer resource directly, described in a shader as a structure with various members that load, store, and atomic operations can be performed on.</p>
<hr />
<h1 id="buffers"><a class="header" href="#buffers">Buffers:</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Buffers</th><th>Size ( vkDeviceSize)</th><th>Usage</th><th>Name</th></tr></thead><tbody>
<tr><td>0</td><td>NumverOfRays*RAY_DOUBLE_AMOUNT</td><td>Transfer_DST|STORAGE_BUFFER</td><td>Ray Buffer</td></tr>
<tr><td>1</td><td>NumberOfRays*RAY_DOUBLE_AMOUNT</td><td>Transfer_SRC|STORAGE_BUFFER</td><td>Output Buffer</td></tr>
<tr><td>2</td><td>Quadric_parm+beamlineSize</td><td>STORAGE_BUFFER</td><td>Quadric Buffer</td></tr>
<tr><td>3</td><td>100</td><td>STORAGE_BUFFER</td><td>Buffer for xyznull</td></tr>
<tr><td>4</td><td>xxxxxxxxxxxxxxx</td><td>STORAGE_BUFFER</td><td>materialIndexBuf</td></tr>
<tr><td>5</td><td>xxxxxxxxxxxxxxx</td><td>STORAGE_BUFFER</td><td>materialBuf</td></tr>
<tr><td>6</td><td>xxxxxxxxxxxxxxx</td><td>STORAGE_BUFFER</td><td>debugBuffer</td></tr>
<tr><td>X</td><td>min(GPU_MAX_STAGING,numberOfRays)</td><td>STORAGE|DST|SRC</td><td>Staging Buffer</td></tr>
</tbody></table>
</div>
<h2 id="buffer-usages"><a class="header" href="#buffer-usages">Buffer Usages:</a></h2>
<p><code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> specifies that the buffer can be used as the source of a transfer command (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT).</p>
<p><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> specifies that the buffer can be used as the destination of a transfer command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-multi-shaderfile-support-shader-split"><a class="header" href="#vulkan-multi-shaderfile-support-shader-split">Vulkan multi-shaderfile support: Shader split</a></h1>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>The current compute task in RAYX is crammed into one <code>main.comp</code> compute shader file. This shader file takes care of all the computation and runs all neccessary tracing operations (bounces, collision check, etc.). As expected though, this file is huge in size, even compared to the state of the art compute shaders. As a consequence, loading this file into the GPU as instructions through Vulkan takes a while.</p>
<p>Moreover, although including one file, launching the task once and idle waiting are easy, massive flexibility and granuanilty are lost. Once the compute task starts, the CPU receives messages from the GPU only once this task has finished or failed. In the meantime, the GPU is a blackbox! To ensure correct result storage, the VRAM needs to allocate enough space for all recorded events, which leads to the output buffer's exponential increase in memory usage.</p>
<h2 id="how-to-solve"><a class="header" href="#how-to-solve">How to solve?</a></h2>
<p>The Vulkan Engine needs to undergo a refactor, so that it can create multiple compute tasks coming from different shader files. We only traget "path tracing" and already have the whole procedure in main.comp. A good start would be to split this shader file into coherent smaller files, which might help make the engine's tasks easier to handle. This would first reduce the size of each task therby help the GPU Scheduler and reduce the register load inside every Core (Nvidia SM Core). By dispatching smaller similar tasks to the GPU, these tasks are bound to finish sooner and more likely to be executed in parallel, as opposed to having idle cores due to register bottlneck or missing cache as reported by Nvidia Nsight tools in singular shader file.</p>
<p>Futhermore, this enables more debugging features as we gain more control over the control flow of the tracing algorithm. But also, the output buffer can be merged with the input buffer and read to fetch results every time a new "mini-task" has finished. The engine is supposed to treat a specific chunk of data, so it makes senes to send the data to GPU and read it back at every checkpoint, while the GPU can execute more tasks on the same data.</p>
<h3 id="vkpipeline"><a class="header" href="#vkpipeline">VKPipeline</a></h3>
<p>AFAIK, a shader <code>VkShaderModule</code> can only be bound through a unique pipeline <code>VkPipeline</code>. Hence this refactoring will center itself around this principle in the goal of making an easy-to-understand API that still doesn't require much user input.</p>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works</a></h2>
<h3 id="a-pass-is-group-of-pipelines"><a class="header" href="#a-pass-is-group-of-pipelines">A Pass is group of Pipelines</a></h3>
<p>The Vulkan Engine is made out of multiple passes. A (compute) Pass is the main class for executing a compute Program(Shader). Every Pass can have a group of pipelines to be executed sequentially. Each Pipeline is bound to a shader file.</p>
<p>Let's suppose, we have Task A, B, and C to be executed on the GPU. If A and B can be ran sequentially, but C needs some CPU intervention before being also executed on GPU, then a possible composition would be to <code>createComputePipelinePass()</code> with A and B in the same Pass (containing 2 pipelines/shaders) and another Pass with only C. A Compute Command recorded for the first Pass will execute for both A and B. Another one is needed for C.</p>
<p><img src="Vulkan/../res/split1.png" alt="How to create passes" /></p>
<h3 id="flow-management"><a class="header" href="#flow-management">Flow management</a></h3>
<p>To follow vulkan usage styles, the vulkan engine is initiliazed once. Then, as we use a batching system, we prepare the Passes (descirptor updating, necessary buffer reallocation, etc. ), run the the required compute task, cleanup, and repeat.</p>
<p><img src="Vulkan/../res/split2.png" alt="Flow" /></p>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h3>
<p>For buffer-descriptor-Pass binding, a new <code>BufferHandler</code> is created. This manages and prepares the buffers needed for the compute tasks.</p>
<p>The <code>BufferHandler</code> binds, following vulkan rules, the buffers to the correct pass, makes sure that the needed size is available and takes care of the transfer and write operation from and to the GPU.</p>
<p>A new buffer is created <code>ray-meta</code> which contains unique data to each ray (seed, ctr or state). This data also persists between bounces.</p>
<h2 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros:</a></h3>
<ul>
<li>
<p>Multiple shader files:</p>
<p>The engine supports more than one shader file, which was the main goal at the beginning. It is now easy to introduce a new shader into the engine, for example ray generation-only tasks, sorting and ray marching.</p>
</li>
<li>
<p>More flexibility and ease of debugging:</p>
<p>The vulkan engine now has more features and much more function calls that makes implementing new ideas faster. It is easier now to fetch more information from the GPU, since the CPU gets more messages in return (every bounce).</p>
</li>
<li>
<p>Less memory usage:</p>
<p>The same buffer <code>ray-buffer</code> is now input and output. The output-only buffer is removed. The size of this buffer is <code>rayAmount</code> instead of being <code>rayAmount*maxBounces</code>.</p>
</li>
<li>
<p>More openings for optimization and parallelism. [Looks at Vulkan-Beyond page]</p>
</li>
<li>
<p>Most of the classes (Pipelines, shaders, buffers, descriptors) are written in a way that graphic pipelines can also be supported (With more code obviously)</p>
</li>
<li>
<p>OOP, destruction, and vulkan cleanup</p>
<p>The new engine moves away from the C-style Vulkan version and creates objects with constructs, smart-pointers and destructors. As a consequence, memory leaks are less bound to happen and syntax is clearer. For example:</p>
<pre><code>// Create a buffer with rayList content
bufferHandler
        -&gt;createBuffer&lt;Ray&gt;({"ray-buffer", VKBUFFER_INOUT}, rayList); 
</code></pre>
<pre><code>// @brief Use ComputePipelineCreateInfo to build a new computePipeline
struct ComputePassCreateInfo {
    const char* passName;
    std::vector&lt;Pass::PipelineCreateInfo&gt; pipelineCreateInfos = {};
    int descriptorSetAmount = 1;
};
</code></pre>
<pre><code>// Explicit passes cleanup
for (auto pass : m_computePasses) {
    for (auto&amp; pipeline : pass-&gt;getPipelines()) {
        pipeline-&gt;cleanPipeline(m_Device);
    }
}
</code></pre>
</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>The internal vkAPI is now a relatively harder to understand as we offer the user more power with compute tasks.</li>
<li>More advanced vulkan synchronization (Fences, multi-pass etc.) are used, which means more pitfalls.</li>
<li>The new version is slower as it relies more on I/O Transfers from and to the GPU. However, this can be analyzed and further optimized. We believe that this version has potential to run faster then original single-shader version.</li>
<li>Some vulkan aspects are obviously not optimized, but are ignored as this was planned to be an easy-to-understand prototype: (Descirptors are all still bound to once set, Pushconstants are global and still do not support multi-pass system)</li>
<li>Unknown undefined behaviour (Hence this shader is not merged)</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This was rather a successful experiment. I (<em>OS</em>) learned much more about Vulkan and GPUs. Once it is time to work on the vulkan engine in RAYX. This is by far, a high priority.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-one-stage-compute-pipeline-and-beyond-a-vulkan-case-study"><a class="header" href="#vulkan-one-stage-compute-pipeline-and-beyond-a-vulkan-case-study">Vulkan one stage Compute Pipeline and beyond... A Vulkan Case Study</a></h1>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p><em>Please note that this page has been written from a Vulkan beginner's perspective. All information and facts are bound to change and tend to be misleading at times.</em></p>
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>We have followed an extensive research on RAYX Execution Model on the GPU side and found plenty of rabbit holes and possible bottlenecks that might lead to future misbehaviours or loss in performance. In this blog-like post, we explain some of the mentioned issues and possible solutions to overcome them. When needed, this post can be a starting point to a code refraction in RAYX.</p>
<h2 id="what-is-vulkan"><a class="header" href="#what-is-vulkan">What is Vulkan?</a></h2>
<p>The GPU is a massive die on Chip that has plenty of processing cores (Similar to a CPU Core but only with very basic Arithmetic Operations FP/INT32). The GPU excels in SIMD (Single Instrct. Multiple Data) operations. It is basically a huge parallel machine that tries to execute the same operation (Pixel coloring, coordinate calculation etc.) on a wide range of data. For this purpose, GPUs are used in a more abstract field other than simply "graphics"; General Purpose Compute on GPU (GPGPU), which is mainly what RAYX on Vulkan relies on. Vulkan? WHO?</p>
<p>Nvidia and AMD are the main GPU manufacturers. As both GPU architectures slightly differ and Nvidia ... isn't a fan of open-source... we decided to use an All-in-One compatible tool to talk to the GPU. <em>Enter Vulkan</em>. A "new" API used to control the GPU for all (Not really, we'll talk about this later) purposes developed to compete against OpenGL and alike. But most of all, open-source! Vulkan is increasingly gaining popularity and is the new state of the art for developing GPU Solutions. However it is the most NOT beginner-friendly API that you can learn. Vulkan is created to give the user the uttermost control over hardware at the price of complexity and low-level execution. It can be very fast and performant but to reach that level you need to cover all aspects and gotchas that vulkan(the dev) might fall into.</p>
<h2 id="gpu--cpu--3"><a class="header" href="#gpu--cpu--3">GPU + CPU = &lt;3</a></h2>
<p>We can talk about Vulkan and how it works for weeks and still have more topics that we haven't covered. By the way, a very effecient way to learn about it, is to simply read the Vulkan-Samples made by Khronos and others.  But let's suppose that we have already created a working Vulkan Environment and we are ready to talk with the GPU... "GPU, do this!".</p>
<p>To do as such, we need to record a <strong>Command</strong> in a <strong>Command Buffer</strong>. The Vulkan <strong>Pipeline</strong> will know which installement we need and which <strong>Shader Module</strong> we intend to run the GPU. The Command is then stored in a <strong>Queue</strong>. The Queue can be seen as a stack memory that accepts commands sequenctually... A then B then C... The Queue is <strong>submitted</strong> to the GPU. Finally we simply <strong>wait until idle</strong> i.e wait until our gpu compute code is terminated as we don't need any render workload or such from the GPU. So that we can proceed with further code.</p>
<p>All of this is executed on the CPU-side. The GPU takes the heavy-lifting and the actual execution of Compute only once queue is submitted. This is a good example of async computation which means that two things are doing seperate operations and they <strong>Synchronize</strong> with each other at different times. The CPU proceeds with data analysis or plotting only when the GPU is idle.</p>
<p>Through Vulkan, the GPU offers about 16 Queue Families (Check your vkinfo) to stack commands inside for execution. Hence the described procedure does not happen once in a standard GPU pipeline and does not have to be unique.</p>
<h2 id="nvidia-ga102-dive"><a class="header" href="#nvidia-ga102-dive">Nvidia GA102 Dive</a></h2>
<p><a href="https://www.nvidia.com/content/PDF/nvidia-ampere-ga-102-gpu-architecture-whitepaper-v2.pdf">You can find GA102 Architecture whitepaper at Nvidia's</a></p>
<p>Before discussing the issues at hand, now is a good chance to dip our hands a bit in the Hardware Side of Nvidia's latest GPU high-end architecture. Although, the dies become faster, and more power demanding, the idea behind a gpu still remains the same throughout the last generations.</p>
<p>A full GPU is mainly made out of memory and execution cores.
The execution cores can be seen as a hierachical abstraction. The GPU (GA102 as reference) has 7 GPCs. Each GPC consists of 12 TPCs. Each TPC is made out of 2 SMs. Each SM has a <strong>Warp Scheduler, a 64KB register File (Registers), Load/Store Units and 32 CUDA FP32/INT32 cores.</strong></p>
<p>This GPU has 84 SMs overall and that is the most important unit in understanding the GPU Design. An SM (Streaming Multiprocessor) is a scalable core and a Cuda Core is the arithmetic brain for operations inside the SM.</p>
<p><img src="https://tpucdn.com/review/nvidia-geforce-ampere-architecture-board-design-gaming-tech-software/images/ampere-sm.jpg" alt="image1" /></p>
<p>Memory consists of a big VRAM (DRAM) outside of the SoC, L2 Cache and a smaller faster L1 Cache closer to every SM. The register file inside the SM is the fastest and it's used to store any temporary values or branch jump "pointers".</p>
<p>L1 Cache can also be split into some shared memory that threads can concurrently share at the same time, depending on the configuration.</p>
<p>In the Compute Model, we talk about Warps, hence the warp scheduler. Warps are a "virtual" budnel of threads (Also called Wavefronts at AMD) made out of a pack of 32 Threads that are executed together. The Warp Scheduler takes care of issueing and disaptching the warps from the Intstruction bank to the SMs and cuda cores. It's only up to the Dev to correctly set the size of the Workload and its scalability. The Warp Scheduler will handle the rest.</p>
<h2 id="warps--divergence"><a class="header" href="#warps--divergence">Warps &amp; Divergence</a></h2>
<p>SMs execute instructions in warps, each warp consists of 32 Threads. It is important to notice that all warps in one SM execute the same instruction. Once done the scheduler issues the next instruction or decides to schedule another warp if the current has to stall for e.g. (Priority scheduling). The GA102 can schedule 4 warps at one cycle as seen in the figure. The Warp Scheduler is still a black box and very few documents describe it's exact functional model. It's also a piece that changes from one architecture to another and handles data and execution differently. Furthermore, the Warps do not directly map to the local group size and global work size in Vulkan.</p>
<p>A warp is considered active from the point its threads start executing until all threads have finished. SMs have a limit on the number of active warps, meaning the remaining inactive warps will need to wait until the current active ones are finished execuring. The ratio of active warps on an SM to the maximum number of active warps on the SM is called occupancy.</p>
<p>If the code to be executed has if clauses then some threads inside the warp have to execute with masks (Not do anything as the if condition is false ) and the else branch would need to also execute AFTER the warp is done with the first part. This is called Warp Divergence. Even if modern GPUs are becoming better with handling the divergence. Compilers tend to also optimize the shader. It's still viewed as one of the DONT in parallel compute.</p>
<h1 id="the-current-vulkan-execution-pipeline"><a class="header" href="#the-current-vulkan-execution-pipeline">The current Vulkan Execution Pipeline</a></h1>
<h2 id="vkdispatch"><a class="header" href="#vkdispatch">vkDispatch()</a></h2>
<p>The current RAYX Tracer uses 1 Vulkan Pipeline consisting of 1 Shader Module. The Shader module is dispatched once with the amount of needed threads (Rays) through 1 Compute Queue and the GPU would handle the rest.</p>
<p><img src="Vulkan//docs/src/res/vulkan-beyond0.png" alt="image0" /></p>
<p>The fence shows that we are waiting for the GPU to become idle.</p>
<h2 id="shader-ifs"><a class="header" href="#shader-ifs">Shader ifs</a></h2>
<p>The current shader code has many if elif elif branchs which would cause internally a huge amount of divergence. According to <a href="https://docs.nvidia.com/cuda/ampere-tuning-guide/index.html">nvidia's devoloper guide</a> for tuning:</p>
<blockquote>
<p>The high-priority recommendations from those guides are as follows:</p>
<ul>
<li>Find ways to parallelize sequential code.</li>
<li>Minimize data transfers between the host and the device.</li>
<li>Adjust kernel launch configuration to maximize device utilization.</li>
<li>Ensure global memory accesses are coalesced.</li>
<li>Minimize redundant accesses to global memory whenever possible.</li>
<li><strong>Avoid long sequences of diverged execution by threads within the same warp.</strong></li>
</ul>
</blockquote>
<p>The divergence and the need to schedule each divergence is a waste of SMs. Our main function is an if clause by itself, inside of it are more ifs. This is one of the major flows of writing GLSL that we seem to be trapped in for now. Even with compiler optimization and the fact that modern GPUs can easily handle warp divergence, it's still one of the main issues that need to be fixed. New architectures include better divergence methods but we shouldn't rely only on that for better performance.</p>
<p>One thing to consider is that usually most ray bundles react the same way in very small finite surfaces. The divergence only happens at the extremeties of said surfaces/objects or wasteboxes.</p>
<h3 id="creating-shader-modules"><a class="header" href="#creating-shader-modules">Creating Shader Modules</a></h3>
<p>To create a pipeline for anything-vulkan, we need to first upload the shader code to the GPU. The shader code is created inside a shader module with the main function as it's entry point. The GLSL code files in RAYX are all packed together and uploaded once. This bundle is too big for standard shader codes and it causes setup speed-loss as vulkan usually hangs in this step waiting for all instructions to be streamed to the GPU.</p>
<h2 id="nsight-graphics-metrics"><a class="header" href="#nsight-graphics-metrics">Nsight Graphics Metrics</a></h2>
<p>Nvidia Nsight Graphics is a developer profiling tool that can run GPU Traces (And many other Profiling traces). It supports Vulkan natively which makes it the perfect candidate. The only problem is that RAYX still does not have a Vulkan Window as we only do compute. So Nsight Graphics is very limited and cannot catch "frames" for tracing. The GPU Trace produces a resource usage timeline and can also name the possible bottlenecks and reasons for low throughput if any. So what does Nsight Graphics say about RAYX Application?</p>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<p>Well, not good stuff..
Below are the Metrics, recorded from a run of 1.5 million Rays:</p>
<p><img src="Vulkan//docs/src/res/vulkan-beyond1.png" alt="image1" /></p>
<p>Notice:</p>
<ul>
<li>High "CS Warp Can't Launch -  Register Limited"</li>
<li>Low SM Throughput</li>
<li>High "Active SM Unused Warp slots on ative SM"</li>
</ul>
<p>The timeline shows more detailed information about the execution:</p>
<p><img src="Vulkan//docs/src/res/vulkan-beyond2.png" alt="image2" /></p>
<p>Notice the bottlneck in the Compute Warps, stopping at almost 25% and the constant CS Warp Can't launch.</p>
<p>Aren't we supposed to get a higher SM Throughput?.. Shouldn't the compute warps reach 95% ?..</p>
<h2 id="problem-explained"><a class="header" href="#problem-explained">Problem Explained</a></h2>
<p>The divergence and the massive amount of shader code to execute in one thread / Warp causes a register pressure. Furthermore we have plenty of loops inside the shader code that might have been unrolled which is causing stalled Warps and the SM being not able to issue to all available CUDA Cores at once. Per Cycle, we are only using 22% of Available Warps. The SM is only using very specific alu fonctions and not even close to hitting 10% mark of the different operations that it can do (FMA Pipe for Floating precision being 5%). This can be better improved by reducing the stalled Warps.</p>
<p>Nsight also recommends that we solve the issue  as the SM is "running out of register-file space" by moving to async compute.</p>
<p>It's however worth mentioning that this is one of the most common SM-occupancy limiters for pixel and compute shaders. <a href="https://gengwg.blogspot.com/2020/03/the-peak-performance-percentage.html">[blog]</a></p>
<h1 id="suggested-vulkan-pipeline"><a class="header" href="#suggested-vulkan-pipeline">Suggested Vulkan pipeline</a></h1>
<h2 id="async-compute"><a class="header" href="#async-compute">Async Compute</a></h2>
<p>To solve this we use the queue in vulkan and send as many small known commands as possible with smaller shader codes instead of one big block of GLSL. We use multiple Compute Queues if needed and let the Warp Scheduler control the rest. We obviously need  a few synchronization points as we are now out of the global scope i.e we need to wait until rays intersect before reflecting, to send more specific commands. This is getting closer an async ompute model! For each stage/compute step we dedicate a vkPipeline preloaded with the shader and all what's left is to correctly bind the Descriptor Sets and push the command at the right time into the Queue.</p>
<p>The new Compute Pipeline Pass:
<img src="Vulkan//docs/src/res/vulkan-beyond3.png" alt="image3" /></p>
<p>A look into a standard usage of queues:
<img src="Vulkan//docs/src/res/vulkan-beyond4.png" alt="image4" /></p>
<p>One issue remains to be solved (or mainly discussed) is as now we are sending commands per Object and per run. We need to know what type of object the ray intersects to feed it the correct shader module. For that we propose these solutions:</p>
<p><img src="Vulkan//docs/src/res/vulkan-beyond5.png" alt="image5" /></p>
<p>The solutions are straight-forward. Solution 2 and 5 are the top-picks as they rely on on async compute the most.</p>
<p>This is still a bound-to-fail idea as we are not sure if it will solve the register and idle Warps problem. But it will surely change some the vulkan code structure.</p>
<h3 id="pros-1"><a class="header" href="#pros-1">Pros:</a></h3>
<ul>
<li>Better readability</li>
<li>Easier debugging as now if the compute unit fails there is no way of finding where and what happened inside the GPU.</li>
<li>Better SM occupancy and throughput as the code to be executed becomes more similar, smaller and easier to run in parallel on multiple Wraps at a time WITHOUT need for divergence scheduling.</li>
</ul>
<h3 id="cons-1"><a class="header" href="#cons-1">Cons:</a></h3>
<ul>
<li>More complicated</li>
<li>Memory Synchronization is needed to avoid read before write and overwrite. This can hinder performance if done wrong.</li>
<li>More Shaders, and the sum of all shaders combined will be bigger than one shader for all. (Duplicate help functions etc..)</li>
</ul>
<p>The main goal is that the pros and the wasted Unused Warps would overcome the cons mentioned.</p>
<h1 id="opencl-vs-vulkan"><a class="header" href="#opencl-vs-vulkan">OpenCL vs Vulkan</a></h1>
<p>A big downset of the new implementation is that it's still being made inside Vulkan. For that we can replace all of Vulkan's API with a pure GPGPU API: OpenCL.</p>
<p>As mentioned earlier Vulkan is not meant to be purely for compute as CUDA or OpenCL etc. but to include compute stages betweenn other render passes. Which makes the pure compute dev work even harder and more time consuming.</p>
<p>OpenCL is lightweight and easier to understand and recreate than Vulkan. It's definitely not faster than OpenCL. It's also older. But still valid for such cases and most of all supported by nvidia and amd.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rayx-ui-1"><a class="header" href="#rayx-ui-1">RAYX-UI</a></h1>
<h2 id="code-documentation"><a class="header" href="#code-documentation">Code Documentation</a></h2>
<ul>
<li><a href="RAYX-UI/./Triangulation.html">Triangulation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-triangulation"><a class="header" href="#2d-triangulation">2D Triangulation</a></h1>
<p>The triangulation algorithm is based on the algorithm presented in <a href="https://archive.org/details/computationalgeo00berg">Computational Geometry</a></p>
<h2 id="initial-polygon-representation"><a class="header" href="#initial-polygon-representation">Initial polygon representation</a></h2>
<p>The polygons are represented as a collection of paths for faces and holes.
Faces are ordered in counter-clockwise order and holes in clockwise order.</p>
<h2 id="edge-list"><a class="header" href="#edge-list">Edge list</a></h2>
<p>The edge list a data structure containing all edges of the polygons.
The edges are directed.
A polygon is represented in counter-clockwise order.</p>
<p>Every edge contains:</p>
<ul>
<li>A reference to the incoming edge</li>
<li>A reference to the outgoing edge</li>
<li>The point of origin</li>
</ul>
<p>The data structure has a split method.
This method inserts two new edges and updates some incoming and outgoing references.</p>
<p>References before splitting:</p>
<ul>
<li>v_prev -&gt; v</li>
<li>u_prev -&gt; u</li>
</ul>
<p>References after splitting:</p>
<ul>
<li>v_prev -&gt; vu -&gt; u</li>
<li>u_prev -&gt; uv -&gt; v</li>
</ul>
<p>Split returns uv and vu.</p>
<p>Example:</p>
<p><img src="RAYX-UI/../res/triangulation/split.png" alt="image" /></p>
<h2 id="generate-monotone-pieces"><a class="header" href="#generate-monotone-pieces">Generate monotone pieces</a></h2>
<p>A polygon is monotone if every line in y direction intersects 0 or 2 edges.</p>
<p>The algorithm is a sweep line algorithm.
The line sweeps from +y to -y.
The algorithm requires a binary search tree, a hash map and a priority queue.
The BST contains every edge that is currently intersecting the sweep line sorted by x position of the intersection.
The hash map maps downward facing edges intersecting the sweep line to edges used for splitting.</p>
<ol>
<li>Add faces and holes to the edge list.</li>
<li>Classify edge origins as Regular, Start, End, Split or Merge vertices.</li>
<li>Add the edges to a priority queue. Priotity relation: <code>y1 &gt; y2 || (y1 == y2 &amp;&amp; x1 &lt; x2)</code></li>
<li>Initialize the BST and HM as empty.</li>
<li>Process entries of the priority queue in order.</li>
</ol>
<h3 id="classification"><a class="header" href="#classification">Classification</a></h3>
<p>Start:</p>
<p>Polygon begin</p>
<p><img src="RAYX-UI/../res/triangulation/start.png" alt="image" /></p>
<p>End:</p>
<p>Polygon end</p>
<p><img src="RAYX-UI/../res/triangulation/end.png" alt="image" /></p>
<p>Regular:</p>
<p>Standard edge</p>
<p><img src="RAYX-UI/../res/triangulation/regular.png" alt="image" /></p>
<p>Merge:</p>
<p>Merge two monotone polygons in one</p>
<p><img src="RAYX-UI/../res/triangulation/merge.png" alt="image" /></p>
<p>Split:</p>
<p>Split polygon in two monotone pieces</p>
<p><img src="RAYX-UI/../res/triangulation/split_v.png" alt="image" /></p>
<h3 id="processing-of-a-vertexedge"><a class="header" href="#processing-of-a-vertexedge">Processing of a Vertex/Edge</a></h3>
<p><code>le*</code> denotes an edge in the BST and <code>helper[le*]</code> the corresponding edge in the HM.
The left part of each diagram is the state before processing and the right part the state after processing.
The dotted line is the current sweep line.
The BST and HM can contain more entries than shown. These entries wont be modified.</p>
<h4 id="start"><a class="header" href="#start">Start</a></h4>
<p><img src="RAYX-UI/../res/triangulation/process_start.png" alt="image" /></p>
<h4 id="end"><a class="header" href="#end">End</a></h4>
<p>Origin of helper is a merge vertex:</p>
<p><img src="RAYX-UI/../res/triangulation/process_end.png" alt="image" /></p>
<p>Otherwise no new edges will be added.</p>
<h4 id="split"><a class="header" href="#split">Split</a></h4>
<p>This works for every vertex type of the helpers origin, in this example the helpers origin is a merge vertex:</p>
<p><img src="RAYX-UI/../res/triangulation/process_split.png" alt="image" /></p>
<h4 id="merge"><a class="header" href="#merge">Merge</a></h4>
<p>New edges are only added if a helpers origin is a merge vertex.
In case le1s helper is not a merge vertex, the helper of le is set to the outgoing edge of the currently processed vertex.</p>
<p><img src="RAYX-UI/../res/triangulation/process_merge.png" alt="image" /></p>
<h4 id="regular"><a class="header" href="#regular">Regular</a></h4>
<h5 id="left"><a class="header" href="#left">Left</a></h5>
<p>Origin of helper is merge vertex.</p>
<p><img src="RAYX-UI/../res/triangulation/process_regular_left.png" alt="image" /></p>
<p>Otherwise no new edge will be added.</p>
<h5 id="right"><a class="header" href="#right">Right</a></h5>
<p>Origin of helper is merge vertex.</p>
<p><img src="RAYX-UI/../res/triangulation/process_regular_right.png" alt="image" /></p>
<p>Otherwise no new edge will be added. And the helper of le is the outgoing edge of the currently processed vertex.</p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>The newly added edges are colored blue.</p>
<p><img src="RAYX-UI/../res/triangulation/monotone.png" alt="image" /></p>
<h2 id="triangulation-of-monotone-polygon"><a class="header" href="#triangulation-of-monotone-polygon">Triangulation of monotone polygon</a></h2>
<p>The algorithm requires a stack containing all not yet triangulated edges.</p>
<p>The triangulation algorithm has the following steps:</p>
<ol>
<li>Annotate each edge origin of the polygon with either left or right.</li>
<li>Initialize the stack and push the first 2 edges.</li>
<li>Process vertices (except the first 2) in decreasing y order.</li>
</ol>
<h3 id="processing"><a class="header" href="#processing">Processing</a></h3>
<p>The green edge is the current edge. The blue edges are on the stack. (ordered by y coordinate)</p>
<h4 id="current-edge-origin-is-on-the-left"><a class="header" href="#current-edge-origin-is-on-the-left">Current edge origin is on the left</a></h4>
<h5 id="edge-on-top-of-the-stack-is-on-the-left"><a class="header" href="#edge-on-top-of-the-stack-is-on-the-left">Edge on top of the stack is on the left</a></h5>
<p><img src="RAYX-UI/../res/triangulation/triang_left_left.png" alt="image" /></p>
<h5 id="edge-on-top-of-the-stack-is-on-the-right"><a class="header" href="#edge-on-top-of-the-stack-is-on-the-right">Edge on top of the stack is on the right</a></h5>
<p><img src="RAYX-UI/../res/triangulation/triang_left_right.png" alt="image" /></p>
<h4 id="current-edge-origin-is-on-the-right"><a class="header" href="#current-edge-origin-is-on-the-right">Current edge origin is on the right</a></h4>
<h5 id="edge-on-top-of-the-stack-is-on-the-right-1"><a class="header" href="#edge-on-top-of-the-stack-is-on-the-right-1">Edge on top of the stack is on the right</a></h5>
<p><img src="RAYX-UI/../res/triangulation/triang_right_right.png" alt="image" /></p>
<h5 id="edge-on-top-of-the-stack-is-on-the"><a class="header" href="#edge-on-top-of-the-stack-is-on-the">Edge on top of the stack is on the</a></h5>
<p><img src="RAYX-UI/../res/triangulation/triang_right_left.png" alt="image" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
